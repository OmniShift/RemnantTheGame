// var socket = io();

// the following values are placeholders to be received from the server on page initialization
// playerNumber refers to the index in various arrays, so ranges from 0 to 3
var playerNumber = 1;
// commName stores the commander names of all players created in the lobby
var commName = ['Ruby Blank', 'Weiss Blank', 'Blake Blank', 'Yang Xiao-Blank'];
var kingdom = [0, 1, 2, 3];
// playerByKingdom are the player numbers that control which kingdom (index 0=Mantle, 1=Mistral, 2=Vacuo, 3=Vale)
var playerByKingdom = [0,1,2,3];
// playerByPos orders the player numbers from top to bottom as they are listed on the left-hand side of the game
var playerByPos = [-1,-1,-1];

// number of cards in each player's hand and those in the draw pile (not including cards added when a new stage of war is reached)
var nOfCards = [0,0,0,0,-99];
// kingdom names, banners, and colors by player number
var kingdomNameArray = ['Atlas', 'Mistral', 'Vacuo', 'Vale'];
var kingdomPicArray = ['images/Atlas_Symbol.svg.png', 'images/Mistral_Symbol.svg.png', 'images/Vacuo_Symbol.svg.png', 'images/Vale_Symbol.svg.png'];
var kingdomColorArray = ['#D4EDF7', '#6FD5F4', '#EFA81B', '#9CF431'];
// capital's territory IDs, NOT in order of player number
var capitalTerIDs = [10, 18, 29, 35];
var continentArray = [{capital:10,start:8,end:14}, {capital:18,start:15,end:24}, {capital:29,start:25,end:30}, {capital:35,start:31,end:37}];
// frequency of common, uncommon, and rare cards in each stage of war
var common = 4;
var uncommon = 3;
var rare = 2;
// temporary generic card art
var unitImage = 'images/Ralph_unit_card.jpg';
var trapImage = 'images/Its_a_trap_card.jpg';
var utilityImage = 'images/Mayonnaise_utility.jpg';
// sizeMultiplier determines how many slots a normal-, large-, and huge-sized unit takes up in a transporter
var sizeMultipliers = [1,3,5];
/*var territoryShapeInfo = [
	/*[{x:10,y:0},{x:20,y:0},{x:20,y:100},{x:10,y:100},{x:0,y:0}],
	[{x:30,y:0},{x:40,y:0},{x:40,y:100},{x:30,y:100},{x:0,y:0}],
	[{x:50,y:0},{x:60,y:0},{x:60,y:100},{x:50,y:100},{x:0,y:0}],
	[{x:70,y:0},{x:80,y:0},{x:80,y:100},{x:70,y:100},{x:0,y:0}],
	[{x:90,y:0},{x:100,y:0},{x:100,y:100},{x:90,y:100},{x:0,y:0}],
	[{x:0,y:10},{x:100,y:10},{x:100,y:20},{x:0,y:20},{x:0,y:0}],
	[{x:0,y:30},{x:100,y:30},{x:100,y:40},{x:0,y:40},{x:0,y:0}],
	[{x:0,y:50},{x:100,y:50},{x:100,y:60},{x:0,y:60},{x:0,y:0}],
	[{x:0,y:70},{x:100,y:70},{x:100,y:80},{x:0,y:80},{x:0,y:0}],
	[{x:0,y:90},{x:100,y:90},{x:100,y:100},{x:0,y:100},{x:0,y:0}],*/
	// end of grid lines
	/*[{x:18.5,y:26.5},{x:20.5,y:18},{x:25,y:20.5},{x:27.5,y:21.5},{x:26.5,y:26},{x:24.5,y:24.5},{x:20,y:29},{x:23,y:23}],
	[{x:27.5,y:21.5},{x:29,y:20},{x:30.5,y:23.5},{x:33,y:25},{x:33,y:31.5},{x:27,y:29},{x:26.5,y:26},{x:30,y:25.75}],
	[{x:29,y:20},{x:28,y:16},{x:29,y:10.5},{x:35,y:9},{x:39.5,y:9.5},{x:41,y:10},{x:40.5,y:12},{x:35,y:13},{x:35,y:15},{x:40,y:18},{x:40,y:20.5},{x:35,y:19.5},{x:32,y:17.5},{x:29,y:20},{x:32.5,y:13.5}],
	[{x:29,y:20},{x:32,y:17.5},{x:35,y:19.5},{x:35,y:21},{x:39.5,y:26},{x:39.5,y:28},{x:37.5,y:27.5},{x:37,y:26},{x:33.5,y:23},{x:33,y:25},{x:30.5,y:23.5},{x:33,y:21}],
	[{x:33,y:28},{x:45,y:34.5},{x:45,y:36.5},{x:40,y:36.5},{x:33,y:31.5},{x:40,y:33.5}],
	[{x:27,y:29},{x:33,y:31.5},{x:32.5,y:42},{x:24,y:36},{x:24.5,y:31.5},{x:29.5,y:34}],
	[{x:33,y:31.5},{x:40,y:36.5},{x:40,y:40.5},{x:38,y:43},{x:36.5,y:40.5},{x:34,y:40.5},{x:32.5,y:42},{x:37,y:37}],
	[{x:25.5,y:37},{x:32.5,y:42},{x:31,y:50},{x:29.5,y:50.5},{x:26.5,y:45},{x:25.5,y:40},{x:29.5,y:43}],
	// end of dragon island
	[{x:17.5,y:35},{x:18.5,y:35},{x:19,y:41.5},{x:23,y:43},{x:22,y:51},{x:16,y:51},{x:17,y:45},{x:20,y:46}],
	[{x:23,y:43},{x:27,y:48.5},{x:28,y:53},{x:28,y:56},{x:24,y:56},{x:23.5,y:54.5},{x:22,y:51},{x:25.5,y:51}],
	[{x:16,y:51},{x:22,y:51},{x:23.5,y:54.5},{x:21,y:59.5},{x:14.5,y:59.5},{x:14.5,y:55},{x:19,y:55}],
	[{x:14.5,y:59.5},{x:21,y:59.5},{x:21,y:67.5},{x:18,y:69},{x:19,y:75},{x:21.5,y:77},{x:20.5,y:80.5},{x:16,y:79},{x:14,y:70},{x:14,y:64},{x:18,y:64}],
	[{x:23.5,y:54.5},{x:24,y:56},{x:27,y:56},{x:27,y:62},{x:24,y:70},{x:22.5,y:70},{x:21,y:67.5},{x:21,y:59.5},{x:24,y:62}],
	[{x:27,y:62},{x:27,y:61},{x:30.3,y:61},{x:30.3,y:70},{x:27.5,y:70},{x:25.5,y:66},{x:29,y:65}],
	[{x:25.5,y:66},{x:27.5,y:70},{x:30.3,y:70},{x:30.3,y:77},{x:27,y:78.5},{x:24.5,y:75},{x:24,y:70},{x:28,y:73}],
	// end of vacuo
	[{x:30.3,y:61},{x:34,y:60},{x:35,y:69},{x:36,y:76},{x:35,y:77.5},{x:31.5,y:77.5},{x:30.3,y:77},{x:33,y:69}],
	[{x:34,y:60},{x:40,y:54},{x:43.5,y:54},{x:45,y:59},{x:45,y:63},{x:41,y:68},{x:35,y:69},{x:40,y:61}],
	[{x:35,y:69},{x:41,y:68},{x:45,y:63},{x:45,y:59},{x:47,y:57},{x:48,y:64},{x:47,y:67},{x:43,y:74},{x:39,y:74},{x:36,y:76},{x:42,y:70}],
	[{x:40,y:54},{x:38.5,y:47},{x:39,y:46},{x:45,y:46},{x:47.5,y:48},{x:49,y:49},{x:49,y:55},{x:47,y:57},{x:45,y:59},{x:43.5,y:54},{x:44.5,y:51}],
	[{x:47,y:57},{x:49,y:55},{x:49,y:52},{x:52,y:49},{x:55.5,y:49},{x:55.5,y:52},{x:50.5,y:63.5},{x:48,y:64},{x:51.5,y:55}],
	[{x:42,y:46},{x:43,y:41},{x:45.5,y:38.5},{x:50.5,y:39.5},{x:50,y:44},{x:47.5,y:48},{x:45,y:46},{x:46.5,y:42.5}],
	[{x:50.5,y:39.5},{x:53.5,y:41},{x:53,y:49},{x:52,y:49},{x:49,y:52},{x:49,y:49},{x:47.5,y:48},{x:50,y:44},{x:52,y:44}],
	[{x:47.5,y:34},{x:48,y:28},{x:50.5,y:28.5},{x:52,y:31},{x:52.5,y:36},{x:51.5,y:37},{x:50,y:37},{x:50,y:32.5}],
	[{x:30,y:84},{x:30,y:82},{x:32,y:81.5},{x:35,y:81.5},{x:36,y:80.5},{x:38,y:80},{x:38.5,y:81},{x:38,y:82.5},{x:34.5,y:84.5},{x:35,y:82.5}],
	[{x:41.5,y:90},{x:41.5,y:88},{x:47,y:85.5},{x:47.5,y:87},{x:47,y:88.5},{x:44,y:91},{x:44.5,y:88.5}],
	// end of vale
	[{x:42.5,y:10},{x:42,y:8},{x:42,y:7.5},{x:43,y:7},{x:48,y:6.5},{x:53,y:7},{x:54,y:8},{x:55.5,y:13},{x:53.5,y:14},{x:49.5,y:12},{x:49,y:10.5},{x:52,y:10}],
	[{x:55.5,y:13},{x:54,y:8},{x:55,y:7},{x:57.5,y:7},{x:59.5,y:7.5},{x:61.5,y:6.5},{x:62.5,y:6.5},{x:63.5,y:8.5},{x:63.5,y:10},{x:58,y:13},{x:58,y:10}],
	[{x:58,y:13},{x:63.5,y:10},{x:63.5,y:8.5},{x:64.5,y:8.5},{x:65,y:13},{x:66.5,y:19},{x:66,y:20},{x:65,y:21},{x:64.5,y:19},{x:63,y:19.5},{x:62,y:15.5},{x:59.5,y:17},{x:63.5,y:13.5}],
	[{x:44,y:21},{x:44,y:20},{x:47.5,y:13},{x:49.5,y:12},{x:51.5,y:13},{x:49.5,y:18.5},{x:48.5,y:20},{x:45,y:21.5},{x:48.5,y:16}],
	[{x:48.5,y:20},{x:49.5,y:18.5},{x:51.5,y:13},{x:53.5,y:14},{x:53.5,y:15},{x:53,y:18.5},{x:53,y:21.5},{x:52.5,y:23.5},{x:48.5,y:24},{x:48,y:22},{x:51.5,y:19}],
	[{x:53,y:21.5},{x:53,y:18.5},{x:53.5,y:15},{x:53.5,y:14},{x:55.5,y:13},{x:58,y:13},{x:59.5,y:17},{x:58.5,y:19.5},{x:57,y:21.5},{x:56,y:17}],
	// end of mantle
	[{x:53,y:77},{x:53.5,y:74},{x:56,y:73.5},{x:57.5,y:75},{x:58.5,y:74},{x:57.5,y:64.5},{x:58,y:63},{x:61,y:62},{x:62,y:63.5},{x:61,y:67},{x:62,y:76},{x:61,y:78},{x:57,y:79},{x:60,y:70}],
	[{x:57.5,y:64.5},{x:57,y:62},{x:57.5,y:58},{x:58.5,y:55},{x:58.5,y:53},{x:57,y:49},{x:57.5,y:46},{x:62.5,y:45.5},{x:64.5,y:48},{x:64,y:52},{x:64,y:57.5},{x:62,y:63.5},{x:61,y:62},{x:58,y:63},{x:61.5,y:54.5}],
	[{x:57.5,y:46},{x:61,y:35},{x:68,y:33},{x:70,y:35},{x:70,y:38},{x:68,y:41.5},{x:66,y:40},{x:62.5,y:42},{x:62.5,y:45.5},{x:64,y:37.5}],
	[{x:68,y:41.5},{x:70,y:38},{x:72,y:38},{x:71.5,y:32},{x:75,y:28.5},{x:78,y:29.5},{x:77.5,y:32},{x:75,y:33.5},{x:74,y:39},{x:73,y:41.5},{x:74.5,y:43},{x:74.5,y:45},{x:68,y:45.5},{x:66,y:44.5},{x:66,y:43.5},{x:71.5,y:41}],
	[{x:62,y:63.5},{x:64,y:57.5},{x:64,y:52},{x:64.5,y:48},{x:66,y:49.5},{x:68,y:47.5},{x:68,y:45.5},{x:74.5,y:45},{x:76.5,y:47.5},{x:76,y:52},{x:72.5,y:53},{x:67,y:63},{x:65,y:64},{x:63.5,y:64},{x:68.5,y:53}],
	[{x:67,y:63},{x:72.5,y:53},{x:74,y:52.5},{x:74,y:58},{x:75,y:62},{x:73.5,y:66},{x:73.5,y:68.5},{x:71.5,y:69.5},{x:66.5,y:68},{x:71.5,y:62}],
	[{x:75,y:62},{x:74,y:58},{x:74,y:52.5},{x:76,y:52},{x:80,y:54},{x:83,y:53},{x:85,y:51},{x:85.5,y:51},{x:86,y:58},{x:85,y:64},{x:84,y:64},{x:82,y:62},{x:80,y:58}],
	// end of mistral
	[{x:67,y:93.5},{x:68,y:87},{x:69,y:86},{x:69,y:84.5},{x:65.5,y:83},{x:65.5,y:82},{x:67.5,y:81},{x:72.5,y:81},{x:72.5,y:86.5},{x:69.5,y:89},{x:68,y:93.5},{x:71,y:84}],
	[{x:72.5,y:86.5},{x:72.5,y:81},{x:74,y:79},{x:78,y:79},{x:79,y:83},{x:75.5,y:86.5},{x:75.5,y:82}],
	[{x:78,y:79},{x:80,y:75},{x:81.5,y:75.5},{x:82,y:78},{x:84,y:79.5},{x:84.5,y:82},{x:83,y:83},{x:79,y:83},{x:81,y:79.5}],
	[{x:75,y:89},{x:75.5,y:86.5},{x:79,y:83},{x:83,y:83},{x:84.5,y:82},{x:85,y:83},{x:85,y:84.5},{x:81,y:90},{x:75.5,y:90},{x:80,y:86}],
	// end of menagerie, rest is water
	[{x:20.5,y:18},{x:21,y:14},{x:25,y:13.5},{x:28.5,y:13.5},{x:28,y:16},{x:29,y:20},{x:27.5,y:21.5},{x:25,y:20.5},{x:25.5,y:16.5}],
	[{x:21,y:14},{x:20.5,y:8},{x:25.5,y:7},{x:30,y:7.5},{x:30.5,y:10},{x:29,y:10.5},{x:28.5,y:13.5},{x:25,y:13.5},{x:25.5,y:10}],
	[{x:30,y:7.5},{x:30.5,y:5},{x:34,y:4.5},{x:40,y:5},{x:39.5,y:9.5},{x:35,y:9},{x:30.5,y:10},{x:35,y:6.5}],
	[{x:39.5,y:9.5},{x:40,y:5},{x:41,y:4},{x:42.5,y:4.5},{x:43,y:7},{x:42,y:7.5},{x:42,y:8},{x:42.5,y:10},{x:49,y:10.5},{x:49.5,y:12},{x:47.5,y:13},{x:45.5,y:17},{x:42.5,y:15.5},{x:40.5,y:12},{x:41,y:10},{x:44.5,y:13}],
	[{x:43,y:7},{x:42.5,y:4.5},{x:42.5,y:3},{x:48,y:2.5},{x:53,y:4},{x:56,y:3.5},{x:58.5,y:5},{x:58,y:7},{x:55,y:7},{x:54,y:8},{x:53,y:7},{x:48,y:6.5},{x:50,y:4.5}],
	[{x:58,y:7},{x:58.5,y:5},{x:57,y:4},{x:57.5,y:3},{x:63,y:3},{x:65,y:4},{x:67,y:6.5},{x:67,y:10.5},{x:66.5,y:12.5},{x:65,y:13},{x:64.5,y:8.5},{x:63.5,y:8.5},{x:62.5,y:6.5},{x:61.5,y:6.5},{x:59.5,y:7.5},{x:64,y:5.5}],
	[{x:65,y:13},{x:66.5,y:12.5},{x:67,y:10.5},{x:68.5,y:10.5},{x:69.5,y:13},{x:70,y:19},{x:68.5,y:22},{x:67,y:21.5},{x:66,y:20},{x:66.5,y:19},{x:65,y:13},{x:68,y:16}],
	[{x:57,y:21.5},{x:58.5,y:19.5},{x:59.5,y:17},{x:62,y:15.5},{x:63,y:19.5},{x:64.5,y:19},{x:65,y:21},{x:66,y:20},{x:67,y:21.5},{x:64,y:25},{x:59.5,y:25.5},{x:61.5,y:21}],
	// end of naval 40's
	[{x:50.5,y:28.5},{x:50.5,y:23.75},{x:52.5,y:23.5},{x:53,y:21.5},{x:57,y:21.5},{x:59.5,y:25.5},{x:57.5,y:30},{x:52,y:31},{x:55,y:26}],
	[{x:35,y:15},{x:35,y:13},{x:40.5,y:12},{x:42.5,y:15.5},{x:45.5,y:17},{x:44,y:20},{x:40,y:20},{x:40,y:18},{x:40,y:14.5}],
	[{x:35,y:21},{x:35,y:19.5},{x:40,y:20.5},{x:40,y:20},{x:44,y:20},{x:44,y:21},{x:45,y:21.5},{x:44,y:24},{x:43,y:26},{x:39.5,y:26},{x:41.5,y:23}],
	[{x:45,y:36.5},{x:45,y:34.5},{x:44,y:34},{x:45,y:29.5},{x:43,y:26},{x:44,y:24},{x:45,y:21.5},{x:48.5,y:20},{x:48,y:22},{x:48.5,y:24},{x:50.5,y:23.75},{x:50.5,y:28.5},{x:48,y:28},{x:47.7,y:32},{x:46,y:32.5},{x:45.8,y:36},{x:46.5,y:26}],
	[{x:33,y:25},{x:33.5,y:23},{x:37,y:26},{x:37.5,y:27.5},{x:39.5,y:28},{x:39.5,y:26},{x:43,y:26},{x:45,y:29.5},{x:44,y:34},{x:33,y:28},{x:42.5,y:29.5}],
	[{x:39,y:46},{x:38,y:43},{x:40,y:40.5},{x:40,y:36.5},{x:45,y:36.5},{x:45.8,y:36},{x:45.5,y:38.5},{x:43,y:41},{x:42,y:46},{x:42,y:40}],
	[{x:35.5,y:40.5},{x:36.5,y:40.5},{x:38,y:43},{x:39,y:46},{x:38.5,y:47},{x:40,y:54},{x:37,y:57},{x:35.5,y:51},{x:37.5,y:48.5}],
	[{x:32,y:60.5},{x:32,y:54},{x:31,y:50},{x:32.5,y:42},{x:34,y:40.5},{x:35.5,y:40.5},{x:35.5,y:51},{x:37,y:57},{x:34,y:60},{x:33.75,y:50}],
	[{x:27,y:61},{x:27,y:56},{x:28,y:56},{x:28,y:53},{x:27,y:48.5},{x:27.5,y:47},{x:29.5,y:50.5},{x:31,y:50},{x:32,y:54},{x:32,y:60.5},{x:30.3,y:61},{x:30,y:55}],
	[{x:21,y:42.25},{x:21,y:36},{x:24,y:36},{x:25.5,y:37},{x:25.5,y:40},{x:26.5,y:45},{x:27.5,y:47},{x:27,y:48.5},{x:23,y:43},{x:23.5,y:39.5}],
	// end of naval 50's
	[{x:20,y:29},{x:24.5,y:24.5},{x:26.5,y:26},{x:27,y:29},{x:24.5,y:31.5},{x:24,y:36},{x:22.5,y:36},{x:23,y:33},{x:22.5,y:30},{x:21.5,y:29.5},{x:20.5,y:30},{x:24.5,y:28}],
	[{x:17.5,y:35},{x:16,y:33},{x:15.5,y:28},{x:16,y:24},{x:17.5,y:22.5},{x:19.5,y:22.5},{x:18.5,y:26.5},{x:20,y:29},{x:20.5,y:30},{x:21,y:32},{x:21,y:42.25},{x:19,y:41.5},{x:18.5,y:35},{x:18.5,y:30}],
	[{x:16,y:24},{x:14,y:18},{x:13,y:11},{x:16,y:5},{x:18.5,y:3.5},{x:22.5,y:3.5},{x:23,y:7.5},{x:20.5,y:8},{x:21,y:14},{x:20.5,y:18},{x:19.5,y:22.5},{x:17.5,y:22.5},{x:17.5,y:13}],
	[{x:5.5,y:19},{x:5,y:14},{x:6,y:8},{x:11,y:5},{x:15,y:7},{x:13,y:11},{x:14,y:18},{x:11,y:18},{x:8,y:21},{x:10,y:13}],
	[{x:8,y:29},{x:8,y:21},{x:11,y:18},{x:14,y:18},{x:16,y:24},{x:15.5,y:28},{x:16,y:33},{x:12.5,y:36},{x:9.5,y:34},{x:12.5,y:26}],
	[{x:7,y:38},{x:8,y:34},{x:9,y:32.5},{x:9.5,y:34},{x:12.5,y:36},{x:16,y:33},{x:17.5,y:35},{x:17,y:45},{x:11,y:44.5},{x:8,y:42},{x:13,y:40}],
	[{x:3,y:32},{x:3.5,y:23},{x:4,y:19.5},{x:5.5,y:19},{x:8,y:21},{x:8,y:29},{x:9,y:32.5},{x:9,y:32.5},{x:8,y:34},{x:7,y:38},{x:4.5,y:37.5},{x:6,y:28}],
	[{x:2.5,y:43},{x:2.5,y:40},{x:4.5,y:37.5},{x:7,y:38},{x:8,y:42},{x:6,y:44.5},{x:4,y:45},{x:5.5,y:41}],
	[{x:3,y:52},{x:3,y:47},{x:4,y:45},{x:6,y:44.5},{x:8,y:42},{x:11,y:44.5},{x:10,y:51},{x:8,y:54},{x:5,y:55},{x:7,y:49}],
	[{x:10,y:51},{x:11,y:44.5},{x:17,y:45},{x:16,y:51},{x:14.5,y:55},{x:12,y:54},{x:13.5,y:49.5}],
	// end of naval 60's
	[{x:8,y:54},{x:10,y:51},{x:12,y:54},{x:14.5,y:55},{x:14.5,y:59.5},{x:10.5,y:60.5},{x:8.5,y:58.5},{x:11,y:56.5}],
	[{x:2,y:59},{x:2.5,y:56},{x:4,y:53.5},{x:5,y:55},{x:8,y:54},{x:8.5,y:58.5},{x:6.5,y:62},{x:3.5,y:62},{x:5.5,y:58}],
	[{x:3,y:66},{x:3.5,y:62},{x:6.5,y:62},{x:8.5,y:58.5},{x:10.5,y:60.5},{x:10,y:66},{x:7,y:68},{x:7.5,y:64}],
	[{x:10.5,y:73},{x:10,y:66},{x:10.5,y:60.5},{x:14.5,y:59.5},{x:14,y:64},{x:14,y:70},{x:15.5,y:77},{x:12.5,y:79},{x:12.5,y:69}],
	[{x:4.5,y:76},{x:4,y:71},{x:5,y:67},{x:7,y:68},{x:10,y:66},{x:10.5,y:73},{x:11.5,y:76},{x:9,y:79},{x:8,y:72.5}],
	[{x:8.5,y:84},{x:9,y:79},{x:11.5,y:76},{x:12.5,y:79},{x:15.5,y:77},{x:16,y:79},{x:18.5,y:80},{x:18,y:85},{x:21,y:87},{x:21,y:91},{x:18,y:92},{x:11,y:90},{x:15,y:85}],
	[{x:10.5,y:95.5},{x:11,y:90},{x:18,y:92},{x:21,y:91},{x:21.5,y:93},{x:21,y:96.5},{x:18,y:95},{x:14,y:94.5},{x:16,y:93}],
	[{x:18,y:85},{x:18.5,y:80},{x:20.5,y:80.5},{x:27,y:82.5},{x:26.5,y:86.5},{x:24.5,y:85.5},{x:24,y:86.5},{x:21,y:87},{x:22.5,y:83.5}],
	[{x:21,y:96.5},{x:21.5,y:93},{x:21,y:91},{x:21,y:87},{x:24,y:86.5},{x:25,y:90},{x:26,y:90.5},{x:27.5,y:90},{x:30,y:90},{x:30.5,y:94},{x:29.5,y:97},{x:26,y:96},{x:26,y:93}],
	[{x:18,y:69},{x:21,y:67.5},{x:22.5,y:70},{x:24,y:70},{x:24.5,y:75},{x:25.5,y:76.5},{x:25,y:79.5},{x:21.5,y:77},{x:19,y:75},{x:22,y:73}],
	// end of naval 70's
	[{x:26.5,y:86.5},{x:27,y:82.5},{x:27,y:81},{x:25,y:79.5},{x:25.5,y:76.5},{x:27,y:78.5},{x:30.3,y:77},{x:31.5,y:77.5},{x:33.5,y:77.5},{x:34,y:81.5},{x:32,y:81.5},{x:30,y:82},{x:30,y:84},{x:34.5,y:84.5},{x:35,y:88},{x:34,y:89},{x:30,y:90},{x:27.5,y:90},{x:27,y:87.5},{x:29,y:84}],
	[{x:33.5,y:77.5},{x:35,y:77.5},{x:36,y:76},{x:39,y:74},{x:43,y:74},{x:43.5,y:78},{x:41,y:80},{x:38.5,y:81},{x:38,y:80},{x:36,y:80.5},{x:35,y:81.5},{x:34,y:81.5},{x:39,y:77.5}],
	[{x:34.5,y:84.5},{x:38,y:82.5},{x:38.5,y:81},{x:41,y:80},{x:43.5,y:78},{x:44,y:82},{x:40.5,y:85},{x:38.5,y:88},{x:36.5,y:89},{x:35,y:88},{x:39.5,y:83.5}],
	[{x:29.5,y:97},{x:30.5,y:94},{x:30,y:90},{x:34,y:89},{x:35,y:88},{x:36.5,y:89},{x:38.5,y:88},{x:39,y:92},{x:37.5,y:95.5},{x:33.5,y:97},{x:34.5,y:92.5}],
	[{x:39,y:92},{x:38.5,y:88},{x:40.5,y:85},{x:44,y:82},{x:47,y:81.5},{x:47,y:85.5},{x:41.5,y:88},{x:41.5,y:90},{x:40.5,y:92},{x:44,y:84.5}],
	[{x:37.5,y:95.5},{x:39,y:92},{x:40.5,y:92},{x:41.5,y:90},{x:44,y:91},{x:47,y:88.5},{x:47.5,y:92},{x:47,y:94.5},{x:44,y:96},{x:41,y:96.5},{x:43,y:93}],
	[{x:44,y:82},{x:43,y:74},{x:45,y:70.5},{x:47.5,y:76},{x:47.5,y:79},{x:47,y:81.5},{x:45.5,y:76.5}],
	[{x:45,y:70.5},{x:47,y:67},{x:48,y:64},{x:50.5,y:63.5},{x:52,y:67},{x:52,y:72},{x:50,y:76},{x:47.5,y:76},{x:49,y:70}],
	[{x:52,y:72},{x:52,y:67},{x:54.5,y:63},{x:57,y:62},{x:57.5,y:64.5},{x:58.5,y:74},{x:57.5,y:75},{x:56,y:73.5},{x:53.5,y:74},{x:55.5,y:69}],
	[{x:50.5,y:63.5},{x:55.5,y:52},{x:55.5,y:49},{x:57,y:49},{x:58.5,y:53},{x:58.5,y:55},{x:57.5,y:58},{x:57,y:62},{x:54.5,y:63},{x:52,y:67},{x:55.5,y:58}],
	// end of naval 80's
	[{x:62.5,y:45.5},{x:62.5,y:42},{x:66,y:40},{x:68,y:41.5},{x:66,y:43.5},{x:66,y:44.5},{x:68,y:45.5},{x:68,y:47.5},{x:66,y:49.5},{x:64.5,y:48},{x:65,y:44}],
	[{x:55,y:41},{x:56,y:36},{x:59,y:33},{x:61,y:35},{x:57.5,y:46},{x:57,y:49},{x:55.5,y:49},{x:55.5,y:46.5},{x:56,y:45},{x:56,y:43},{x:58,y:38.5}],
	[{x:50.5,y:39.5},{x:50.5,y:37},{x:51.5,y:37},{x:52.5,y:36},{x:52,y:31},{x:57.5,y:30},{x:59,y:33},{x:56,y:36},{x:55,y:41},{x:53.5,y:41},{x:54.5,y:35}],
	[{x:57.5,y:30},{x:59.5,y:25.5},{x:64,y:25},{x:63.5,y:29.5},{x:64.5,y:34},{x:61,y:35},{x:59,y:33},{x:61.5,y:30}],
	[{x:63.5,y:29.5},{x:64,y:25},{x:67,y:21.5},{x:68.5,y:22},{x:68,y:26},{x:66.5,y:27},{x:66,y:30},{x:66.5,y:33.5},{x:64.5,y:34},{x:65.5,y:27}],
	[{x:66.5,y:33.5},{x:66,y:30},{x:66.5,y:27},{x:68,y:26},{x:70.5,y:27},{x:71.5,y:32},{x:72,y:38},{x:70,y:38},{x:70,y:35},{x:68,y:33},{x:69,y:30}],
	[{x:68,y:26},{x:68.5,y:22},{x:70,y:19},{x:72,y:20},{x:73.5,y:25},{x:73.5,y:30},{x:71.5,y:32},{x:70.5,y:27},{x:71,y:24}],
	[{x:73.5,y:30},{x:73.5,y:25},{x:72,y:20},{x:75.5,y:17},{x:78.5,y:20},{x:79,y:25},{x:78,y:29.5},{x:75,y:28.5},{x:76,y:23}],
	[{x:70,y:19},{x:69.5,y:13},{x:68.5,y:10.5},{x:72,y:9.5},{x:75,y:9.5},{x:76,y:13},{x:75.5,y:17},{x:72,y:20},{x:72.5,y:14}],
	[{x:67,y:10.5},{x:67,y:6.5},{x:69.5,y:5},{x:74,y:4},{x:77,y:5.5},{x:78,y:10.5},{x:76,y:13},{x:75,y:9.5},{x:72,y:9.5},{x:68.5,y:10.5},{x:73,y:7}],
	// end of naval 90's
	[{x:75.5,y:17},{x:76,y:13},{x:78,y:10.5},{x:77,y:5.5},{x:80,y:5},{x:81,y:17},{x:78.5,y:20},{x:78.5,y:14.5}],
	[{x:79,y:25},{x:78.5,y:20},{x:81,y:17},{x:80.5,y:11},{x:85,y:9.5},{x:88,y:11},{x:89,y:18},{x:87,y:23},{x:83,y:25},{x:84,y:17.5}],
	[{x:89,y:18},{x:88,y:11},{x:89,y:7},{x:93,y:6.5},{x:96,y:9.5},{x:96.5,y:14},{x:94,y:18},{x:91.5,y:19},{x:92,y:12.5}],
	[{x:87,y:23},{x:89,y:18},{x:91.5,y:19},{x:94,y:18},{x:96.5,y:14},{x:97.5,y:16},{x:97.5,y:22},{x:95.5,y:25.5},{x:92,y:28.5},{x:89.5,y:28.5},{x:92.5,y:22.5}],
	[{x:84,y:29.5},{x:83,y:25},{x:87,y:23},{x:89.5,y:28.5},{x:92,y:28.5},{x:93,y:33},{x:89.5,y:34},{x:87,y:30},{x:86.5,y:26.5}],
	[{x:74,y:39},{x:75,y:33.5},{x:77.5,y:32},{x:79,y:25},{x:83,y:25},{x:84,y:29.5},{x:80.5,y:31},{x:79.5,y:36},{x:77.5,y:39},{x:80.5,y:28}],
	[{x:77.5,y:39},{x:79.5,y:36},{x:80.5,y:31},{x:84,y:29.5},{x:87,y:30},{x:89.5,y:34},{x:90,y:37.5},{x:89,y:39},{x:87,y:35},{x:83,y:35},{x:82,y:39},{x:79.5,y:42},{x:84,y:32.5}],
	[{x:73,y:41.5},{x:74,y:39},{x:77.5,y:39},{x:79.5,y:42},{x:80.5,y:48},{x:80,y:54},{x:76,y:52},{x:76.5,y:47.5},{x:74.5,y:45},{x:74.5,y:43},{x:77.5,y:45}],
	[{x:80,y:45},{x:79.5,y:42},{x:82,y:39},{x:83,y:35},{x:87,y:35},{x:89,y:39},{x:89,y:43},{x:87,y:47},{x:83,y:47},{x:85,y:41}],
	[{x:80,y:54},{x:80.5,y:48},{x:80,y:45},{x:83,y:47},{x:87,y:47},{x:87,y:49.5},{x:85.5,y:51},{x:85,y:51},{x:83,y:53},{x:83,y:49.5}],
	// end of naval 100's
	[{x:87,y:49.5},{x:87,y:47},{x:89,y:43},{x:89,y:39},{x:90,y:37.5},{x:89.5,y:34},{x:93,y:33},{x:93.5,y:42},{x:91,y:48.5},{x:91,y:42}],
	[{x:91,y:48.5},{x:93.5,y:42},{x:93,y:33},{x:92,y:28.5},{x:95,y:26},{x:96.5,y:30},{x:97,y:42},{x:97,y:49},{x:93.5,y:50.5},{x:95,y:39}],
	[{x:86,y:58},{x:85.5,y:51},{x:87,y:49.5},{x:91,y:48.5},{x:93.5,y:50.5},{x:93,y:55},{x:90.5,y:58},{x:89.5,y:53}],
	[{x:91,y:63},{x:90.5,y:58},{x:93,y:55},{x:93.5,y:50.5},{x:97,y:49},{x:97,y:56},{x:95,y:61},{x:94.5,y:56.5}],
	[{x:84,y:68},{x:84,y:64},{x:85,y:64},{x:86,y:58},{x:90.5,y:58},{x:91,y:63},{x:91,y:68},{x:87.5,y:69},{x:88,y:63.5}],
	[{x:73.5,y:68.5},{x:73.5,y:68},{x:75.5,y:68.5},{x:77,y:68},{x:76.5,y:65.5},{x:73.5,y:66},{x:75,y:62},{x:82,y:62},{x:84,y:64},{x:84,y:68},{x:81,y:70},{x:75.5,y:70},{x:80,y:66}],
	[{x:74,y:79},{x:74,y:73},{x:75.5,y:70},{x:80,y:70},{x:80,y:75},{x:78,y:79},{x:77,y:74.5}],
	[{x:67.5,y:81},{x:69,y:75.5},{x:71.5,y:75},{x:71.5,y:69.5},{x:73.5,y:68.5},{x:75.5,y:70},{x:74,y:73},{x:74,y:79},{x:72.5,y:81},{x:71.5,y:78}],
	[{x:65.5,y:82},{x:65,y:78},{x:66.5,y:68},{x:71.5,y:69.5},{x:71.5,y:71},{x:69,y:73},{x:69,y:75.5},{x:67.5,y:81},{x:67.5,y:75}],
	[{x:62,y:76},{x:61,y:67},{x:62,y:63.5},{x:63.5,y:64},{x:65,y:64},{x:67,y:63},{x:66.5,y:68},{x:65,y:78},{x:64,y:70}],
	// end of naval 110's
	[{x:57.5,y:84},{x:57,y:79},{x:61,y:78},{x:62,y:76},{x:65,y:78},{x:65.5,y:82},{x:65.5,y:83},{x:62,y:85},{x:61.5,y:81}],
	[{x:52,y:83},{x:52,y:79},{x:53,y:77},{x:57,y:79},{x:57.5,y:84},{x:57,y:88},{x:55,y:87.5},{x:54.5,y:84},{x:55,y:81}],
	[{x:47,y:81.5},{x:47.5,y:79},{x:47.5,y:76},{x:50,y:76},{x:52,y:72},{x:53.5,y:74},{x:53,y:77},{x:52,y:79},{x:52,y:80},{x:49,y:81.5},{x:51,y:77.5}],
	[{x:47,y:94.5},{x:47.5,y:92},{x:47,y:88.5},{x:47.5,y:87},{x:47,y:85.5},{x:47,y:81.5},{x:49,y:81.5},{x:50,y:88},{x:50.5,y:94.5},{x:49,y:94},{x:48.5,y:88}],
	[{x:50,y:88},{x:49,y:81.5},{x:52,y:80},{x:52,y:83},{x:54.5,y:84},{x:55,y:87.5},{x:55,y:89.5},{x:53,y:90},{x:52,y:87},{x:52,y:85}],
	[{x:50.5,y:94.5},{x:50,y:88},{x:52,y:87},{x:53,y:90},{x:55,y:89.5},{x:55,y:87.5},{x:57,y:88},{x:56.5,y:95},{x:54.5,y:93.5},{x:52.5,y:93.5},{x:53.5,y:91.5}],
	[{x:56.5,y:95},{x:57,y:88},{x:57.5,y:84},{x:62,y:85},{x:62,y:87},{x:64.5,y:88},{x:65,y:92},{x:62,y:95},{x:60.5,y:90}],
	[{x:62,y:87},{x:62,y:85},{x:65.5,y:83},{x:69,y:84.5},{x:69,y:86},{x:68,y:87},{x:67,y:93.5},{x:65.5,y:93.5},{x:65,y:92},{x:64.5,y:88},{x:66,y:87}],
	[{x:63,y:94},{x:65,y:92},{x:65.5,y:93.5},{x:68,y:93.5},{x:69.5,y:89},{x:72.5,y:86.5},{x:73,y:93},{x:73,y:94.5},{x:70.5,y:96},{x:65,y:95.5},{x:71,y:92}],
	[{x:73,y:94.5},{x:73,y:93},{x:72.5,y:86.5},{x:75.5,y:86.5},{x:75,y:89},{x:75.5,y:90},{x:81,y:90},{x:81.5,y:95.5},{x:78,y:97},{x:75,y:96.5},{x:77,y:93}],
	// end of naval 120's
	[{x:81.5,y:95.5},{x:81,y:90},{x:85,y:84.5},{x:88,y:88.5},{x:88.5,y:94},{x:87,y:96},{x:84.5,y:94.5},{x:85,y:90.5}],
	[{x:85,y:84.5},{x:85,y:83},{x:84.5,y:82},{x:84,y:79.5},{x:85,y:76.5},{x:88,y:74.5},{x:88.5,y:79},{x:91,y:80},{x:90.5,y:86},{x:88,y:88.5},{x:87.5,y:82}],
	[{x:84,y:79.5},{x:82,y:78},{x:81.5,y:75.5},{x:80,y:75},{x:80,y:70},{x:81,y:70},{x:84,y:68},{x:87.5,y:69},{x:87.5,y:71},{x:88,y:74.5},{x:85,y:76.5},{x:84,y:73}],
	[{x:88,y:74.5},{x:87.5,y:71},{x:87.5,y:69},{x:91,y:68},{x:91,y:63},{x:95,y:61},{x:96,y:67},{x:95,y:73},{x:93,y:68}],
	[{x:88.5,y:79},{x:88,y:74.5},{x:95,y:73},{x:94.5,y:79.5},{x:91,y:80},{x:91.5,y:76.5}],
	[{x:88.5,y:94},{x:88,y:88.5},{x:90.5,y:86},{x:91,y:80},{x:94.5,y:79.5},{x:94,y:87},{x:92.5,y:91.5},{x:92,y:87}],
	[{x:92.5,y:91.5},{x:94,y:87},{x:94.5,y:79.5},{x:95,y:73},{x:95.5,y:70},{x:97.5,y:73.5},{x:98,y:82},{x:97,y:92},{x:94.5,y:94},{x:96,y:82}],
];*/
// territoryShapeInfo contains all info to draw borders on the map and contains location markers for unit, capital/wall, and natural hazard icons for each territory
var territoryShapeInfo = [
	/*[{x:10,y:0},{x:20,y:0},{x:20,y:100},{x:10,y:100},{x:0,y:0}],
	[{x:30,y:0},{x:40,y:0},{x:40,y:100},{x:30,y:100},{x:0,y:0}],
	[{x:50,y:0},{x:60,y:0},{x:60,y:100},{x:50,y:100},{x:0,y:0}],
	[{x:70,y:0},{x:80,y:0},{x:80,y:100},{x:70,y:100},{x:0,y:0}],
	[{x:90,y:0},{x:100,y:0},{x:100,y:100},{x:90,y:100},{x:0,y:0}],
	[{x:0,y:10},{x:100,y:10},{x:100,y:20},{x:0,y:20},{x:0,y:0}],
	[{x:0,y:30},{x:100,y:30},{x:100,y:40},{x:0,y:40},{x:0,y:0}],
	[{x:0,y:50},{x:100,y:50},{x:100,y:60},{x:0,y:60},{x:0,y:0}],
	[{x:0,y:70},{x:100,y:70},{x:100,y:80},{x:0,y:80},{x:0,y:0}],
	[{x:0,y:90},{x:100,y:90},{x:100,y:100},{x:0,y:100},{x:0,y:0}],*/
	// end of grid lines
	[{x:18.5,y:26.5},{x:20.5,y:18},{x:25,y:20.5},{x:27.5,y:21.5},{x:26.5,y:26},{x:24.5,y:24.5},{x:20,y:29},[[{x:23,y:22.5}],[{x:22,y:22.5},{x:24,y:22.5}],[{x:21,y:22.5},{x:23,y:22.5},{x:25,y:22.5}]]],
	[{x:27.5,y:21.5},{x:29,y:20},{x:30.5,y:23.5},{x:33,y:25},{x:33,y:31.5},{x:27,y:29},{x:26.5,y:26},[[{x:30,y:26.5}],[{x:29,y:26.5},{x:31,y:26.5}],[{x:28,y:26.5},{x:30,y:26.5},{x:32,y:26.5}]]],
	[{x:29,y:20},{x:28,y:16},{x:29,y:10.5},{x:35,y:9},{x:39.5,y:9.5},{x:41,y:10},{x:40.5,y:12},{x:35,y:13},{x:35,y:15},{x:40,y:18},{x:40,y:20.5},{x:35,y:19.5},{x:32,y:17.5},{x:29,y:20},[[{x:32.5,y:14}],[{x:31.5,y:14},{x:33.5,y:14}],[{x:32.5,y:12.5},{x:31.5,y:15.5},{x:33.5,y:15.5}]]],
	[{x:29,y:20},{x:32,y:17.5},{x:35,y:19.5},{x:35,y:21},{x:39.5,y:26},{x:39.5,y:28},{x:37.5,y:27.5},{x:37,y:26},{x:33.5,y:23},{x:33,y:25},{x:30.5,y:23.5},[[{x:33.5,y:21.5}],[{x:32.5,y:21},{x:34.5,y:22}],[{x:31.5,y:20},{x:33.5,y:21.5},{x:35.5,y:23}]]],
	[{x:33,y:28},{x:45,y:34.5},{x:45,y:36.5},{x:40,y:36.5},{x:33,y:31.5},[[{x:38.5,y:33}],[{x:37.5,y:32.5},{x:39.5,y:33.75}],[{x:36.5,y:32},{x:38.5,y:33},{x:40.5,y:34}]]],
	[{x:27,y:29},{x:33,y:31.5},{x:32.5,y:42},{x:24,y:36},{x:24.5,y:31.5},[[{x:28.5,y:34}],[{x:27,y:34.5},{x:29,y:34.5}],[{x:26.5,y:34},{x:28.5,y:34},{x:30.5,y:34}]]],
	[{x:33,y:31.5},{x:40,y:36.5},{x:40,y:40.5},{x:38,y:43},{x:36.5,y:40.5},{x:34,y:40.5},{x:32.5,y:42},[[{x:36.5,y:37.5}],[{x:35.5,y:37.5},{x:37.5,y:37.5}],[{x:34.5,y:37.5},{x:36.5,y:37.5},{x:38.5,y:37.5}]]],
	[{x:25.5,y:37},{x:32.5,y:42},{x:31,y:50},{x:29.5,y:50.5},{x:26.5,y:45},{x:25.5,y:40},[[{x:29,y:43.5}],[{x:28,y:43.5},{x:30,y:43.5}],[{x:27,y:43.5},{x:29,y:43.5},{x:31,y:43.5}]]],
	// end of dragon island
	[{x:17.5,y:35},{x:18.5,y:35},{x:19,y:41.5},{x:23,y:43},{x:22,y:51},{x:16,y:51},{x:17,y:45},[[{x:20,y:46}],[{x:18.5,y:46},{x:20.5,y:46}],[{x:20,y:44.5},{x:19,y:47.5},{x:21,y:47.5}]]],
	[{x:23,y:43},{x:27,y:48.5},{x:28,y:53},{x:28,y:56},{x:24,y:56},{x:23.5,y:54.5},{x:22,y:51},[[{x:25,y:50.5}],[{x:24,y:50.5},{x:26,y:50.5}],[{x:25,y:49},{x:24,y:52},{x:26,y:52}]]],
	[{x:16,y:51},{x:22,y:51},{x:23.5,y:54.5},{x:21,y:59.5},{x:14.5,y:59.5},{x:14.5,y:55},[[{x:19,y:55}],[{x:18,y:55},{x:20,y:55}],[{x:17,y:55},{x:19,y:55},{x:21,y:55}]]],
	[{x:14.5,y:59.5},{x:21,y:59.5},{x:21,y:67.5},{x:18,y:69},{x:19,y:75},{x:21.5,y:77},{x:20.5,y:80.5},{x:16,y:79},{x:14,y:70},{x:14,y:64},[[{x:17.5,y:64}],[{x:16,y:64},{x:18,y:64}],[{x:15.5,y:64},{x:17.5,y:64},{x:19.5,y:64}]]],
	[{x:23.5,y:54.5},{x:24,y:56},{x:27,y:56},{x:27,y:62},{x:24,y:70},{x:22.5,y:70},{x:21,y:67.5},{x:21,y:59.5},[[{x:24,y:62}],[{x:23,y:62},{x:25,y:62}],[{x:24,y:60.5},{x:23,y:63.5},{x:25,y:63.5}]]],
	[{x:27,y:62},{x:27,y:61},{x:30.3,y:61},{x:30.3,y:70},{x:27.5,y:70},{x:25.5,y:66},[[{x:28.25,y:65.5}],[{x:27.25,y:65.5},{x:29.25,y:65.5}],[{x:28.25,y:63.5},{x:27.25,y:66.5},{x:29.25,y:66.5}]]],
	[{x:25.5,y:66},{x:27.5,y:70},{x:30.3,y:70},{x:30.3,y:77},{x:27,y:78.5},{x:24.5,y:75},{x:24,y:70},[[{x:27.5,y:73}],[{x:26.5,y:73},{x:28.5,y:73}],[{x:25.5,y:73},{x:27.5,y:73},{x:29.5,y:73}]]],
	// end of vacuo
	[{x:30.3,y:61},{x:34,y:60},{x:35,y:69},{x:36,y:76},{x:35,y:77.5},{x:31.5,y:77.5},{x:30.3,y:77},[[{x:32.75,y:69}],[{x:31.75,y:69},{x:33.75,y:69}],[{x:32.75,y:65.5},{x:32.75,y:69},{x:32.75,y:72.5}]]],
	[{x:34,y:60},{x:40,y:54},{x:43.5,y:54},{x:45,y:59},{x:45,y:63},{x:41,y:68},{x:35,y:69},[[{x:39.75,y:61.25}],[{x:38.75,y:61.25},{x:40.75,y:61.25}],[{x:37.75,y:61.25},{x:39.75,y:61.25},{x:41.75,y:61.25}]]],
	[{x:35,y:69},{x:41,y:68},{x:45,y:63},{x:45,y:59},{x:47,y:57},{x:48,y:64},{x:47,y:67},{x:43,y:74},{x:39,y:74},{x:36,y:76},[[{x:42,y:70}],[{x:41,y:71},{x:43,y:69.5}],[{x:40,y:71.5},{x:42,y:70},{x:44,y:68.5}]]],
	[{x:40,y:54},{x:38.5,y:47},{x:39,y:46},{x:45,y:46},{x:47.5,y:48},{x:49,y:49},{x:49,y:55},{x:47,y:57},{x:45,y:59},{x:43.5,y:54},[[{x:44.5,y:51}],[{x:43.5,y:51},{x:45.5,y:51}],[{x:42.5,y:51},{x:44.5,y:51},{x:46.5,y:51}]]],
	[{x:47,y:57},{x:49,y:55},{x:49,y:52},{x:52,y:49},{x:55.5,y:49},{x:55.5,y:52},{x:50.5,y:63.5},{x:48,y:64},[[{x:51,y:56}],[{x:50,y:56},{x:52,y:56}],[{x:49.5,y:59},{x:51,y:56},{x:52.5,y:53}]]],
	[{x:42,y:46},{x:43,y:41},{x:45.5,y:38.5},{x:50.5,y:39.5},{x:50,y:44},{x:47.5,y:48},{x:45,y:46},[[{x:46.5,y:42.5}],[{x:45.5,y:42.5},{x:47.5,y:42.5}],[{x:44.5,y:42.5},{x:46.5,y:42.5},{x:48.5,y:42.5}]]],
	[{x:50.5,y:39.5},{x:53.5,y:41},{x:55,y:41},{x:56,y:43},{x:56,y:45},{x:55.5,y:46.5},{x:55.5,y:49},{x:52,y:49},{x:49,y:52},{x:49,y:49},{x:47.5,y:48},{x:50,y:44},[[{x:52.5,y:45}],[{x:51.5,y:45},{x:53.5,y:45}],[{x:50.5,y:45.5},{x:52.5,y:45.5},{x:54.5,y:45.5}]]],
	[{x:47.5,y:34},{x:48,y:28},{x:50.5,y:28.5},{x:52,y:31},{x:52.5,y:36},{x:51.5,y:37},{x:50,y:37},[[{x:50,y:32.5}],[{x:49,y:32.5},{x:51,y:32.5}],[{x:50,y:31},{x:49,y:34},{x:51,y:34}]]],
	[{x:30,y:84},{x:30,y:82},{x:32,y:81.5},{x:35,y:81.5},{x:36,y:80.5},{x:38,y:80},{x:38.5,y:81},{x:38,y:82.5},{x:34.5,y:84.5},[[{x:34.5,y:83}],[{x:33.5,y:83},{x:35.5,y:82.5}],[{x:32.5,y:83},{x:34.5,y:83},{x:36.5,y:82}]]],
	[{x:41.5,y:90},{x:41.5,y:88},{x:47,y:85.5},{x:47.5,y:87},{x:47,y:88.5},{x:44,y:91},[[{x:44.5,y:88.5}],[{x:43.5,y:89},{x:45.5,y:88}],[{x:42.5,y:89},{x:44.5,y:88.5},{x:46.5,y:87.5}]]],
	// end of vale
	[{x:42.5,y:10},{x:42,y:8},{x:42,y:7.5},{x:43,y:7},{x:48,y:6.5},{x:53,y:7},{x:54,y:8},{x:55.5,y:13},{x:53.5,y:14},{x:49.5,y:12},{x:49,y:10.5},[[{x:52,y:10}],[{x:51,y:10},{x:53,y:10}],[{x:49.5,y:8.5},{x:51.5,y:9.5},{x:53.5,y:10.5}]]],
	[{x:55.5,y:13},{x:54,y:8},{x:55,y:7},{x:57.5,y:7},{x:59.5,y:7.5},{x:61.5,y:6.5},{x:62.5,y:6.5},{x:63.5,y:8.5},{x:63.5,y:10},{x:58,y:13},[[{x:59,y:9.5}],[{x:58,y:9.5},{x:60,y:9.5}],[{x:57,y:9.5},{x:59,y:9.5},{x:61,y:9.5}]]],
	[{x:58,y:13},{x:63.5,y:10},{x:63.5,y:8.5},{x:64.5,y:8.5},{x:65,y:13},{x:66.5,y:19},{x:66,y:20},{x:65,y:21},{x:64.5,y:19},{x:63,y:19.5},{x:62,y:15.5},{x:59.5,y:17},[[{x:62.5,y:13.5}],[{x:61.5,y:13.5},{x:63.5,y:13.5}],[{x:61,y:13.5},{x:63,y:13.5},{x:64.5,y:16}]]],
	[{x:44,y:21},{x:44,y:20},{x:47.5,y:13},{x:49.5,y:12},{x:51.5,y:13},{x:49.5,y:18.5},{x:48.5,y:20},{x:45,y:21.5},[[{x:48.5,y:16}],[{x:47.5,y:17},{x:49,y:15}],[{x:46.5,y:18.5},{x:48,y:16.5},{x:49.5,y:14.5}]]],
	[{x:48.5,y:20},{x:49.5,y:18.5},{x:51.5,y:13},{x:53.5,y:14},{x:53.5,y:15},{x:53,y:18.5},{x:53,y:21.5},{x:52.5,y:23.5},{x:48.5,y:24},{x:48,y:22},[[{x:51.25,y:19}],[{x:50.75,y:20.5},{x:51.75,y:17}],[{x:50.25,y:21.5},{x:51.25,y:18.5},{x:52.25,y:15.5}]]],
	[{x:53,y:21.5},{x:53,y:18.5},{x:53.5,y:15},{x:53.5,y:14},{x:55.5,y:13},{x:58,y:13},{x:59.5,y:17},{x:58.5,y:19.5},{x:57,y:21.5},[[{x:56,y:17}],[{x:55,y:17},{x:57,y:17}],[{x:56,y:15.5},{x:55,y:18.5},{x:57,y:18.5}]]],
	// end of mantle
	[{x:53,y:77},{x:53.5,y:74},{x:56,y:73.5},{x:57.5,y:75},{x:58.5,y:74},{x:57.5,y:64.5},{x:58,y:63},{x:61,y:62},{x:62,y:63.5},{x:61,y:67},{x:62,y:76},{x:61,y:78},{x:57,y:79},[[{x:60,y:70}],[{x:59.75,y:68},{x:59.75,y:72}],[{x:60,y:66.5},{x:60,y:70},{x:60,y:73.5}]]],
	[{x:57.5,y:64.5},{x:57,y:62},{x:57.5,y:58},{x:58.5,y:55},{x:58.5,y:53},{x:57,y:49},{x:57.5,y:46},{x:62.5,y:45.5},{x:64.5,y:48},{x:64,y:52},{x:64,y:57.5},{x:62,y:63.5},{x:61,y:62},{x:58,y:63},[[{x:61,y:54.5}],[{x:60,y:54.5},{x:62,y:54.5}],[{x:61,y:53},{x:60,y:56},{x:62,y:56}]]],
	[{x:57.5,y:46},{x:61,y:35},{x:68,y:33},{x:70,y:35},{x:70,y:38},{x:68,y:41.5},{x:66,y:40},{x:62.5,y:42},{x:62.5,y:45.5},[[{x:64,y:37.5}],[{x:63,y:37.5},{x:65,y:37.5}],[{x:62,y:37.5},{x:64,y:37.5},{x:66,y:37.5}]]],
	[{x:68,y:41.5},{x:70,y:38},{x:72,y:38},{x:71.5,y:32},{x:75,y:28.5},{x:78,y:29.5},{x:77.5,y:32},{x:75,y:33.5},{x:74,y:39},{x:73,y:41.5},{x:74.5,y:43},{x:74.5,y:45},{x:68,y:45.5},{x:66,y:44.5},{x:66,y:43.5},[[{x:71,y:41.5}],[{x:70,y:41.5},{x:72,y:41.5}],[{x:71,y:40},{x:70,y:43},{x:72,y:43}]]],
	[{x:62,y:63.5},{x:64,y:57.5},{x:64,y:52},{x:64.5,y:48},{x:66,y:49.5},{x:68,y:47.5},{x:68,y:45.5},{x:74.5,y:45},{x:76.5,y:47.5},{x:76,y:52},{x:72.5,y:53},{x:67,y:63},{x:65,y:64},{x:63.5,y:64},[[{x:68.5,y:53}],[{x:67.5,y:53},{x:69.5,y:53}],[{x:66.5,y:53},{x:68.5,y:53},{x:70.5,y:53}]]],
	[{x:67,y:63},{x:72.5,y:53},{x:74,y:52.5},{x:74,y:58},{x:75,y:62},{x:73.5,y:66},{x:73.5,y:68.5},{x:71.5,y:69.5},{x:66.5,y:68},[[{x:71,y:62.5}],[{x:70,y:62.5},{x:72,y:62.5}],[{x:69,y:62.5},{x:71,y:62.5},{x:73,y:62.5}]]],
	[{x:75,y:62},{x:74,y:58},{x:74,y:52.5},{x:76,y:52},{x:80,y:54},{x:83,y:53},{x:85,y:51},{x:85.5,y:51},{x:86,y:58},{x:85,y:64},{x:84,y:64},{x:82,y:62},[[{x:80,y:58}],[{x:79,y:58},{x:81,y:58}],[{x:78,y:58},{x:80,y:58},{x:82,y:58}]]],
	// end of mistral
	[{x:67,y:93.5},{x:68,y:87},{x:69,y:86},{x:69,y:84.5},{x:65.5,y:83},{x:65.5,y:82},{x:67.5,y:81},{x:72.5,y:81},{x:72.5,y:86.5},{x:69.5,y:89},{x:68,y:93.5},[[{x:70.5,y:84.5}],[{x:70.5,y:82.75},{x:70.5,y:86.25}],[{x:69.5,y:83},{x:71.5,y:83},{x:70.5,y:86}]]],
	[{x:72.5,y:86.5},{x:72.5,y:81},{x:74,y:79},{x:78,y:79},{x:79,y:83},{x:75.5,y:86.5},[[{x:75.5,y:82.5}],[{x:74.5,y:82.5},{x:76.5,y:82.5}],[{x:74.5,y:81},{x:76.5,y:81},{x:75.5,y:84}]]],
	[{x:78,y:79},{x:80,y:75},{x:81.5,y:75.5},{x:82,y:78},{x:84,y:79.5},{x:84.5,y:82},{x:83,y:83},{x:79,y:83},[[{x:81,y:80}],[{x:80,y:80},{x:82,y:80}],[{x:81,y:78},{x:80,y:81},{x:82,y:81}]]],
	[{x:75,y:89},{x:75.5,y:86.5},{x:79,y:83},{x:83,y:83},{x:84.5,y:82},{x:85,y:83},{x:85,y:84.5},{x:81,y:90},{x:75.5,y:90},[[{x:80,y:86.5}],[{x:79,y:86.5},{x:81,y:86.5}],[{x:78,y:86.5},{x:80,y:86.5},{x:82,y:86.5}]]],
	// end of menagerie, rest is water
	[{x:20.5,y:18},{x:21,y:14},{x:25,y:13.5},{x:28.5,y:13.5},{x:28,y:16},{x:29,y:20},{x:27.5,y:21.5},{x:25,y:20.5},[[{x:25,y:17}],[{x:24,y:17},{x:26,y:17}]]],
	[{x:21,y:14},{x:20.5,y:8},{x:25.5,y:7},{x:30,y:7.5},{x:30.5,y:10},{x:29,y:10.5},{x:28.5,y:13.5},{x:25,y:13.5},[[{x:25.5,y:10}],[{x:24.5,y:10.5},{x:26.5,y:10.5}]]],
	[{x:30,y:7.5},{x:30.5,y:5},{x:34,y:4.5},{x:40,y:5},{x:39.5,y:9.5},{x:35,y:9},{x:30.5,y:10},[[{x:35,y:7}],[{x:34,y:7},{x:36,y:7}]]],
	[{x:39.5,y:9.5},{x:40,y:5},{x:41,y:4},{x:42.5,y:4.5},{x:43,y:7},{x:42,y:7.5},{x:42,y:8},{x:42.5,y:10},{x:49,y:10.5},{x:49.5,y:12},{x:47.5,y:13},{x:45.5,y:17},{x:42.5,y:15.5},{x:40.5,y:12},{x:41,y:10},[[{x:44.5,y:13}],[{x:43,y:12.5},{x:45,y:12.5}]]],
	[{x:43,y:7},{x:42.5,y:4.5},{x:42.5,y:3},{x:48,y:2.5},{x:53,y:4},{x:56,y:3.5},{x:58.5,y:5},{x:58,y:7},{x:55,y:7},{x:54,y:8},{x:53,y:7},{x:48,y:6.5},[[{x:50.5,y:5}],[{x:49.5,y:5},{x:51.5,y:5}]]],
	[{x:58,y:7},{x:58.5,y:5},{x:57,y:4},{x:57.5,y:3},{x:63,y:3},{x:65,y:4},{x:67,y:6.5},{x:67,y:10.5},{x:66.5,y:12.5},{x:65,y:13},{x:64.5,y:8.5},{x:63.5,y:8.5},{x:62.5,y:6.5},{x:61.5,y:6.5},{x:59.5,y:7.5},[[{x:64,y:5.5}],[{x:63,y:5},{x:65,y:6.5}]]],
	[{x:65,y:13},{x:66.5,y:12.5},{x:67,y:10.5},{x:68.5,y:10.5},{x:69.5,y:13},{x:70,y:19},{x:68.5,y:22},{x:67,y:21.5},{x:66,y:20},{x:66.5,y:19},{x:65,y:13},[[{x:68,y:16}],[{x:68,y:14},{x:68,y:18}]]],
	[{x:57,y:21.5},{x:58.5,y:19.5},{x:59.5,y:17},{x:62,y:15.5},{x:63,y:19.5},{x:64.5,y:19},{x:65,y:21},{x:66,y:20},{x:67,y:21.5},{x:64,y:25},{x:59.5,y:25.5},[[{x:61.5,y:21.5}],[{x:60.5,y:21.5},{x:62.5,y:21.5}]]],
	// end of naval 40's
	[{x:50.5,y:28.5},{x:50.5,y:23.75},{x:52.5,y:23.5},{x:53,y:21.5},{x:57,y:21.5},{x:59.5,y:25.5},{x:57.5,y:30},{x:52,y:31},[[{x:55,y:26}],[{x:54,y:26},{x:56,y:26}]]],
	[{x:35,y:15},{x:35,y:13},{x:40.5,y:12},{x:42.5,y:15.5},{x:45.5,y:17},{x:44,y:20},{x:40,y:20},{x:40,y:18},[[{x:41,y:16}],[{x:40,y:15},{x:42,y:17.5}]]],
	[{x:35,y:21},{x:35,y:19.5},{x:40,y:20.5},{x:40,y:20},{x:44,y:20},{x:44,y:21},{x:45,y:21.5},{x:44,y:24},{x:43,y:26},{x:39.5,y:26},[[{x:41,y:23}],[{x:40,y:23},{x:42,y:23}]]],
	[{x:45,y:36.5},{x:45,y:34.5},{x:44,y:34},{x:45,y:29.5},{x:43,y:26},{x:44,y:24},{x:45,y:21.5},{x:48.5,y:20},{x:48,y:22},{x:48.5,y:24},{x:50.5,y:23.75},{x:50.5,y:28.5},{x:48,y:28},{x:47.7,y:32},{x:46,y:32.5},{x:45.8,y:36},[[{x:46.5,y:26}],[{x:45.5,y:26},{x:47.5,y:26}]]],
	[{x:33,y:25},{x:33.5,y:23},{x:37,y:26},{x:37.5,y:27.5},{x:39.5,y:28},{x:39.5,y:26},{x:43,y:26},{x:45,y:29.5},{x:44,y:34},{x:33,y:28},[[{x:42,y:29.5}],[{x:41,y:29.5},{x:43,y:29.5}]]],
	[{x:39,y:46},{x:38,y:43},{x:40,y:40.5},{x:40,y:36.5},{x:45,y:36.5},{x:45.8,y:36},{x:45.5,y:38.5},{x:43,y:41},{x:42,y:46},[[{x:41.75,y:40.5}],[{x:41,y:42},{x:42.5,y:39}]]],
	[{x:35.5,y:40.5},{x:36.5,y:40.5},{x:38,y:43},{x:39,y:46},{x:38.5,y:47},{x:40,y:54},{x:37,y:57},{x:35.5,y:51},[[{x:37.25,y:48.5}],[{x:37.25,y:46.5},{x:37.25,y:50.5}]]],
	[{x:32,y:60.5},{x:32,y:54},{x:31,y:50},{x:32.5,y:42},{x:34,y:40.5},{x:35.5,y:40.5},{x:35.5,y:51},{x:37,y:57},{x:34,y:60},[[{x:33.75,y:50}],[{x:33.75,y:48},{x:33.75,y:52}]]],
	[{x:27,y:61},{x:27,y:56},{x:28,y:56},{x:28,y:53},{x:27,y:48.5},{x:27.5,y:47},{x:29.5,y:50.5},{x:31,y:50},{x:32,y:54},{x:32,y:60.5},{x:30.3,y:61},[[{x:30,y:55}],[{x:30,y:54},{x:30,y:58}]]],
	[{x:21,y:42.25},{x:21,y:36},{x:24,y:36},{x:25.5,y:37},{x:25.5,y:40},{x:26.5,y:45},{x:27.5,y:47},{x:27,y:48.5},{x:23,y:43},[[{x:23.5,y:40}],[{x:22.75,y:38.5},{x:24.25,y:41.5}]]],
	// end of naval 50's
	[{x:20,y:29},{x:24.5,y:24.5},{x:26.5,y:26},{x:27,y:29},{x:24.5,y:31.5},{x:24,y:36},{x:22.5,y:36},{x:23,y:33},{x:22.5,y:30},{x:21.5,y:29.5},{x:20.5,y:30},[[{x:24.5,y:28.25}],[{x:23.5,y:29},{x:25.5,y:27.5}]]],
	[{x:17.5,y:35},{x:16,y:33},{x:15.5,y:28},{x:16,y:24},{x:17.5,y:22.5},{x:19.5,y:22.5},{x:18.5,y:26.5},{x:20,y:29},{x:20.5,y:30},{x:21,y:32},{x:21,y:42.25},{x:19,y:41.5},{x:18.5,y:35},[[{x:18.5,y:31}],[{x:17.5,y:31},{x:19.5,y:31}]]],
	[{x:16,y:24},{x:14,y:18},{x:13,y:11},{x:16,y:5},{x:18.5,y:3.5},{x:22.5,y:3.5},{x:23,y:7.5},{x:20.5,y:8},{x:21,y:14},{x:20.5,y:18},{x:19.5,y:22.5},{x:17.5,y:22.5},[[{x:17.5,y:13}],[{x:16.5,y:13},{x:18.5,y:13}]]],
	[{x:5.5,y:19},{x:5,y:14},{x:6,y:8},{x:11,y:5},{x:15,y:7},{x:13,y:11},{x:14,y:18},{x:11,y:18},{x:8,y:21},[[{x:9.5,y:13}],[{x:8.5,y:13},{x:10.5,y:13}]]],
	[{x:8,y:29},{x:8,y:21},{x:11,y:18},{x:14,y:18},{x:16,y:24},{x:15.5,y:28},{x:16,y:33},{x:12.5,y:36},{x:9.5,y:34},[[{x:12,y:27}],[{x:11,y:27},{x:13,y:27}]]],
	[{x:7,y:38},{x:8,y:34},{x:9,y:32.5},{x:9.5,y:34},{x:12.5,y:36},{x:16,y:33},{x:17.5,y:35},{x:17,y:45},{x:11,y:44.5},{x:8,y:42},[[{x:13,y:40}],[{x:11.5,y:40},{x:13.5,y:40}]]],
	[{x:3,y:32},{x:3.5,y:23},{x:4,y:19.5},{x:5.5,y:19},{x:8,y:21},{x:8,y:29},{x:9,y:32.5},{x:9,y:32.5},{x:8,y:34},{x:7,y:38},{x:4.5,y:37.5},[[{x:5.75,y:29}],[{x:4.75,y:29},{x:6.75,y:29}]]],
	[{x:2.5,y:43},{x:2.5,y:40},{x:4.5,y:37.5},{x:7,y:38},{x:8,y:42},{x:6,y:44.5},{x:4,y:45},[[{x:5.25,y:41}],[{x:4.25,y:41},{x:6.25,y:41}]]],
	[{x:3,y:52},{x:3,y:47},{x:4,y:45},{x:6,y:44.5},{x:8,y:42},{x:11,y:44.5},{x:10,y:51},{x:8,y:54},{x:5,y:55},[[{x:7,y:49}],[{x:6,y:49},{x:8,y:49}]]],
	[{x:10,y:51},{x:11,y:44.5},{x:17,y:45},{x:16,y:51},{x:14.5,y:55},{x:12,y:54},[[{x:13.5,y:49.5}],[{x:12.5,y:49.5},{x:14.5,y:49.5}]]],
	// end of naval 60's
	[{x:8,y:54},{x:10,y:51},{x:12,y:54},{x:14.5,y:55},{x:14.5,y:59.5},{x:10.5,y:60.5},{x:8.5,y:58.5},[[{x:11,y:56.5}],[{x:10.5,y:56.5},{x:12.5,y:56.5}]]],
	[{x:2,y:59},{x:2.5,y:56},{x:4,y:53.5},{x:5,y:55},{x:8,y:54},{x:8.5,y:58.5},{x:6.5,y:62},{x:3.5,y:62},[[{x:5.5,y:58}],[{x:4.5,y:58},{x:6.5,y:58}]]],
	[{x:3,y:66},{x:3.5,y:62},{x:6.5,y:62},{x:8.5,y:58.5},{x:10.5,y:60.5},{x:10,y:66},{x:7,y:68},[[{x:7,y:64}],[{x:6,y:64},{x:8,y:64}]]],
	[{x:10.5,y:73},{x:10,y:66},{x:10.5,y:60.5},{x:14.5,y:59.5},{x:14,y:64},{x:14,y:70},{x:15.5,y:77},{x:12.5,y:79},[[{x:12.25,y:69}],[{x:12.25,y:67},{x:12.25,y:71}]]],
	[{x:4.5,y:76},{x:4,y:71},{x:5,y:67},{x:7,y:68},{x:10,y:66},{x:10.5,y:73},{x:11.5,y:76},{x:9,y:79},[[{x:7.5,y:72.5}],[{x:6.5,y:72.5},{x:8.5,y:72.5}]]],
	[{x:8.5,y:84},{x:9,y:79},{x:11.5,y:76},{x:12.5,y:79},{x:15.5,y:77},{x:16,y:79},{x:18.5,y:80},{x:18,y:85},{x:21,y:87},{x:21,y:91},{x:18,y:92},{x:11,y:90},[[{x:14.55,y:85}],[{x:13.5,y:85},{x:15.5,y:85}]]],
	[{x:10.5,y:95.5},{x:11,y:90},{x:18,y:92},{x:21,y:91},{x:21.5,y:93},{x:21,y:96.5},{x:18,y:95},{x:14,y:94.5},[[{x:16,y:93}],[{x:15,y:93},{x:17,y:93.25}]]],
	[{x:18,y:85},{x:18.5,y:80},{x:20.5,y:80.5},{x:27,y:82.5},{x:26.5,y:86.5},{x:24.5,y:85.5},{x:24,y:86.5},{x:21,y:87},[[{x:22.75,y:84}],[{x:21.75,y:84},{x:23.75,y:84}]]],
	[{x:21,y:96.5},{x:21.5,y:93},{x:21,y:91},{x:21,y:87},{x:24,y:86.5},{x:25,y:90},{x:26,y:90.5},{x:27.5,y:90},{x:30,y:90},{x:30.5,y:94},{x:29.5,y:97},{x:26,y:96},[[{x:26,y:93}],[{x:25,y:93},{x:27,y:93}]]],
	[{x:18,y:69},{x:21,y:67.5},{x:22.5,y:70},{x:24,y:70},{x:24.5,y:75},{x:25.5,y:76.5},{x:25,y:79.5},{x:21.5,y:77},{x:19,y:75},[[{x:22,y:73}],[{x:21,y:72},{x:22.75,y:74}]]],
	// end of naval 70's
	[{x:26.5,y:86.5},{x:27,y:82.5},{x:27,y:81},{x:25,y:79.5},{x:25.5,y:76.5},{x:27,y:78.5},{x:30.3,y:77},{x:31.5,y:77.5},{x:33.5,y:77.5},{x:34,y:81.5},{x:32,y:81.5},{x:30,y:82},{x:30,y:84},{x:34.5,y:84.5},{x:35,y:88},{x:34,y:89},{x:30,y:90},{x:27.5,y:90},{x:27,y:87.5},[[{x:28.75,y:84}],[{x:28.75,y:82},{x:28.75,y:86}]]],
	[{x:33.5,y:77.5},{x:35,y:77.5},{x:36,y:76},{x:39,y:74},{x:43,y:74},{x:43.5,y:78},{x:41,y:80},{x:38.5,y:81},{x:38,y:80},{x:36,y:80.5},{x:35,y:81.5},{x:34,y:81.5},[[{x:39,y:77.5}],[{x:38,y:77.5},{x:40,y:77.5}]]],
	[{x:34.5,y:84.5},{x:38,y:82.5},{x:38.5,y:81},{x:41,y:80},{x:43.5,y:78},{x:44,y:82},{x:40.5,y:85},{x:38.5,y:88},{x:36.5,y:89},{x:35,y:88},[[{x:39.5,y:83.5}],[{x:38.5,y:84.5},{x:40.5,y:82.5}]]],
	[{x:29.5,y:97},{x:30.5,y:94},{x:30,y:90},{x:34,y:89},{x:35,y:88},{x:36.5,y:89},{x:38.5,y:88},{x:39,y:92},{x:37.5,y:95.5},{x:33.5,y:97},[[{x:34.5,y:92.5}],[{x:33.5,y:92.5},{x:35.5,y:92.5}]]],
	[{x:39,y:92},{x:38.5,y:88},{x:40.5,y:85},{x:44,y:82},{x:47,y:81.5},{x:47,y:85.5},{x:41.5,y:88},{x:41.5,y:90},{x:40.5,y:92},[[{x:43,y:85}],[{x:42,y:85.75},{x:44,y:84.5}]]],
	[{x:37.5,y:95.5},{x:39,y:92},{x:40.5,y:92},{x:41.5,y:90},{x:44,y:91},{x:47,y:88.5},{x:47.5,y:92},{x:47,y:94.5},{x:44,y:96},{x:41,y:96.5},[[{x:43,y:93.5}],[{x:42,y:93.5},{x:44,y:93.5}]]],
	[{x:44,y:82},{x:43,y:74},{x:45,y:70.5},{x:47.5,y:76},{x:47.5,y:79},{x:47,y:81.5},[[{x:45.5,y:77}],[{x:45.5,y:75.25},{x:45.5,y:79}]]],
	[{x:45,y:70.5},{x:47,y:67},{x:48,y:64},{x:50.5,y:63.5},{x:52,y:67},{x:52,y:72},{x:50,y:76},{x:47.5,y:76},[[{x:49,y:70}],[{x:48,y:70},{x:50,y:70}]]],
	[{x:52,y:72},{x:52,y:67},{x:54.5,y:63},{x:57,y:62},{x:57.5,y:64.5},{x:58.5,y:74},{x:57.5,y:75},{x:56,y:73.5},{x:53.5,y:74},[[{x:55.25,y:69}],[{x:54.25,y:69},{x:56.25,y:69}]]],
	[{x:50.5,y:63.5},{x:55.5,y:52},{x:55.5,y:49},{x:57,y:49},{x:58.5,y:53},{x:58.5,y:55},{x:57.5,y:58},{x:57,y:62},{x:54.5,y:63},{x:52,y:67},[[{x:55.25,y:58.5}],[{x:54.5,y:60},{x:56,y:57}]]],
	// end of naval 80's
	[{x:62.5,y:45.5},{x:62.5,y:42},{x:66,y:40},{x:68,y:41.5},{x:66,y:43.5},{x:66,y:44.5},{x:68,y:45.5},{x:68,y:47.5},{x:66,y:49.5},{x:64.5,y:48},[[{x:65,y:45.5}],[{x:64,y:44.5},{x:66,y:46.5}]]],
	[{x:55,y:41},{x:56,y:36},{x:59,y:33},{x:61,y:35},{x:57.5,y:46},{x:57,y:49},{x:55.5,y:49},{x:55.5,y:46.5},{x:56,y:45},{x:56,y:43},[[{x:57.5,y:39.5}],[{x:57.5,y:37.5},{x:57.5,y:41.5}]]],
	[{x:50.5,y:39.5},{x:50.5,y:37},{x:51.5,y:37},{x:52.5,y:36},{x:52,y:31},{x:57.5,y:30},{x:59,y:33},{x:56,y:36},{x:55,y:41},{x:53.5,y:41},[[{x:54.5,y:35}],[{x:54,y:36.5},{x:55.5,y:33.5}]]],
	[{x:57.5,y:30},{x:59.5,y:25.5},{x:64,y:25},{x:63.5,y:29.5},{x:64.5,y:34},{x:61,y:35},{x:59,y:33},[[{x:61,y:30}],[{x:60,y:30},{x:62,y:30}]]],
	[{x:63.5,y:29.5},{x:64,y:25},{x:67,y:21.5},{x:68.5,y:22},{x:68,y:26},{x:66.5,y:27},{x:66,y:30},{x:66.5,y:33.5},{x:64.5,y:34},[[{x:65.25,y:27}],[{x:65,y:28.5},{x:66,y:25.5}]]],
	[{x:66.5,y:33.5},{x:66,y:30},{x:66.5,y:27},{x:68,y:26},{x:70.5,y:27},{x:71.5,y:32},{x:72,y:38},{x:70,y:38},{x:70,y:35},{x:68,y:33},[[{x:68.75,y:30}],[{x:67.75,y:30},{x:69.75,y:30}]]],
	[{x:68,y:26},{x:68.5,y:22},{x:70,y:19},{x:72,y:20},{x:73.5,y:25},{x:73.5,y:30},{x:71.5,y:32},{x:70.5,y:27},[[{x:71,y:24}],[{x:70,y:24},{x:72,y:24}]]],
	[{x:73.5,y:30},{x:73.5,y:25},{x:72,y:20},{x:75.5,y:17},{x:78.5,y:20},{x:79,y:25},{x:78,y:29.5},{x:75,y:28.5},[[{x:76,y:23}],[{x:75,y:23},{x:77,y:23}]]],
	[{x:70,y:19},{x:69.5,y:13},{x:68.5,y:10.5},{x:72,y:9.5},{x:75,y:9.5},{x:76,y:13},{x:75.5,y:17},{x:72,y:20},[[{x:72.5,y:14}],[{x:71.5,y:14},{x:73.5,y:14}]]],
	[{x:67,y:10.5},{x:67,y:6.5},{x:69.5,y:5},{x:74,y:4},{x:77,y:5.5},{x:78,y:10.5},{x:76,y:13},{x:75,y:9.5},{x:72,y:9.5},{x:68.5,y:10.5},[[{x:72,y:7}],[{x:71,y:7},{x:73,y:7}]]],
	// end of naval 90's
	[{x:75.5,y:17},{x:76,y:13},{x:78,y:10.5},{x:77,y:5.5},{x:80,y:5},{x:81,y:17},{x:78.5,y:20},[[{x:78.5,y:14.5}],[{x:77.5,y:14.5},{x:79.5,y:14.5}]]],
	[{x:79,y:25},{x:78.5,y:20},{x:81,y:17},{x:80.5,y:11},{x:85,y:9.5},{x:88,y:11},{x:89,y:18},{x:87,y:23},{x:83,y:25},[[{x:84,y:17.5}],[{x:83,y:17.5},{x:85,y:17.5}]]],
	[{x:89,y:18},{x:88,y:11},{x:89,y:7},{x:93,y:6.5},{x:96,y:9.5},{x:96.5,y:14},{x:94,y:18},{x:91.5,y:19},[[{x:92,y:12.5}],[{x:91,y:12.5},{x:93,y:12.5}]]],
	[{x:87,y:23},{x:89,y:18},{x:91.5,y:19},{x:94,y:18},{x:96.5,y:14},{x:97.5,y:16},{x:97.5,y:22},{x:95.5,y:25.5},{x:92,y:28.5},{x:89.5,y:28.5},[[{x:92.5,y:22.5}],[{x:91.5,y:22.5},{x:93.5,y:22.5}]]],
	[{x:84,y:29.5},{x:83,y:25},{x:87,y:23},{x:89.5,y:28.5},{x:92,y:28.5},{x:93,y:33},{x:89.5,y:34},{x:87,y:30},[[{x:88,y:29}],[{x:87,y:28},{x:89,y:30}]]],
	[{x:74,y:39},{x:75,y:33.5},{x:77.5,y:32},{x:79,y:25},{x:83,y:25},{x:84,y:29.5},{x:80.5,y:31},{x:79.5,y:36},{x:77.5,y:39},[[{x:79,y:32}],[{x:78.5,y:33.5},{x:79.5,y:30.5}]]],
	[{x:77.5,y:39},{x:79.5,y:36},{x:80.5,y:31},{x:84,y:29.5},{x:87,y:30},{x:89.5,y:34},{x:90,y:37.5},{x:89,y:39},{x:87,y:35},{x:83,y:35},{x:82,y:39},{x:79.5,y:42},[[{x:84,y:32.5}],[{x:83,y:32.5},{x:85,y:32.5}]]],
	[{x:73,y:41.5},{x:74,y:39},{x:77.5,y:39},{x:79.5,y:42},{x:80.5,y:48},{x:80,y:54},{x:76,y:52},{x:76.5,y:47.5},{x:74.5,y:45},{x:74.5,y:43},[[{x:77.5,y:45}],[{x:76.5,y:45},{x:78.5,y:45}]]],
	[{x:80,y:45},{x:79.5,y:42},{x:82,y:39},{x:83,y:35},{x:87,y:35},{x:89,y:39},{x:89,y:43},{x:87,y:47},{x:83,y:47},[[{x:84.75,y:41}],[{x:83.75,y:41},{x:85.75,y:41}]]],
	[{x:80,y:54},{x:80.5,y:48},{x:80,y:45},{x:83,y:47},{x:87,y:47},{x:87,y:49.5},{x:85.5,y:51},{x:85,y:51},{x:83,y:53},[[{x:83,y:49.5}],[{x:82,y:49.5},{x:84,y:49.5}]]],
	// end of naval 100's
	[{x:87,y:49.5},{x:87,y:47},{x:89,y:43},{x:89,y:39},{x:90,y:37.5},{x:89.5,y:34},{x:93,y:33},{x:93.5,y:42},{x:91,y:48.5},[[{x:91,y:42}],[{x:90,y:42},{x:92,y:42}]]],
	[{x:91,y:48.5},{x:93.5,y:42},{x:93,y:33},{x:92,y:28.5},{x:95,y:26},{x:96.5,y:30},{x:97,y:42},{x:97,y:49},{x:93.5,y:50.5},[[{x:95,y:39}],[{x:95,y:37},{x:95,y:41}]]],
	[{x:86,y:58},{x:85.5,y:51},{x:87,y:49.5},{x:91,y:48.5},{x:93.5,y:50.5},{x:93,y:55},{x:90.5,y:58},[[{x:89.5,y:53}],[{x:88.5,y:53},{x:90.5,y:53}]]],
	[{x:91,y:63},{x:90.5,y:58},{x:93,y:55},{x:93.5,y:50.5},{x:97,y:49},{x:97,y:56},{x:95,y:61},[[{x:94.5,y:56.5}],[{x:93.5,y:57.5},{x:95.5,y:55.5}]]],
	[{x:84,y:68},{x:84,y:64},{x:85,y:64},{x:86,y:58},{x:90.5,y:58},{x:91,y:63},{x:91,y:68},{x:87.5,y:69},[[{x:88,y:63.5}],[{x:87,y:63.5},{x:89,y:63.5}]]],
	[{x:73.5,y:68.5},{x:73.5,y:68},{x:75.5,y:68.5},{x:77,y:68},{x:76.5,y:65.5},{x:73.5,y:66},{x:75,y:62},{x:82,y:62},{x:84,y:64},{x:84,y:68},{x:81,y:70},{x:75.5,y:70},[[{x:80,y:66}],[{x:79,y:66},{x:81,y:66}]]],
	[{x:74,y:79},{x:74,y:73},{x:75.5,y:70},{x:80,y:70},{x:80,y:75},{x:78,y:79},[[{x:77,y:74.5}],[{x:76,y:74.5},{x:78,y:74.5}]]],
	[{x:67.5,y:81},{x:69,y:75.5},{x:71.5,y:75},{x:71.5,y:69.5},{x:73.5,y:68.5},{x:75.5,y:70},{x:74,y:73},{x:74,y:79},{x:72.5,y:81},[[{x:71.5,y:78}],[{x:70.5,y:78},{x:72.5,y:78}]]],
	[{x:65.5,y:82},{x:65,y:78},{x:66.5,y:68},{x:71.5,y:69.5},{x:71.5,y:71},{x:69,y:73},{x:69,y:75.5},{x:67.5,y:81},[[{x:67.25,y:75}],[{x:67.25,y:73},{x:67.25,y:77}]]],
	[{x:62,y:76},{x:61,y:67},{x:62,y:63.5},{x:63.5,y:64},{x:65,y:64},{x:67,y:63},{x:66.5,y:68},{x:65,y:78},[[{x:63.75,y:70}],[{x:62.75,y:70},{x:64.75,y:70}]]],
	// end of naval 110's
	[{x:57.5,y:84},{x:57,y:79},{x:61,y:78},{x:62,y:76},{x:65,y:78},{x:65.5,y:82},{x:65.5,y:83},{x:62,y:85},[[{x:61.5,y:81}],[{x:60.5,y:81},{x:62.5,y:81}]]],
	[{x:52,y:83},{x:52,y:79},{x:53,y:77},{x:57,y:79},{x:57.5,y:84},{x:57,y:88},{x:55,y:87.5},{x:54.5,y:84},[[{x:55,y:81}],[{x:54,y:81},{x:56,y:81}]]],
	[{x:47,y:81.5},{x:47.5,y:79},{x:47.5,y:76},{x:50,y:76},{x:52,y:72},{x:53.5,y:74},{x:53,y:77},{x:52,y:79},{x:52,y:80},{x:49,y:81.5},[[{x:51,y:77.5}],[{x:49.5,y:78.5},{x:51.5,y:76.5}]]],
	[{x:47,y:94.5},{x:47.5,y:92},{x:47,y:88.5},{x:47.5,y:87},{x:47,y:85.5},{x:47,y:81.5},{x:49,y:81.5},{x:50,y:88},{x:50.5,y:94.5},{x:49,y:94},[[{x:48.5,y:88}],[{x:48.5,y:86},{x:48.5,y:90}]]],
	[{x:50,y:88},{x:49,y:81.5},{x:52,y:80},{x:52,y:83},{x:54.5,y:84},{x:55,y:87.5},{x:55,y:89.5},{x:53,y:90},{x:52,y:87},[[{x:52,y:85}],[{x:51,y:84},{x:53,y:86}]]],
	[{x:50.5,y:94.5},{x:50,y:88},{x:52,y:87},{x:53,y:90},{x:55,y:89.5},{x:55,y:87.5},{x:57,y:88},{x:56.5,y:95},{x:54.5,y:93.5},{x:52.5,y:93.5},[[{x:53.5,y:91.5}],[{x:52.5,y:91.5},{x:54.5,y:91.5}]]],
	[{x:56.5,y:95},{x:57,y:88},{x:57.5,y:84},{x:62,y:85},{x:62,y:87},{x:64.5,y:88},{x:65,y:92},{x:62,y:95},[[{x:60.5,y:90}],[{x:59.5,y:90},{x:61.5,y:90}]]],
	[{x:62,y:87},{x:62,y:85},{x:65.5,y:83},{x:69,y:84.5},{x:69,y:86},{x:68,y:87},{x:67,y:93.5},{x:65.5,y:93.5},{x:65,y:92},{x:64.5,y:88},[[{x:66,y:86}],[{x:65,y:86},{x:67,y:86}]]],
	[{x:63,y:94},{x:65,y:92},{x:65.5,y:93.5},{x:68,y:93.5},{x:69.5,y:89},{x:72.5,y:86.5},{x:73,y:93},{x:73,y:94.5},{x:70.5,y:96},{x:65,y:95.5},[[{x:70.75,y:92}],[{x:69.75,y:92},{x:71.75,y:92}]]],
	[{x:73,y:94.5},{x:73,y:93},{x:72.5,y:86.5},{x:75.5,y:86.5},{x:75,y:89},{x:75.5,y:90},{x:81,y:90},{x:81.5,y:95.5},{x:78,y:97},{x:75,y:96.5},[[{x:77,y:93}],[{x:76,y:93},{x:78,y:93}]]],
	// end of naval 120's
	[{x:81.5,y:95.5},{x:81,y:90},{x:85,y:84.5},{x:88,y:88.5},{x:88.5,y:94},{x:87,y:96},{x:84.5,y:94.5},[[{x:85,y:90.5}],[{x:84,y:90.5},{x:86,y:90.5}]]],
	[{x:85,y:84.5},{x:85,y:83},{x:84.5,y:82},{x:84,y:79.5},{x:85,y:76.5},{x:88,y:74.5},{x:88.5,y:79},{x:91,y:80},{x:90.5,y:86},{x:88,y:88.5},[[{x:87.5,y:82}],[{x:86.5,y:82},{x:88.5,y:82}]]],
	[{x:84,y:79.5},{x:82,y:78},{x:81.5,y:75.5},{x:80,y:75},{x:80,y:70},{x:81,y:70},{x:84,y:68},{x:87.5,y:69},{x:87.5,y:71},{x:88,y:74.5},{x:85,y:76.5},[[{x:84,y:73}],[{x:83,y:73},{x:85,y:73}]]],
	[{x:88,y:74.5},{x:87.5,y:71},{x:87.5,y:69},{x:91,y:68},{x:91,y:63},{x:95,y:61},{x:96,y:67},{x:95,y:73},[[{x:92,y:70}],[{x:91,y:70},{x:93,y:70}]]],
	[{x:88.5,y:79},{x:88,y:74.5},{x:95,y:73},{x:94.5,y:79.5},{x:91,y:80},[[{x:91.5,y:77}],[{x:90.5,y:77},{x:92.5,y:77}]]],
	[{x:88.5,y:94},{x:88,y:88.5},{x:90.5,y:86},{x:91,y:80},{x:94.5,y:79.5},{x:94,y:87},{x:92.5,y:91.5},[[{x:92,y:87}],[{x:92,y:85},{x:92,y:89}]]],
	[{x:92.5,y:91.5},{x:94,y:87},{x:94.5,y:79.5},{x:95,y:73},{x:95.5,y:70},{x:97.5,y:73.5},{x:98,y:82},{x:97,y:92},{x:94.5,y:94},[[{x:96,y:83}],[{x:96,y:81},{x:96,y:85}]]]
];

// territoryStateInfo contains information on a territory's type, current owner, original owner, temporary occupant (when a unit has moved there), occupying forces, and active natural hazards, as well as information that tracks active units' movement possibilities
    // type: 0=land, 1=sea
    var territoryStateInfo = [];
    for (var i = 0; i <= 7; i++) {
    	territoryStateInfo.push({type:0,capital:false,ownedByPlayer:-1,originalPlayerOwner:-1,occupiedByPlayer:-1,occupiedByUnits:[],naturalHazardIDs:[],speedSpent:99,pathToTer:[]})
    }
    for (var i = 8; i <= 14; i++) {
    	territoryStateInfo.push({type:0,capital:false,ownedByPlayer:playerByKingdom[2],originalPlayerOwner:playerByKingdom[2],occupiedByPlayer:-1,occupiedByUnits:[],naturalHazardIDs:[],speedSpent:99,pathToTer:[]})
    }
    territoryStateInfo[10].capital = true;
    territoryStateInfo[10].occupiedByPlayer = playerByKingdom[2];
    for (var i = 15; i <= 24; i++) {
    	territoryStateInfo.push({type:0,capital:false,ownedByPlayer:playerByKingdom[3],originalPlayerOwner:playerByKingdom[3],occupiedByPlayer:-1,occupiedByUnits:[],naturalHazardIDs:[],speedSpent:99,pathToTer:[]})
    }
    territoryStateInfo[18].capital = true;
    territoryStateInfo[18].occupiedByPlayer = playerByKingdom[3];
    for (var i = 25; i <= 30; i++) {
    	territoryStateInfo.push({type:0,capital:false,ownedByPlayer:playerByKingdom[0],originalPlayerOwner:playerByKingdom[0],occupiedByPlayer:-1,occupiedByUnits:[],naturalHazardIDs:[],speedSpent:99,pathToTer:[]})
    }
    territoryStateInfo[29].capital = true;
    territoryStateInfo[29].occupiedByPlayer = playerByKingdom[0];
    for (var i = 31; i <= 37; i++) {
    	territoryStateInfo.push({type:0,capital:false,ownedByPlayer:playerByKingdom[1],originalPlayerOwner:playerByKingdom[1],occupiedByPlayer:-1,occupiedByUnits:[],naturalHazardIDs:[],speedSpent:99,pathToTer:[]})
    }
    territoryStateInfo[35].capital = true;
    territoryStateInfo[35].occupiedByPlayer = playerByKingdom[1];
    for (var i = 38; i <= 41; i++) {
    	territoryStateInfo.push({type:0,capital:false,ownedByPlayer:-1,originalPlayerOwner:-1,occupiedByPlayer:-1,occupiedByUnits:[],naturalHazardIDs:[],speedSpent:99,pathToTer:[]})
    }
    for (var i = 42; i <= 136; i++) {
    	territoryStateInfo.push({type:1,capital:false,ownedByPlayer:-1,originalPlayerOwner:-1,occupiedByPlayer:-1,occupiedByUnits:[],naturalHazardIDs:[],speedSpent:99,pathToTer:[]})
    }
// adjacent territories (territory IDs of those adjacent to each territory)
	territoryStateInfo[0].adjacentTer = [1,42,60,61,62];
	territoryStateInfo[1].adjacentTer = [0,3,4,5,42,54,60];
	territoryStateInfo[2].adjacentTer = [3,42,43,44,45,51,52];
	territoryStateInfo[3].adjacentTer = [1,2,52,54];
	territoryStateInfo[4].adjacentTer = [1,6,53,54,55];
	territoryStateInfo[5].adjacentTer = [1,6,7,59,60];
	territoryStateInfo[6].adjacentTer = [4,5,55,56,57];
	territoryStateInfo[7].adjacentTer = [5,57,58,59];
	territoryStateInfo[8].adjacentTer = [9,10,59,61,65,69];
	territoryStateInfo[9].adjacentTer = [8,10,12,58,59];
	territoryStateInfo[10].adjacentTer = [8,9,11,12,69,70];
	territoryStateInfo[11].adjacentTer = [10,12,73,75,77,79];
	territoryStateInfo[12].adjacentTer = [9,10,11,13,14,58,79];
	territoryStateInfo[13].adjacentTer = [12,14,15,58];
	territoryStateInfo[14].adjacentTer = [12,13,15,79,80];
	territoryStateInfo[15].adjacentTer = [13,14,16,17,57,58,80,81];
	territoryStateInfo[16].adjacentTer = [15,17,18,56,57];
	territoryStateInfo[17].adjacentTer = [15,16,18,19,81,86,87];
	territoryStateInfo[18].adjacentTer = [16,17,19,20,21,55,56];
	territoryStateInfo[19].adjacentTer = [17,18,21,87,89];
	territoryStateInfo[20].adjacentTer = [18,21,55];
	territoryStateInfo[21].adjacentTer = [18,19,20,91,92];
	territoryStateInfo[22].adjacentTer = [50,53,92];
	territoryStateInfo[23].adjacentTer = [80,81,82];
	territoryStateInfo[24].adjacentTer = [84,85,123];
	territoryStateInfo[25].adjacentTer = [26,28,29,30,45,46];
	territoryStateInfo[26].adjacentTer = [25,27,30,46,47];
	territoryStateInfo[27].adjacentTer = [26,30,47,48,49];
	territoryStateInfo[28].adjacentTer = [25,29,45,51,52,53];
	territoryStateInfo[29].adjacentTer = [25,28,30,50,53];
	territoryStateInfo[30].adjacentTer = [25,26,27,29,49,50];
	territoryStateInfo[31].adjacentTer = [32,88,119,120,121,122];
	territoryStateInfo[32].adjacentTer = [31,33,35,88,89,90,91];
	territoryStateInfo[33].adjacentTer = [32,34,90,91,93,94,95];
	territoryStateInfo[34].adjacentTer = [33,35,90,95,96,97,105,107];
	territoryStateInfo[35].adjacentTer = [32,34,36,37,90,107,119];
	territoryStateInfo[36].adjacentTer = [35,37,115,117,118,119];
	territoryStateInfo[37].adjacentTer = [35,36,107,109,112,114,115];
	territoryStateInfo[38].adjacentTer = [39,117,118,120,127,128];
	territoryStateInfo[39].adjacentTer = [38,40,41,116,117,129];
	territoryStateInfo[40].adjacentTer = [39,41,116,131,132];
	territoryStateInfo[41].adjacentTer = [39,40,129,130,131];
	territoryStateInfo[42].adjacentTer = [0,1,2,43,62];
	territoryStateInfo[43].adjacentTer = [2,42,44,62];
	territoryStateInfo[44].adjacentTer = [2,43,45];
	territoryStateInfo[45].adjacentTer = [2,25,28,44,46,51];
	territoryStateInfo[46].adjacentTer = [25,26,45,47];
	territoryStateInfo[47].adjacentTer = [26,27,46,48,99];
	territoryStateInfo[48].adjacentTer = [27,47,49,94,96,98,99];
	territoryStateInfo[49].adjacentTer = [27,30,48,50,93,94];
	territoryStateInfo[50].adjacentTer = [22,29,30,49,53,92,93];
	territoryStateInfo[51].adjacentTer = [2,28,45,52];
	territoryStateInfo[52].adjacentTer = [2,3,28,51,53,54];
	territoryStateInfo[53].adjacentTer = [4,22,28,29,50,52,54,55];
	territoryStateInfo[54].adjacentTer = [1,3,4,52,53];
	territoryStateInfo[55].adjacentTer = [4,6,18,20,53,56];
	territoryStateInfo[56].adjacentTer = [6,16,18,55,57];
	territoryStateInfo[57].adjacentTer = [6,7,15,16,56,58];
	territoryStateInfo[58].adjacentTer = [7,9,12,13,15,57,59];
	territoryStateInfo[59].adjacentTer = [5,7,8,9,58,60,61];
	territoryStateInfo[60].adjacentTer = [0,1,5,59,61];
	territoryStateInfo[61].adjacentTer = [0,8,59,60,62,64,65];
	territoryStateInfo[62].adjacentTer = [0,42,43,61,63,64];
	territoryStateInfo[63].adjacentTer = [62,64,66];
	territoryStateInfo[64].adjacentTer = [61,62,63,65,66];
	territoryStateInfo[65].adjacentTer = [8,61,64,66,67,68,69];
	territoryStateInfo[66].adjacentTer = [63,64,65,67];
	territoryStateInfo[67].adjacentTer = [65,66,68];
	territoryStateInfo[68].adjacentTer = [65,67,69,70,71];
	territoryStateInfo[69].adjacentTer = [8,10,65,68,70];
	territoryStateInfo[70].adjacentTer = [10,68,69,71,72,73];
	territoryStateInfo[71].adjacentTer = [68,70,72];
	territoryStateInfo[72].adjacentTer = [70,71,73,74];
	territoryStateInfo[73].adjacentTer = [11,70,72,74,75];
	territoryStateInfo[74].adjacentTer = [72,73,75];
	territoryStateInfo[75].adjacentTer = [11,73,74,76,77];
	territoryStateInfo[76].adjacentTer = [75,78];
	territoryStateInfo[77].adjacentTer = [11,75,78,80];
	territoryStateInfo[78].adjacentTer = [76,77,80,83];
	territoryStateInfo[79].adjacentTer = [11,12,14,80];
	territoryStateInfo[80].adjacentTer = [14,15,23,77,78,79,81,82,83];
	territoryStateInfo[81].adjacentTer = [15,17,23,80,82,86];
	territoryStateInfo[82].adjacentTer = [23,80,81,83,84,86];
	territoryStateInfo[83].adjacentTer = [78,80,82,84,85];
	territoryStateInfo[84].adjacentTer = [24,82,83,85,86,123];
	territoryStateInfo[85].adjacentTer = [24,83,84,123];
	territoryStateInfo[86].adjacentTer = [17,81,82,84,87,122];
	territoryStateInfo[87].adjacentTer = [17,19,86,88,89,122];
	territoryStateInfo[88].adjacentTer = [31,32,87,89,122];
	territoryStateInfo[89].adjacentTer = [19,32,87,88,91];
	territoryStateInfo[90].adjacentTer = [32,33,34,35,107,119];
	territoryStateInfo[91].adjacentTer = [21,32,33,89,92,93];
	territoryStateInfo[92].adjacentTer = [21,22,50,91,93];
	territoryStateInfo[93].adjacentTer = [33,49,50,91,92,94];
	territoryStateInfo[94].adjacentTer = [33,48,49,93,95,96];
	territoryStateInfo[95].adjacentTer = [33,34,94,96];
	territoryStateInfo[96].adjacentTer = [34,48,94,95,97,98];
	territoryStateInfo[97].adjacentTer = [34,96,98,100,101,105];
	territoryStateInfo[98].adjacentTer = [48,96,97,99,100];
	territoryStateInfo[99].adjacentTer = [47,48,98,100];
	territoryStateInfo[100].adjacentTer = [97,98,99,101];
	territoryStateInfo[101].adjacentTer = [97,100,102,103,104,105];
	territoryStateInfo[102].adjacentTer = [101,103];
	territoryStateInfo[103].adjacentTer = [101,102,104,111];
	territoryStateInfo[104].adjacentTer = [101,103,105,106,110,111];
	territoryStateInfo[105].adjacentTer = [34,97,101,104,106,107];
	territoryStateInfo[106].adjacentTer = [104,105,107,108,110];
	territoryStateInfo[107].adjacentTer = [34,35,37,90,105,106,108,109];
	territoryStateInfo[108].adjacentTer = [106,107,109,110];
	territoryStateInfo[109].adjacentTer = [37,107,108,110,112];
	territoryStateInfo[110].adjacentTer = [104,106,108,109,111,112];
	territoryStateInfo[111].adjacentTer = [103,104,110,112,113];
	territoryStateInfo[112].adjacentTer = [37,109,110,111,113,114];
	territoryStateInfo[113].adjacentTer = [111,112,114,133];
	territoryStateInfo[114].adjacentTer = [37,112,113,115,132,133];
	territoryStateInfo[115].adjacentTer = [36,37,114,116,117,132];
	territoryStateInfo[116].adjacentTer = [39,40,115,117,132];
	territoryStateInfo[117].adjacentTer = [36,38,39,116,118];
	territoryStateInfo[118].adjacentTer = [36,38,117,119,120];
	territoryStateInfo[119].adjacentTer = [31,35,36,90,118,120];
	territoryStateInfo[120].adjacentTer = [31,38,118,119,121,126,127];
	territoryStateInfo[121].adjacentTer = [31,120,122,124,125,126];
	territoryStateInfo[122].adjacentTer = [31,86,87,88,121,123,124];
	territoryStateInfo[123].adjacentTer = [24,84,85,122,124,125];
	territoryStateInfo[124].adjacentTer = [121,122,123,125];
	territoryStateInfo[125].adjacentTer = [121,123,124,126];
	territoryStateInfo[126].adjacentTer = [120,121,125,127,128];
	territoryStateInfo[127].adjacentTer = [38,120,126,128];
	territoryStateInfo[128].adjacentTer = [38,126,127,129];
	territoryStateInfo[129].adjacentTer = [39,41,128,130];
	territoryStateInfo[130].adjacentTer = [41,129,131,135];
	territoryStateInfo[131].adjacentTer = [40,41,130,132,134,135];
	territoryStateInfo[132].adjacentTer = [40,114,115,116,131];
	territoryStateInfo[133].adjacentTer = [113,114,132,134,136];
	territoryStateInfo[134].adjacentTer = [131,132,133,135,136];
	territoryStateInfo[135].adjacentTer = [130,131,134,136];
	territoryStateInfo[136].adjacentTer = [133,134,135];

/*icon locations for testing*/
	/*var dummyColors = ['red', 'green', 'yellow'];
	// circleType provides a unique id to circles are texts
	var circleType = ['unit', 'nh', 'def'];
	for (var t = 0; t <= 41; t++) {
		console.log(territoryShapeInfo[t][(territoryShapeInfo[t].length - 1)][2][0]);
		for (var dummyCircles = 0; dummyCircles < territoryShapeInfo[t][(territoryShapeInfo[t].length - 1)][2].length; dummyCircles++) {
			var tempX = 3840 / 100 * territoryShapeInfo[t][(territoryShapeInfo[t].length - 1)][2][dummyCircles].x;
			var tempY = 2160 / 100 * territoryShapeInfo[t][(territoryShapeInfo[t].length - 1)][2][dummyCircles].y;
			var icon = document.createElementNS('http:// www.w3.org/2000/svg','polygon');
			// var icon = document.createElementNS('http:// www.w3.org/2000/svg','circle');
			// icon.setAttributeNS(null, "cx", tempX);
			// icon.setAttributeNS(null, "cy", tempY);
			// icon.setAttributeNS(null, "r", 2160 / 100 * 1.5);
			icon.setAttributeNS(null, "points",
				(tempX - (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
				tempX + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
				(tempX + (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)));
			icon.setAttributeNS(null, "style", 'stroke:black;stroke-width:4;fill:' + dummyColors[dummyCircles]);
			icon.id = circleType[dummyCircles] + 'CircleTer' + t;
			document.getElementById('gameBoardSVG').appendChild(icon);
			document.getElementById(circleType[dummyCircles] + 'CircleTer' + t).classList.add('territoryCircle');
			document.getElementById(circleType[dummyCircles] + 'CircleTer' + t).classList.add('territoryArea');
			var text = document.createElementNS('http:// www.w3.org/2000/svg','text');
			text.setAttributeNS(null, "x", tempX);
			text.setAttributeNS(null, "y", tempY + 7);
			text.setAttributeNS(null, "font-size", '290%');
			// text.setAttributeNS(null, "font-weight", 'bold');
			text.setAttributeNS(null, "alignment-baseline", 'middle');
			text.setAttributeNS(null, "text-anchor", 'middle');
			text.setAttributeNS(null, "font-family", 'arial');
			text.id = circleType[dummyCircles] + 'NumbersTer' + t;
			document.getElementById('gameBoardSVG').appendChild(text);
			document.getElementById(circleType[dummyCircles] + 'NumbersTer' + t).classList.add('territoryText');
			document.getElementById(circleType[dummyCircles] + 'NumbersTer' + t).classList.add('territoryArea');
			d3.select('#' + circleType[dummyCircles] + 'NumbersTer' + t).text('2');
			// territoryStateInfo[dummyCircles].ownedByPlayer = playerNumber;
			// territoryStateInfo[dummyCircles].occupiedByPlayer = playerNumber;
		}
	}*/

// cardType: 0=unit, 1=trap, 2=utility, 99=special
// frequency#: how often a card appears in each stage of war
// affiliation: 0=none, 1=mantle, 2=mistral, 3=vacuo, 4=vale
// (transport)size: 0=normal, 1=large, 2=huge, 3=colossal, 99=immovable (structure)
// type: 0=ground, 1=naval, 2=flying, 3=structure(ground), 4=structure(naval), 5=ground/naval
// mechanical: 0=non-mechanical, 1=half-mechanical, 2=full-mechanical
// ranged: whether a unit can attack without being retaliated
// maxSpeed: how many territories a unit can move per turn
// trainingTime: number of turns (including other players' turns) it takes to train/construct a unit before it can be given orders
// duration: 0=player turn, 1+=n rounds, 999=permanent
// compatibilityGroup (cards of the same group, except 0, are incompatible with each other): 0=default, 1=attack upgrades
// natural hazards: vsGround=vs ground, vsNaval=vs naval, vsAir=vs flying
var cardInfo = [
	// unit cards
	{name:'Artificial Tsunami Generator',cardType:0,frequency1:0,frequency2:rare,frequency3:uncommon,affiliation:'None',size:99,type:4,mechanical:2,currentHP:1,maxHP:20,attack:25,ranged:true,currentSpeed:0,maxSpeed:0,trainingTime:8,image:unitImage,description:''},
	{name:'Atlesian Air Fleet',cardType:0,frequency1:0,frequency2:rare,frequency3:uncommon,affiliation:'Mantle',size:1,type:2,mechanical:2,currentHP:1,maxHP:25,attack:40,ranged:true,currentSpeed:2,maxSpeed:2,trainingTime:11,image:unitImage,description:'Flying.'},
	{name:'Atlesian Bomb Drones',cardType:0,frequency1:0,frequency2:0,frequency3:uncommon,affiliation:'Mantle',size:0,type:0,mechanical:2,currentHP:1,maxHP:15,attack:50,currentSpeed:1,maxSpeed:1,trainingTime:6,image:unitImage,description:''},
	{name:'Atlesian Dreadnaught',cardType:0,frequency1:0,frequency2:0,frequency3:uncommon,affiliation:'Mantle',size:2,type:1,mechanical:2,currentHP:1,maxHP:40,attack:40,ranged:true,currentSpeed:2,maxSpeed:2,trainingTime:12,image:unitImage,description:'Naval.'},
	{name:'Atlesian Knights',cardType:0,frequency1:common,frequency2:rare,frequency3:0,affiliation:'Vacuo',size:0,type:0,mechanical:0,currentHP:1,maxHP:15,attack:15,currentSpeed:1,maxSpeed:1,trainingTime:1,image:unitImage,description:''},
	{name:'Cannonneers',cardType:0,frequency1:0,frequency2:rare,frequency3:uncommon,affiliation:'None',size:0,type:0,mechanical:0,currentHP:1,maxHP:20,attack:25,ranged:true,currentSpeed:1,maxSpeed:1,trainingTime:7,image:unitImage,description:''},
	{name:'Conscript',cardType:0,frequency1:common,frequency2:uncommon,frequency3:0,affiliation:'None',size:0,type:0,mechanical:0,currentHP:1,maxHP:10,attack:15,currentSpeed:1,maxSpeed:1,trainingTime:0,image:unitImage,description:''},
	{name:'Faunus Slave-soldiers',cardType:0,frequency1:uncommon,frequency2:uncommon,frequency3:0,affiliation:'None',size:0,type:0,mechanical:0,currentHP:1,maxHP:10,attack:15,currentSpeed:1,maxSpeed:1,trainingTime:0,image:unitImage,description:''},
	{name:'Giant Armor',cardType:0,frequency1:0,frequency2:uncommon,frequency3:rare,affiliation:'None',size:1,type:0,mechanical:0,currentHP:1,maxHP:25,attack:40,currentSpeed:3,maxSpeed:3,trainingTime:6,image:unitImage,description:''},
	{name:'Guardian Angel',cardType:0,frequency1:0,frequency2:0,frequency3:rare,affiliation:'None',size:2,type:2,mechanical:2,currentHP:1,maxHP:50,attack:40,currentSpeed:1,maxSpeed:1,trainingTime:16,image:unitImage,description:'Flying.'},
    // {name:'Heinz Doofenshmirtz',cardType:0,frequency1:1,frequency2:0,frequency3:0,affiliation:'None',size:0,type:0,mechanical:1,currentHP:1,maxHP:5,attack:5,currentSpeed:1,maxSpeed:1,trainingTime:256,image:url('http:// vignette4.wikia.nocookie.net/phineasandferb/images/5/5d/Doofenshmirtz_Portrait.jpg/revision/latest?cb=20120604014520'),description:'When played, equip with a -10 ATK inator card.'},
	{name:'Highwind Surfers',cardType:0,frequency1:common,frequency2:uncommon,frequency3:0,affiliation:'None',size:0,type:1,mechanical:1,currentHP:1,maxHP:15,attack:15,currentSpeed:2,maxSpeed:2,trainingTime:3,image:unitImage,description:'Naval.'},
	{name:'Imahim\'s Aerial Gunship',cardType:0,frequency1:0,frequency2:uncommon,frequency3:uncommon,affiliation:'None',size:0,type:2,mechanical:2,currentHP:1,maxHP:25,attack:25,ranged:true,currentSpeed:3,maxSpeed:3,trainingTime:9,image:unitImage,description:'Flying.'},
	{name:'Iron Whale',cardType:0,frequency1:0,frequency2:uncommon,frequency3:common,affiliation:'None',size:1,type:1,mechanical:2,currentHP:1,maxHP:25,attack:25,currentSpeed:2,maxSpeed:2,trainingTime:7,image:unitImage,description:'Naval.'},
	{name:'Knights of the Golden Sparrow',cardType:0,frequency1:rare,frequency2:uncommon,frequency3:0,affiliation:'None',size:0,type:0,mechanical:0,currentHP:1,maxHP:25,attack:25,currentSpeed:1,maxSpeed:1,trainingTime:3,image:unitImage,description:''},
	{name:'Large Transport Ship',cardType:0,frequency1:0,frequency2:uncommon,frequency3:common,affiliation:'None',size:2,type:1,mechanical:2,currentHP:1,maxHP:35,attack:0,currentSpeed:3,maxSpeed:3,trainingTime:7,transportFilledSlots:0,transportMaxSpots:6,transportSize:1,transportingUnits:[],image:unitImage,description:'Naval.'},
	{name:'Mistral Elemental Titan',cardType:0,frequency1:0,frequency2:0,frequency3:uncommon,affiliation:'Mistral',size:2,type:0,mechanical:0,currentHP:1,maxHP:40,attack:40,currentSpeed:1,maxSpeed:1,trainingTime:12,image:unitImage,description:''},
	{name:'Mistral Gliders',cardType:0,frequency1:uncommon,frequency2:rare,frequency3:0,affiliation:'Mistral',size:0,type:5,mechanical:1,currentHP:1,maxHP:15,attack:15,currentSpeed:2,maxSpeed:2,trainingTime:6,image:unitImage,description:'Amphibious.'},
	{name:'Mistral Golems',cardType:0,frequency1:0,frequency2:uncommon,frequency3:rare,affiliation:'Mistral',size:1,type:0,mechanical:2,currentHP:1,maxHP:35,attack:15,currentSpeed:2,maxSpeed:2,trainingTime:8,image:unitImage,description:''},
	{name:'Mistral Ironclad Warships',cardType:0,frequency1:0,frequency2:uncommon,frequency3:rare,affiliation:'Mistral',size:1,type:1,mechanical:2,currentHP:1,maxHP:25,attack:35,ranged:true,currentSpeed:3,maxSpeed:3,trainingTime:8,image:unitImage,description:''},
	{name:'Orbine\'s Buccaneers',cardType:0,frequency1:rare,frequency2:common,frequency3:0,affiliation:'None',size:1,type:1,mechanical:2,currentHP:1,maxHP:20,attack:20,ranged:true,currentSpeed:4,maxSpeed:4,trainingTime:5,image:unitImage,description:'Naval.'},
	{name:'Paradroppers',cardType:0,frequency1:0,frequency2:0,frequency3:common,affiliation:'None',size:1,type:2,mechanical:2,currentHP:1,maxHP:40,attack:0,currentSpeed:2,maxSpeed:2,trainingTime:12,transportFilledSlots:0,transportMaxSpots:4,transportSize:0,transportingUnits:[],image:unitImage,description:'Flying.'},
	{name:'Reckless Dustbombers',cardType:0,frequency1:0,frequency2:9,frequency3:0,affiliation:'None',size:0,type:0,mechanical:0,currentHP:1,maxHP:15,attack:25,currentSpeed:1,maxSpeed:1,trainingTime:4,image:unitImage,description:''},
	{name:'Transport Ships',cardType:0,frequency1:uncommon,frequency2:uncommon,frequency3:0,affiliation:'None',size:1,type:1,mechanical:2,currentHP:1,maxHP:15,attack:0,currentSpeed:3,maxSpeed:3,trainingTime:4,transportFilledSlots:0,transportMaxSpots:2,transportSize:1,transportingUnits:[],image:unitImage,description:'Naval.'},
	{name:'Unstable Dust Ships',cardType:0,frequency1:rare,frequency2:common,frequency3:rare,affiliation:'None',size:0,type:1,mechanical:2,currentHP:1,maxHP:15,attack:50,currentSpeed:3,maxSpeed:3,trainingTime:4,image:unitImage,description:'Naval.'},
	{name:'Vacual Beast Tamers',cardType:0,frequency1:0,frequency2:uncommon,frequency3:0,affiliation:'Vacuo',size:1,type:0,mechanical:0,currentHP:1,maxHP:25,attack:25,currentSpeed:2,maxSpeed:2,trainingTime:4,image:unitImage,description:''},
	{name:'Vacual Dunesailers',cardType:0,frequency1:rare,frequency2:uncommon,frequency3:0,affiliation:'Vacuo',size:1,type:0,mechanical:2,currentHP:1,maxHP:15,attack:0,currentSpeed:3,maxSpeed:3,trainingTime:4,transportFilledSlots:0,transportMaxSpots:2,transportSize:0,transportingUnits:[],image:unitImage,description:''},
	{name:'Vacual Valkyries',cardType:0,frequency1:0,frequency2:0,frequency3:uncommon,affiliation:'Vacuo',size:1,type:2,mechanical:0,currentHP:1,maxHP:25,attack:40,currentSpeed:3,maxSpeed:3,trainingTime:6,image:unitImage,description:'Flying.'},
	{name:'Vacual Wolfriders',cardType:0,frequency1:common,frequency2:uncommon,frequency3:0,affiliation:'Vacuo',size:0,type:0,mechanical:0,currentHP:1,maxHP:15,attack:20,currentSpeed:3,maxSpeed:3,trainingTime:4,image:unitImage,description:''},
	{name:'Valer Air Balloons',cardType:0,frequency1:uncommon,frequency2:uncommon,frequency3:0,affiliation:'Vale',size:0,type:2,mechanical:2,currentHP:1,maxHP:15,attack:15,currentSpeed:1,maxSpeed:1,trainingTime:8,image:unitImage,description:'Flying.'},
	{name:'Valer Musketeers',cardType:0,frequency1:rare,frequency2:uncommon,frequency3:0,affiliation:'Vale',size:0,type:0,mechanical:0,currentHP:1,maxHP:15,attack:20,ranged:true,currentSpeed:1,maxSpeed:1,trainingTime:2,image:unitImage,description:''},
	{name:'Valer Sapphire Eye Marines',cardType:0,frequency1:0,frequency2:0,frequency3:common,affiliation:'Vale',size:1,type:1,mechanical:2,currentHP:1,maxHP:30,attack:25,currentSpeed:3,maxSpeed:3,trainingTime:8,image:unitImage,description:'Naval.'},
	{name:'Valer Sniper Squad',cardType:0,frequency1:0,frequency2:rare,frequency3:uncommon,affiliation:'Vale',size:0,type:0,mechanical:0,currentHP:1,maxHP:25,attack:40,ranged:true,currentSpeed:1,maxSpeed:1,trainingTime:4,image:unitImage,description:''},
	{name:'Wall',cardType:0,frequency1:common,frequency2:uncommon,frequency3:0,affiliation:'None',size:99,type:3,mechanical:2,currentHP:1,maxHP:15,attack:0,currentSpeed:0,maxSpeed:0,trainingTime:4,image:unitImage,description:''},
	{name:'Watch Tower',cardType:0,frequency1:uncommon,frequency2:common,frequency3:0,affiliation:'None',size:99,type:3,mechanical:2,currentHP:1,maxHP:15,attack:15,ranged:true,currentSpeed:0,maxSpeed:0,trainingTime:4,image:unitImage,description:''},
	{name:'Zeppelin Bombers',cardType:0,frequency1:0,frequency2:0,frequency3:rare,affiliation:'None',size:1,type:2,mechanical:2,currentHP:1,maxHP:25,attack:30,currentSpeed:1,maxSpeed:1,trainingTime:12,image:unitImage,description:'Flying.'},
	// trap cards
	{name:'Abanea Trenchdiggers',cardType:1,frequency1:uncommon,frequency2:uncommon,frequency3:0,affiliation:'None',image:trapImage,description:'Enemy ground units deal half damage to ground units.'},
	{name:'Dismantler',cardType:1,frequency1:rare,frequency2:rare,frequency3:rare,affiliation:'None',image:trapImage,description:'When a player activates a trap card, negate its effects.'},
	{name:'Distraction',cardType:1,frequency1:rare,frequency2:uncommon,frequency3:uncommon,affiliation:'None',image:trapImage,description:'When attacked or countering a trap, select an enemy players permanent utility and discard it at the end of combat.'},
	{name:'Forged Armistice',cardType:1,frequency1:rare,frequency2:rare,frequency3:rare,affiliation:'None',image:trapImage,description:'No combat takes place and the attacking player cannot attack you again for 1 round.'},
	{name:'Frost Dust Bombs',cardType:1,frequency1:0,frequency2:rare,frequency3:uncommon,affiliation:'None',image:trapImage,description:'Attackers cannot move or attack for 1 round. Flying units also crash, taking 40% of their maximum HP in damage.'},
	{name:'Giant Nevermore',cardType:1,frequency1:0,frequency2:rare,frequency3:rare,affiliation:'None',image:trapImage,description:'Select attacking unit and roll dice. If 7+, Fatal Feathers destroy target unit. If 6-, Fatal Feathers destroy a random friendly unit up to 1 space away.'},
	{name:'Grimm Attack',cardType:1,frequency1:common,frequency2:common,frequency3:uncommon,affiliation:'None',image:trapImage,description:'Grimm deal 10 damage to all combatants at the end of combat.'},
	{name:'Liquid Death',cardType:1,frequency1:0,frequency2:uncommon,frequency3:uncommon,affiliation:'None',image:trapImage,description:'When a Structure is attacked, it deals +100% damage against non-ranged ground units for 1 round.'},
	{name:'Minefield',cardType:1,frequency1:rare,frequency2:uncommon,frequency3:0,affiliation:'None',image:trapImage,description:'Deal 15 damage to all non-ranged ground attackers prior to combat.'},
	{name:'Naval Minefield',cardType:1,frequency1:rare,frequency2:uncommon,frequency3:0,affiliation:'None',image:trapImage,description:'Deal 15 damage to all naval attackers before combat starts.'},
	{name:'Royal Reinstatement',cardType:1,frequency1:uncommon,frequency2:uncommon,frequency3:uncommon,affiliation:'None',image:trapImage,description:'When attacked by units affiliated with your kingdom, take control of those units before combat starts and move them to the defending territory.'},
	{name:'Rusting Mists',cardType:1,frequency1:0,frequency2:rare,frequency3:uncommon,affiliation:'None',image:trapImage,description:'All half-/full-Mechanical combatants (friend and foe) cannot attack for 1 round.'},
	{name:'Stealthy Commandeering',cardType:1,frequency1:0,frequency2:rare,frequency3:rare,affiliation:'None',image:trapImage,description:'Select one attacking non-transport, full-Mechanical unit. Switch its command to you and move it to the defending territory before combat.'},
	{name:'Trapping Pit',cardType:1,frequency1:common,frequency2:uncommon,frequency3:0,affiliation:'None',image:trapImage,description:'Non-huge, non-colossal ground attackers cannot move or attack for 1 round, and cannot be attacked by non-ranged ground units while trapped.'},
	// utility cards
	{name:'Amethyst Grove Saboteur',cardType:2,frequency1:rare,frequency2:rare,frequency3:rare,affiliation:'None',duration:0,compatibilityGroup:0,image:utilityImage,description:'Target player discards 1 random trap card from their hand if they have any.'},
	{name:'Atlesian Engineers',cardType:2,frequency1:0,frequency2:uncommon,frequency3:rare,affiliation:'None',duration:1,compatibilityGroup:0,image:utilityImage,description:'For 1 round, all your repairs are twice as effective. Does not stack.'},
	{name:'Concentrated Dust',cardType:2,frequency1:0,frequency2:uncommon,frequency3:uncommon,affiliation:'None',duration:999,compatibilityGroup:1,image:utilityImage,description:'Target Mechanical non-transport unit gains +10 ATK. Does not stack with itself and other attack upgrades.'},
	{name:'Desert Scavenge',cardType:2,frequency1:0,frequency2:rare,frequency3:0,affiliation:'None',duration:0,compatibilityGroup:0,image:utilityImage,description:'Draw a random non-unit card from any player\'s discard pile.'},
	{name:'Earthquake',cardType:2,frequency1:0,frequency2:uncommon,frequency3:rare,affiliation:'None',vsGround:1,vsNaval:0,vsAir:0,duration:3,compatibilityGroup:0,image:utilityImage,description:'Natural hazard.<BR>For 3 rounds, ground units in target land territory cannot enter or exit target territory.'},
	{name:'Elemental Destabilizer',cardType:2,frequency1:0,frequency2:rare,frequency3:rare,affiliation:'None',duration:0,compatibilityGroup:0,image:utilityImage,description:'Target Natural Hazard is expanded to all adjacent territories, each sharing the same remaining duration.'},
	{name:'First Aid',cardType:2,frequency1:uncommon,frequency2:uncommon,frequency3:rare,affiliation:'None',duration:0,compatibilityGroup:0,image:utilityImage,description:'Target non-full-mechanical unit restores 20 HP.'},
	{name:'Infused Armor',cardType:2,frequency1:0,frequency2:rare,frequency3:uncommon,affiliation:'None',duration:999,compatibilityGroup:0,image:utilityImage,description:'Target non-Mechanical unit gains +15 HP and becomes half-Mechanical.'},
	{name:'Lightning Storm',cardType:2,frequency1:0,frequency2:uncommon,frequency3:rare,affiliation:'None',vsGround:0,vsNaval:0,vsAir:1,duration:3,compatibilityGroup:0,image:utilityImage,description:'Natural hazard.<BR>For 3 rounds, Flying units in target territory cannot attack or be attacked, and cannot enter or exit target territory.'},
	{name:'Maelstrom',cardType:2,frequency1:0,frequency2:uncommon,frequency3:rare,affiliation:'None',vsGround:0,vsNaval:1,vsAir:0,duration:3,compatibilityGroup:0,image:utilityImage,description:'Natural hazard.<BR>For 3 rounds, Naval units in target territory cannot attack or be attacked, and cannot enter or exit target territory.'},
	{name:'Mistral Trade Route',cardType:2,frequency1:rare,frequency2:rare,frequency3:rare,affiliation:'None',duration:0,compatibilityGroup:0,image:utilityImage,description:'For 1 round, you gain the Spoils of War for up to 2 victorious battles per player.'},
	// {name:'Mithril Pebble of Pigsmiting',cardType:2,frequency1:1,frequency2:0,frequency3:0,affiliation:'None',duration:999,compatibilityGroup:1,image:'http:// pm1.narvii.com/5689/f5ddc2307b4432a932f265408b7434c1551d1e32_hq.jpg',description:'Target non-Mechanical unit gains +1000 ATK against Pig units.<BR><i>Long ago, this pebble was forged in the fiery pits of Tartarus by the grand blacksmith of Lucifer himself in a time before the world began...</i>'},
	{name:'Naval Ram',cardType:2,frequency1:common,frequency2:uncommon,frequency3:0,affiliation:'None',duration:999,compatibilityGroup:1,image:utilityImage,description:'Target naval unit (including transport ships) gains +10 ATK. Does not stack with itself and other attack upgrades.'},
	{name:'Perimeter Defenses',cardType:2,frequency1:uncommon,frequency2:uncommon,frequency3:0,affiliation:'None',duration:999,compatibilityGroup:0,image:utilityImage,description:'Target Structures gains +5 ATK. Stacks up to 5 times.'},
	{name:'Prototype Weaponry',cardType:2,frequency1:rare,frequency2:rare,frequency3:rare,affiliation:'None',duration:999,compatibilityGroup:1,image:utilityImage,description:'Target unit gains +10 ATK. Does not stack with itself and other attack upgrades.'},
	{name:'Reinforce Structure',cardType:2,frequency1:common,frequency2:uncommon,frequency3:rare,affiliation:'None',duration:999,compatibilityGroup:0,image:utilityImage,description:'Target Structure gains +10 HP. Stacks up to 5 times.'},
	{name:'Resourceful Raider',cardType:2,frequency1:30,frequency2:rare,frequency3:rare,affiliation:'None',duration:0,compatibilityGroup:0,image:utilityImage,description:'Select 1 full-Mechanical unit card from any player\'s discard pile and put it in your hand.'},
	{name:'Sandstorm',cardType:2,frequency1:0,frequency2:uncommon,frequency3:rare,affiliation:'None',vsGround:1,vsNaval:0,vsAir:1,duration:3,compatibilityGroup:0,image:utilityImage,description:'Natural hazard.<BR>For 3 rounds, ground and Flying units in target territory cannot attack or be attacked, and cannot enter or exit target territory.'},
	{name:'Schnee Dust Company',cardType:2,frequency1:0,frequency2:0,frequency3:1,affiliation:'None',duration:999,compatibilityGroup:0,image:utilityImage,description:'All half-/full-Mechanical units gain +5 ATK.'},
	// {name:'Silver Eyes',cardType:2,frequency1:0,frequency2:0,frequency3:1,affiliation:'None',duration:999,compatibilityGroup:0,image:utilityImage,description:'Target non-full-mechanical unit and all friendly units on the same territory cannot be attacked by non-colossal Grimm.'},
	{name:'Smugglers of Wind Path',cardType:2,frequency1:uncommon,frequency2:uncommon,frequency3:uncommon,affiliation:'None',duration:0,compatibilityGroup:0,image:utilityImage,description:'Draw a(n additional) card as Spoils of War from the last player you won a battle against.'},
	{name:'Thruster Packs',cardType:2,frequency1:0,frequency2:rare,frequency3:uncommon,affiliation:'None',duration:999,compatibilityGroup:0,image:utilityImage,description:'Target non-/half-Mechanical normal-size ground unit gains Flying.'},
	{name:'Tornado',cardType:2,frequency1:0,frequency2:uncommon,frequency3:rare,affiliation:'None',vsGround:1,vsNaval:1,vsAir:1,duration:3,compatibilityGroup:0,image:utilityImage,description:'Natural hazard.<BR>For 3 rounds, all units in target territory cannot enter or exit target territory.'},
	// special cards
	{name:'Evolution of Warfare',cardType:99,frequency1:1,frequency2:1,frequency3:0,affiliation:'None',image:'images/Evolution_of_Warfare.png',description:'Nations\' drive to get an edge in this war led to new militaristic advancements.<BR>New cards are added to the draw pile.'}
];

// fun adventurous boardgame looking for same player for playing games, romantic marches on beachhead, and dominating the people of remnant!

$(document).ready(function() {
	// socket.to(GRID).emit('next turn', 1, 2);
	// overlay windows
		// FUTURE FIX: overlayWindowsBackground doesn't appear anywhere for some reason
		function hideCombat() {
			$('#overlayWindows, #overlayWindowsBackground, #combat').fadeOut(150);
		}
		function showCombat() {
			$('#overlayWindows, #overlayWindowsBackground, #combat').fadeIn(150);
		}
		hideCombat();
		function hideUtilityApplier() {
			$('#overlayWindows, #overlayWindowsBackground, #utilityApplier').fadeOut(150);
		}
		function showUtilityApplier() {
			$('#overlayWindows, #overlayWindowsBackground, #utilityApplier').fadeIn(150);
		}
		hideUtilityApplier();
		function hideCardCarousel() {
			$('#overlayWindows, #overlayWindowsBackground, #cardCarousel').fadeOut(150);
		}
		function showCardCarousel() {
			$('#overlayWindows, #overlayWindowsBackground, #cardCarousel').fadeIn(150);
		}
        hideCardCarousel();
		function hideDiscardCard() {
			$('#overlayWindows, #overlayWindowsBackground, #discardCard').fadeOut(150);
			for (var buttons = 0; buttons < document.getElementsByClassName('discardButton').length; buttons++) {
				document.getElementsByClassName('discardButton')[buttons].style.visibility = 'hidden';
			}
		}
		function showDiscardCard() {
			$('#overlayWindows, #overlayWindowsBackground, #discardCard').fadeIn(150);
			for (var buttons = 0; buttons < document.getElementsByClassName('discardButton').length; buttons++) {
				document.getElementsByClassName('discardButton')[buttons].style.visibility = 'visible';
			}
		}
		hideDiscardCard();
		function hideDontUseTraps() {
			$('#overlayWindows, #overlayWindowsBackground, #dontUseTraps').fadeOut(150);
		}
		function showDontUseTraps() {
			$('#overlayWindows, #overlayWindowsBackground, #dontUseTraps').fadeIn(150);
		}
		hideDontUseTraps();
		function hideGiantNevermore() {
			$('#overlayWindows, #overlayWindowsBackground, #giantNevermore').fadeOut(150);
		}
		function showGiantNevermore() {
			$('#overlayWindows, #overlayWindowsBackground, #giantNevermore').fadeIn(150);
		}
		hideGiantNevermore();
		function hideStealthyCommandeering() {
			$('#overlayWindows, #overlayWindowsBackground, #stealthyCommandeering').fadeOut(150);
		}
		function showStealthyCommandeering() {
			$('#overlayWindows, #overlayWindowsBackground, #stealthyCommandeering').fadeIn(150);
		}
		hideStealthyCommandeering();
		function hideSpoilsOfWar() {
			$('#overlayWindows, #overlayWindowsBackground, #spoilsOfWar').fadeOut(150);
		}
		function showSpoilsOfWar() {
			$('#overlayWindows, #overlayWindowsBackground, #spoilsOfWar').fadeIn(150);
		}
		hideSpoilsOfWar();
		function hidePriorityTargets() {
			$('#overlayWindows, #overlayWindowsBackground, #priorityTargets').fadeOut(150);
		}
		function showPriorityTargets() {
			$('#overlayWindows, #overlayWindowsBackground, #priorityTargets').fadeIn(150);
		}
		hidePriorityTargets();
        function hideSurrender() {
            $('#overlayWindows, #overlayWindowsBackground, #surrender').fadeOut(150);
        }
        function showSurrender() {
            $('#overlayWindows, #overlayWindowsBackground, #surrender').fadeIn(150);
            document.getElementById('surrender').style.top = ((window.innerHeight / 2) - (document.getElementById('surrender').offsetHeight / 2) - 50) + 'px';
        }
        hideSurrender();
        function hidePlayerDefeated() {
            $('#overlayWindows, #overlayWindowsBackground, #playerDefeated').fadeOut(150);
        }
        function showPlayerDefeated() {
            $('#overlayWindows, #overlayWindowsBackground, #playerDefeated').fadeIn(150);
        }
        hidePlayerDefeated();
        function hidePlayerVictory() {
            $('#overlayWindows, #overlayWindowsBackground, #playerVictory').fadeOut(150);
        }
        function showPlayerVictory() {
            $('#overlayWindows, #overlayWindowsBackground, #playerVictory').fadeIn(150);
        }
        hidePlayerVictory();
        function hideTransportManager() {
            $('#overlayWindows, #overlayWindowsBackground, #transportManager').fadeOut(150);
        }
        function showTransportManager() {
            $('#overlayWindows, #overlayWindowsBackground, #transportManager').fadeIn(150);
        }
        hideTransportManager();
        // showTransportManager();
        // refreshTransportManager([77, 78], [69, 12, 17 ,64], [69, 12, 17, 64]);
		function showEvolutionOfWarfareText() {
			$('#evolutionOfWarfareText').fadeIn(1000);
			setTimeout(function() {
				$('#evolutionOfWarfareText').fadeOut(1000);
			}, 2000);
		}
		document.getElementById('evolutionOfWarfareText').style.top = (window.innerHeight / 3) - (document.getElementById('evolutionOfWarfareText').offsetHeight / 2) + 'px';
		document.getElementById('evolutionOfWarfareText').style.left = (window.innerWidth / 2) - (document.getElementById('evolutionOfWarfareText').offsetWidth / 2) + 'px';
		$('#evolutionOfWarfareText').hide();
		$('#flyingCard').hide();

		document.getElementById('utilityCancelButton').onclick = function() {
			hideUtilityApplier();
		}
		document.getElementById('carouselBack').onclick = function() {
			carouselCurrentIndex--;
			pickCard();
		}
		document.getElementById('carouselForward').onclick = function() {
			carouselCurrentIndex++;
			pickCard();
		}
		document.getElementById('carouselCancelButton').onclick = function() {
			hideCardCarousel();
		}
        document.getElementById('singleCardWindowButton').onclick = function() {
            $('#overlayWindows, #singleCardWindow').fadeOut(150);
        }
		document.getElementById('priorityTargetsCancelButton').onclick = function() {
			hidePriorityTargets();
		}
		for (var buttons = 0; buttons < document.getElementsByClassName('discardButton').length; buttons++) {
			document.getElementsByClassName('discardButton')[buttons].onclick = function() {
				discardCard(this);
			}
		}
		document.getElementsByClassName('priorityTargetsCancelButton').onclick = function() {
			hidePriorityTargets();
		}
		document.getElementById('surrenderButton').onclick = function() {
			showSurrender();
		}
		document.getElementById('surrenderConfirmButton').onclick = function() {
            // socket.emit('player surrenders', playerNumber);
			hideSurrender();
		}
		document.getElementById('surrenderCancelButton').onclick = function() {
			hideSurrender();
		}
        document.getElementById('playerDefeatedButton').onclick = function() {
            hidePlayerDefeated();
        }
        document.getElementById('playerVictoryButton').onclick = function() {
            window.location.href = '/index.html';
            // TO DO: remove savegame cookies
            // document.cookie = ;
        }

	document.body.style.cursor = 'default';
	// temporary Game Room ID and User ID for testing purposes
	var GRID = 'rtgLG';
	var UID = 'rtgUID';
	var gameStarted = false;
	// referenceCards is where all data of each individual card is stored for reference (based on id) and status manipulation
	var referenceCards = [];
	// number of capitals owned by the player for local victory/surrender checking
	var nOfCapitals = 1;
	var stageOfWar = 0;
    // ON LIVE: remove drawPile in favor of server-side drawPile management
	var drawPile = [];
	// array of reference numbers of last 10 cards played by any player
	var cardHistory = [];
	var lastPlayedCard = -1;
	// Only own cards and all active/discard piles are locally stored. The rest is for structure only
	// For every player, there's an array of cards on their hand (1), cards in play (2), and card in their discard pile (3)
	var altCardPiles = [[/*drawpile*/], [/*p1*/], [], [], [/*p2*/], [], [], [/*p3*/], [], [], [/*p4*/], [], []];
	// activeCard is the card that has been selected. targetCard is a card that may need manipulation because of actions taken with the activeCard
	var activeCard = -1;
	var targetCard = -1;
	var targetPlayer = -1;
	// checks if a unit or utility card has been played this turn (since only 1 may be played per turn)
	var playedCard = false;
	// territory from which units take action
	var activeTer = -1;
	// units that were selected by player to move or attack with
	var activeUnits = [];
	// the collective methods (land, sea, air, a combination, or immobile) with which all selected activeUnits can move
	var movementMethods = [];
	//  hasRanged (0=none, 1=partial, 2=all) checks if the collective activeUnits can attack at long range without retaliation
	var hasRanged = -1;
	// keeps logs of which units have various effects on them and for how much longer they remain in effect
	var forgedArmistice = [];
	var frostDustBombs = [];
	var liquidDeath = [];
	var rustingMists = [];
	var trappingPit = [];
	// the number of cards that can still be drawn from another player as spoils of war after achieving a victory against them
	var spoilsOfWar = [1,1,1,1];

	// determines size of the card's visuals in pixels
	var cardSize = {w:0,h:0};
	if (window.innerWidth / window.innerHeight > 1.5) {
		// widescreen 16:10 or wider
		cardSize.w = window.innerWidth / 10;
		cardSize.h = cardSize.w * 1.4;
	} else {
		// standard 4:3 or narrower
		cardSize.h = window.innerHeight / 4;
		cardSize.w = cardSize.h / 1.4;
	}
	// spoils of war window
		$('#spoilsOfWarPlayer').width(cardSize.w);
		$('#spoilsOfWarPlayer').height(cardSize.h);
		$('#spoilsOfWarEmpty').width(cardSize.w / 4);
		$('#spoilsOfWarEmpty').height(cardSize.h);
		$('#spoilsOfWarDrawPile').width(cardSize.w);
		$('#spoilsOfWarDrawPile').height(cardSize.h);
		$('#spoilsOfWar').css({left:(window.innerWidth / 2) - ($('#spoilsOfWar').width() / 2), top:(window.innerHeight / 2) - ($('#spoilsOfWar').height() / 2)});
		$('#spoilsOfWarTable').css({left:($('#spoilsOfWar').width() / 2) - (cardSize.w * 2.5 / 2)});
		$('#spoilsOfWarPlayerImage').attr('src', kingdomPicArray[kingdom[playerNumber]]);
		$('#spoilsOfWarDrawPile').attr('line-height', cardSize.h);
		$('#spoilsOfWarDrawPileHelper').attr('height', cardSize.h);

	$('#endTurnButton').hide();
	$('#surrenderButton').hide();

	// create reference cards
	var count = 0;
	for (var cType = 0; cType < cardInfo.length; cType++) {
        for (var freq = 0; freq < cardInfo[cType].frequency1; freq++) {
            var card = JSON.parse(JSON.stringify(cardInfo[cType]));
            card.id = count++;
            card.stage = 1;
            card.appliedEffects = [];
            card.hasAttacked = false;
            referenceCards.push(card);
        }
        for (var freq = 0; freq < cardInfo[cType].frequency2; freq++) {
            var card = JSON.parse(JSON.stringify(cardInfo[cType]));
            card.id = count++;
            card.stage = 2;
            card.appliedEffects = [];
            card.hasAttacked = false;
            referenceCards.push(card);
        }
        for (var freq = 0; freq < cardInfo[cType].frequency3; freq++) {
            var card = JSON.parse(JSON.stringify(cardInfo[cType]));
            card.id = count++;
            card.stage = 3;
            card.appliedEffects = [];
            card.hasAttacked = false;
            referenceCards.push(card);
        }
	}
    for (var i = 0; i < referenceCards.length; i++) {
        if (referenceCards[i].stage === 1 && referenceCards[i].name !== 'Evolution of Warfare') {
            nOfCards[4]++;
        }
    }
    // socket.emit('create draw pile', GRID, referenceCards);
    createDrawPile(referenceCards);

    // ON LIVE: do this only server-side
	// manually add Evolution of Warfare card after cards have been dealt to prevent it being drawn in the starting hand of a player
	for (var i = 0; i < referenceCards.length; i++) {
		if (referenceCards[i].stage === 1 && referenceCards[i].name === 'Evolution of Warfare') {
			drawPile.splice(Math.floor(Math.random() * drawPile.length), 0, referenceCards[i].id);
            nOfCards[4]++;
		}
	}
	// create 3 divs on the lefthand side, 1 for each player in order after the client's player's turn
	var tempPlayerNumber = 0;
	for (var pos = 1; pos < 4; pos++) {
		tempPlayerNumber = (playerNumber + pos);
		if (tempPlayerNumber > 3) {
			tempPlayerNumber = 0;
		}
		// FUTURE FIX (optional): add actives and discard piles
		document.getElementById('p' + pos + 'Area').innerHTML = '<div><img src="' + kingdomPicArray[kingdom[tempPlayerNumber]] + '" width="40%"><BR>' + commName[tempPlayerNumber] + '<div id="player' + tempPlayerNumber + 'Cards" class="nOfCards">' + nOfCards[tempPlayerNumber] + '</div></div>';
		playerByPos[pos - 1] = tempPlayerNumber;
	}
	// visualizing cards in player hand
	for (var cards = 0; cards < altCardPiles[((playerNumber * 3) + 1)].length; cards++) {
		document.getElementById('cardVisualsName' + (cards + 1)).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].name;
		if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].hasOwnProperty('trainingTime')) {
			document.getElementById('cardVisualsDuration' + (cards + 1)).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].trainingTime + 'TR';
		} else if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].hasOwnProperty('duration')) {
			switch (referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].duration) {
				case 0: break;
				case 999: document.getElementById('cardVisualsDuration' + (cards + 1)).innerHTML = 'Perm.'; break;
				default: document.getElementById('cardVisualsDuration' + (cards + 1)).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].duration + 'TR'; break;
			}
		}
		if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].cardType === 0) {
			document.getElementById('cardVisualsSpeed' + (cards + 1)).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].maxSpeed + 'SP';
		}
		if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].cardType === 0) {
			document.getElementById('cardVisualsAttack' + (cards + 1)).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].attack + 'ATK';
		}
		if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].cardType === 0) {
			document.getElementById('cardVisualsHP' + (cards + 1)).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].maxHP + 'HP';
		}
		document.getElementById('cardVisualsImage' + (cards + 1)).src = referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].image;
		if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].cardType === 0) {
			switch (referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].size) {
				case 0: document.getElementById('cardVisualsSizeType' + (cards + 1)).innerHTML = 'Unit'; break;
				case 1: document.getElementById('cardVisualsSizeType' + (cards + 1)).innerHTML = 'Large unit'; break;
				case 2: document.getElementById('cardVisualsSizeType' + (cards + 1)).innerHTML = 'Huge unit'; break;
				case 3: document.getElementById('cardVisualsSizeType' + (cards + 1)).innerHTML = 'Colossal unit'; break;
				case 99: document.getElementById('cardVisualsSizeType' + (cards + 1)).innerHTML = 'Structure'; break;
			}
		} else if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].cardType === 1) {
			document.getElementById('cardVisualsSizeType' + (cards + 1)).innerHTML = 'Trap';
		} else if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].cardType === 2) {
			document.getElementById('cardVisualsSizeType' + (cards + 1)).innerHTML = 'Utility';
		}
		if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].cardType === 0) {
			switch (referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].mechanical) {
				case 0: document.getElementById('cardVisualsMechanical' + (cards + 1)).innerHTML = 'Non-Mech.'; break;
				case 1: document.getElementById('cardVisualsMechanical' + (cards + 1)).innerHTML = 'Half-Mech.'; break;
				case 2: document.getElementById('cardVisualsMechanical' + (cards + 1)).innerHTML = 'Full-Mech.'; break;
			}
		}
		document.getElementById('cardVisualsDescription' + (cards + 1)).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].description;
		// document.getElementsByClassName('cardImage')[cards].innerHTML = altCardPiles[((playerNumber * 3) + 1)][cards] + '. ' + referenceCards[altCardPiles[((playerNumber * 3) + 1)][cards]].name;
	}
	// OPN LIVE: remove these lines
	var playerTurn = 1;
	var stageOfWar = 1;

	// display draw pile size and stage
	document.getElementById('drawPile').innerHTML = '<div style="font-size: 2em">' + nOfCards[4] + '</div><BR><div style="font-size: 1.2em">(Stage ' + stageOfWar + ')</div>';

	// initial player info
	document.getElementById('kingdomImage').innerHTML = '<img src="' + kingdomPicArray[kingdom[playerNumber]] + '" height="' + (document.getElementById('playerCards').offsetHeight/100*75) + '">';
	document.getElementById('commanderName').innerHTML = commName[playerNumber];

	// drawing territory borders
	for (ter = 0; ter < territoryShapeInfo.length; ter++) {
        console.log('drawing borders');
		var tempString = '';
		for (coord = 0; coord < (territoryShapeInfo[ter].length - 1); coord++) {
			var tempX = 3840 / 100 * territoryShapeInfo[ter][coord].x
			var tempY = 2160 / 100 * territoryShapeInfo[ter][coord].y
			tempString = tempString + tempX + ',' + tempY + ' ';
		}
		// console.log(tempString);
		var polygon = document.createElementNS('http:// www.w3.org/2000/svg','polygon');
		polygon.setAttribute("points", tempString);
		polygon.style = 'stroke:black; stroke-width:3';
		polygon.id = 'territoryArea' + ter;
		// polygon.newClass = 'territoryArea';
		// polygon.setAttribute("class", 'territoryArea');
		// $('#territoryArea' + ter).attr("class", "oldclass");
		// console.log($('#territoryArea' + ter).className);
		document.getElementById('gameBoardSVG').appendChild(polygon);
		$('#territoryArea' + ter).addClass('territoryArea');
	}
	// creating unpassable 'mountain' area south of vital island
		var fadedPolygon1 = document.createElementNS('http:// www.w3.org/2000/svg','polygon');
		fadedPolygon1.setAttribute("points", '1747.2,831.6 1758.72,777.6 1766.4,702 1831.68,691.2 1824,734.4 1920,799.2 1939.2,799.2 1939.2,853.2');
		fadedPolygon1.style = 'stroke:black; stroke-width:3; fill:rgba(250,243,216,0.6)';
		document.getElementById('gameBoardSVG').appendChild(fadedPolygon1);
		var attackArrowSVG = document.createElementNS('http:// www.w3.org/2000/svg','line');
		attackArrowSVG.setAttribute("x1", '1000');
		attackArrowSVG.setAttribute("y1", '831.6');
		attackArrowSVG.setAttribute("x2", '1758.72');
		attackArrowSVG.setAttribute("y2", '400');
		attackArrowSVG.style = 'stroke:red; stroke-width:20; marker-end:url(#attackArrowMarker);';
		document.getElementById('gameBoardSVG').appendChild(attackArrowSVG);
		attackArrowSVG.style.visibility = 'hidden';
		var moveArrowSVG = document.createElementNS('http:// www.w3.org/2000/svg','line');
		moveArrowSVG.setAttribute("x1", '1000');
		moveArrowSVG.setAttribute("y1", '1031.6');
		moveArrowSVG.setAttribute("x2", '1758.72');
		moveArrowSVG.setAttribute("y2", '600');
		moveArrowSVG.style = 'stroke:darkblue; stroke-width:20; marker-end:url(#moveArrowMarker);';
		document.getElementById('gameBoardSVG').appendChild(moveArrowSVG);
		moveArrowSVG.style.visibility = 'hidden';

	// add walls to capitals
		// FUTURE FIX: initial draw should show capitals in their own respective colors(?)
		var tempCard = {name:'Wall',cardType:0,frequency1:common,frequency2:uncommon,frequency3:0,affiliation:'None',size:99,type:3,mechanical:2,currentHP:15,maxHP:15,attack:0,currentSpeed:0,maxSpeed:0,trainingTime:0,image:unitImage};
		for (var k = 0; k < 4; k++) {
			tempCard.id = count++;
			tempCard.stage = 0;
			tempCard.appliedEffects = [];
			referenceCards.push(tempCard);
			territoryStateInfo[capitalTerIDs[k]].occupiedByUnits.push(tempCard.id);
			altCardPiles[((k * 3) + 2)].push(tempCard.id);
		}
	/*placing temporary units for local testing*/
		var tempTerID = 33;
		var tempActiveCard = 40;
		territoryStateInfo[tempTerID].occupiedByUnits.push(tempActiveCard);
		var tempX = 3840 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].x;
		var tempY = 2160 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].y;
		territoryStateInfo[tempTerID].ownedByPlayer = 2;
		territoryStateInfo[tempTerID].occupiedByPlayer = 2;
		altCardPiles[((2 * 3) + 2)].push(tempActiveCard);
		referenceCards[tempActiveCard].trainingTime = 0;
		referenceCards[tempActiveCard].currentHP = 5;
		/*--------------------------------------------------------------*/
		var tempTerID = 33;
		var tempActiveCard = 41;
		territoryStateInfo[tempTerID].occupiedByUnits.push(tempActiveCard);
		var tempX = 3840 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].x;
		var tempY = 2160 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].y;
		altCardPiles[((2 * 3) + 2)].push(tempActiveCard);
		referenceCards[tempActiveCard].trainingTime = 0;
		referenceCards[tempActiveCard].currentHP = referenceCards[tempActiveCard].maxHP;
		/*--------------------------------------------------------------*/
		var tempTerID = 33;
		var tempActiveCard = 42;
		territoryStateInfo[tempTerID].occupiedByUnits.push(tempActiveCard);
		var tempX = 3840 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].x;
		var tempY = 2160 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].y;
		altCardPiles[((2 * 3) + 2)].push(tempActiveCard);
		referenceCards[tempActiveCard].trainingTime = 0;
		referenceCards[tempActiveCard].currentHP = referenceCards[tempActiveCard].maxHP;
		/*--------------------------------------------------------------*/
		var tempTerID = 34;
		var tempActiveCard = 5;
		territoryStateInfo[tempTerID].occupiedByUnits.push(tempActiveCard);
		var tempX = 3840 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].x;
		var tempY = 2160 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].y;
		territoryStateInfo[tempTerID].ownedByPlayer = playerNumber;
		territoryStateInfo[tempTerID].occupiedByPlayer = playerNumber;
		altCardPiles[((playerNumber * 3) + 2)].push(tempActiveCard);
		referenceCards[tempActiveCard].trainingTime = 0;
		referenceCards[tempActiveCard].currentHP = referenceCards[tempActiveCard].maxHP;
        /*--------------------------------------------------------------*/
        var tempTerID = 34;
        var tempActiveCard = 43;
        territoryStateInfo[tempTerID].occupiedByUnits.push(tempActiveCard);
        var tempX = 3840 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].x;
        var tempY = 2160 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].y;
        altCardPiles[((2 * 3) + 2)].push(tempActiveCard);
        referenceCards[tempActiveCard].trainingTime = 0;
        referenceCards[tempActiveCard].currentHP = referenceCards[tempActiveCard].maxHP;
		/*--------------------------------------------------------------*/
		var tempTerID = 89;
		var tempActiveCard = 116;
		territoryStateInfo[tempTerID].occupiedByUnits.push(tempActiveCard);
		var tempX = 3840 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].x;
		var tempY = 2160 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].y;
		territoryStateInfo[tempTerID].ownedByPlayer = playerNumber;
		territoryStateInfo[tempTerID].occupiedByPlayer = playerNumber;
		altCardPiles[((playerNumber * 3) + 2)].push(tempActiveCard);
		referenceCards[tempActiveCard].trainingTime = 0;
		referenceCards[tempActiveCard].currentHP = referenceCards[tempActiveCard].maxHP;
		/*--------------------------------------------------------------*/
		var tempTerID = 32;
		var tempActiveCard = 16;
		territoryStateInfo[tempTerID].occupiedByUnits.push(tempActiveCard);
		var tempX = 3840 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].x;
		var tempY = 2160 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].y;
		territoryStateInfo[tempTerID].ownedByPlayer = playerNumber;
		territoryStateInfo[tempTerID].occupiedByPlayer = playerNumber;
		altCardPiles[((playerNumber * 3) + 2)].push(tempActiveCard);
		referenceCards[tempActiveCard].trainingTime = 0;
		referenceCards[tempActiveCard].currentHP = referenceCards[tempActiveCard].maxHP;
		/*--------------------------------------------------------------*/
		var tempTerID = 32;
		var tempActiveCard = 168;
		territoryStateInfo[tempTerID].occupiedByUnits.push(tempActiveCard);
		var tempX = 3840 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].x;
		var tempY = 2160 / 100 * territoryShapeInfo[tempTerID][(territoryShapeInfo[tempTerID].length - 1)][0][0].y;
		altCardPiles[((2 * 3) + 2)].push(tempActiveCard);
		referenceCards[tempActiveCard].trainingTime = 0;
		referenceCards[tempActiveCard].currentHP = referenceCards[tempActiveCard].maxHP;

	// optionally add function to change combatSpeed
	var combatSpeed = 1;

	console.log(referenceCards);

	/*-------------------------------------------------------------------------------------------*/

	document.getElementById('endTurnButton').onclick = function() {
		console.log('next turn');
        $('#endTurnButton').prop('disabled', true);
		$('#endTurnButton').fadeOut(150);
		// socket.emit('next turn', GRID, playerNumber);
		serverNextTurn(GRID, playerNumber);
	}
	function nextTurn(newPlayerTurn, hasCapital) {
        // in response to the server telling the client a new player's turn is starting
		for (var player = 0; player < 4; player++) {
			for (var actives = 0; actives < altCardPiles[((player * 3) + 2)].length; actives++) {
				if (referenceCards[altCardPiles[((player * 3) + 2)][actives]].trainingTime > 0) {
					referenceCards[altCardPiles[((player * 3) + 2)][actives]].trainingTime--
				}
				referenceCards[altCardPiles[((player * 3) + 2)][actives]].currentSpeed = referenceCards[altCardPiles[((player * 3) + 2)][actives]].maxSpeed;
			}
		}
		for (var couple = 0; couple < forgedArmistice.length; couple++) {
            if (newPlayerTurn === playerNumber) {
                forgedArmistice[couple].turnsLeft--;
                if (forgedArmistice[couple].turnsLeft === 0) {
                    forgedArmistice.splice(forgedArmistice[couple], 1);
                }
            }
		}
		for (var unit = 0; unit < frostDustBombs.length; unit++) {
            if (newPlayerTurn === playerNumber) {
                frostDustBombs[unit].turnsLeft--;
                if (frostDustBombs[unit].turnsLeft === 0) {
                    frostDustBombs.splice(frostDustBombs[unit], 1);
                }
            }
        }
        for (var unit = 0; unit < liquidDeath.length; unit++) {
            if (newPlayerTurn === playerNumber) {
                liquidDeath[unit].turnsLeft--;
                if (liquidDeath[unit].turnsLeft === 0) {
                    liquidDeath.splice(liquidDeath[unit], 1);
                }
            }
        }
        for (var unit = 0; unit < rustingMists.length; unit++) {
            if (newPlayerTurn === playerNumber) {
                rustingMists[unit].turnsLeft--;
                if (rustingMists[unit].turnsLeft === 0) {
                    rustingMists.splice(rustingMists[unit], 1);
                }
            }
        }
        for (var unit = 0; unit < trappingPit.length; unit++) {
            if (newPlayerTurn === playerNumber) {
                trappingPit[unit].turnsLeft--;
                if (trappingPit[unit].turnsLeft === 0) {
                    trappingPit.splice(trappingPit[unit], 1);
                }
            }
        }
		if (activeCard !== -1) {
			$('#cardImage' + (altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1)).removeClass('selected');
			activeCard = -1;
		}
		for (var item = 0; item < territoryStateInfo[activeTer].occupiedByUnits.length; item++) {
			$('#terUnitInfo' + item).remove();
			document.getElementById('terUnitTooltip' + item).remove();
		}
		for (var ter = 0; ter < territoryShapeInfo.length; ter++) {
			$('#territoryArea' + ter).removeClass('viableMovement');
			$('#territoryArea' + ter).removeClass('viableAttackTarget');
            $('#territoryArea' + ter).removeClass('viableRangedTarget');
            $('#territoryArea' + ter).removeClass('passingThrough');
            $('#territoryArea' + ter).removeClass('attackPath');
			$('#territoryArea' + ter).removeClass('viableLoadIn');
			$('#territoryArea' + activeTer).removeClass('selected');
		}
        spoilsOfWar = [0,0,0,0];
        playerTurn = newPlayerTurn;
        lastPlayerVictory = -1;
		activeTer = -1;
		activeUnits = [];
		refreshInteractibility();
		if (playerTurn === playerNumber) {
			spoilsOfWar = [1,1,1,1];
			playedCard = false;
            for (var i = 0; i < altCardPiles[((playerNumber * 3) + 2)].length; i++) {
                if (referenceCards[altCardPiles[((playerNumber * 3) + 2)][i]].cardType === 0) {
                    referenceCards[altCardPiles[((playerNumber * 3) + 2)][i]].hasAttacked = false;
                }
            }
			// players who have no capital get the option to surrender, or are considered automatically defeated if they also have no units
            if (hasCapital === false) {
				var hasUnits = false;
				for (var ter = 0; ter < territoryShapeInfo.length; ter++) {
					if (territoryShapeInfo[ter].occupiedByPlayer === playerNumber) {
						hasUnits = true;
						break;
					}
				}
				if (hasUnits === false) {
                    // socket.emit('player defeated', playerNumber);
                    // TO DO (optional): maybe have checked for defeat after each battle?
				} else {
					$('#surrenderButton').fadeIn(150);
				}
			}
			$('#endTurnButton').fadeIn(150);
            $('#endTurnButton').prop('disabled', false);
		}
	}

    // FUTURE FIX: properly add terIDs to pathToTers before this function is called and check if classes are correctly added in refreshInteractibility() after that
	function refreshInteractibility() {
		console.log('refreshInteractibility()');
		if (playerTurn === playerNumber) {
			for (var ter = 0; ter < territoryShapeInfo.length; ter++) {
				$('#territoryArea' + ter).unbind('mouseenter');
				$('#territoryArea' + ter).unbind('mouseleave');
				$('#territoryArea' + ter).unbind('click');
				$('#territoryArea' + ter).hover(
                    (function(ter) {
                        return function() {
                            $(this).toggleClass('hoveredTer');
                            if ($(this).hasClass('viableMovement') === true || $(this).hasClass('viableAttackTarget') === true || $(this).hasClass('viableRangedTarget') === true || $(this).hasClass('viableLoadIn') === true) {
                                var attackPath = false;
                                console.log('ter: ' + ter + '; PTT length: ' + territoryStateInfo[ter].pathToTer.length);
                                for (var tempPassed = 0; tempPassed < territoryStateInfo[ter].pathToTer.length; tempPassed++) {
                                    // console.log('tempPassed: ' + tempPassed);
                                    var tempPassedTerID = territoryStateInfo[ter].pathToTer[tempPassed];
                                    if ($('#territoryArea' + tempPassedTerID).hasClass('viableAttackTarget') === true) {
                                        attackPath = true;
                                        break;
                                    }
                                }
                                for (var passed = 1; passed < territoryStateInfo[ter].pathToTer.length; passed++) {
                                    // FUTURE FIX: recheck if classes are properly added once the pathToTers are fixed
                                    // console.log('checking passed areas');
                                    var tempPassedTerID = territoryStateInfo[ter].pathToTer[passed];
                                    $('#territoryArea' + tempPassedTerID).toggleClass('passingThrough');
                                    if (attackPath === true) {
                                        console.log(tempPassedTerID + ' has passingThrough');
                                        if ($('#territoryArea' + tempPassedTerID).hasClass('viableAttackTarget') === false) {
                                            $('#territoryArea' + tempPassedTerID).toggleClass('attackPath');
                                        }
                                    }
                                }
                            }
                        };
                    })(ter)
                );
				$('#territoryArea' + ter).click(function(){
					var terID = parseInt(this.id.substr(13));
					if (activeCard !== -1 && referenceCards[activeCard].cardType === 0 && $(this).hasClass('viableTarget')) {
						placeUnit(terID);
					/*} else if (activeCard !== -1 && referenceCards[activeCard].type === 2 && $(this).hasClass('viableTarget')) {
						placeUtility(terID);*/
					} else if (activeCard === -1) {
						// FUTURE FIX: does not yet detect if selecting viable attack target
						if ($(this).hasClass('viableMovement') === true) {
							moveToTer(terID);
						} else if ($(this).hasClass('viableAttackTarget') === true) {
							selectPriorityTargets(terID);
						} else if ($(this).hasClass('viableRangedTarget') === true) {
							selectPriorityTargets(terID);
						} else if ($(this).hasClass('viableLoadIn') === true) {
							loadInTransport(terID);
						} else {
							/*if (activeTer !== -1) {
								removeRadial(terID);
							}
							createRadial(terID);*/
							showTerState(terID, this);
						}
					}
					console.log(territoryStateInfo[terID].occupiedByUnits);
				});
			}
			for (var cards = 1; cards <= 8; cards++) {
				$('#cardImage' + cards).unbind('mouseenter');
				$('#cardImage' + cards).unbind('mouseleave');
				$('#cardImage' + cards).unbind('click');
				if (cards <= nOfCards[playerNumber]) {
					$('#cardImage' + cards).hover(function(){
						$(this).toggleClass('hoveredCard');
					});
					$('#cardImage' + cards).click(function(){
						var cardID = altCardPiles[((playerNumber * 3) + 1)][this.cellIndex - 1];
						selectCard(cardID, this);
					});
				}
			}
		} else {
            for (var ter = 0; ter < territoryShapeInfo.length; ter++) {
                $('#territoryArea' + ter).unbind('mouseenter');
                $('#territoryArea' + ter).unbind('mouseleave');
                $('#territoryArea' + ter).unbind('click');
                $('#territoryArea' + ter).hover(function(){
                    $(this).toggleClass('hoveredTer');
                });
            }
		}
	}
	refreshInteractibility();
    // TO DO (optional): use different icon shapes if all units are of 1 type (ground, air, naval) or mixed
	function refreshTerStateVisuals(terID) {
		console.log('refreshTerStateVisuals()');
		var nOfIcons = -1;
		// displayedIcons are: units, defense level, natural hazards
		var displayedIcons = [0,0,0];
		if (territoryStateInfo[terID].occupiedByUnits.length > 0) {
			for (var units = 0; units < territoryStateInfo[terID].occupiedByUnits.length; units++) {
				if (referenceCards[territoryStateInfo[terID].occupiedByUnits[units]].name !== 'Wall') {
					nOfIcons++;
					displayedIcons[0] = 1;
					break;
				}
			}
		}
		if (territoryStateInfo[terID].capital === true) {
			nOfIcons++;
			displayedIcons[1] = 1;
		} else {
			for (var units = 0; units < territoryStateInfo[terID].occupiedByUnits.length; units++) {
				if (referenceCards[territoryStateInfo[terID].occupiedByUnits[units]].name === 'Wall') {
					nOfIcons++;
					displayedIcons[1] = 1;
					break;
				}
			}
		}
		if (territoryStateInfo[terID].naturalHazardIDs.length > 0) {
			nOfIcons++;
			displayedIcons[2] = 1;
		}
		$('#unitIconTer' + terID).remove();
		$('#unitNumbersTer' + terID).remove();
		$('#defIconTer' + terID).remove();
		$('#defNumbersTer' + terID).remove();
		$('#nhIconTer' + terID).remove();
		$('#nhNumbersTer' + terID).remove();
		var iconsInUse = 0;
		if (displayedIcons[0] === 1) {
			var tempX = 3840 / 100 * territoryShapeInfo[terID][(territoryShapeInfo[terID].length - 1)][nOfIcons][iconsInUse].x
			var tempY = 2160 / 100 * territoryShapeInfo[terID][(territoryShapeInfo[terID].length - 1)][nOfIcons][iconsInUse].y
			var icon = document.createElementNS('http:// www.w3.org/2000/svg','circle');
			icon.setAttributeNS(null, "cx", tempX);
			icon.setAttributeNS(null, "cy", tempY);
			icon.setAttributeNS(null, "r", 2160 / 100 * 1.5);
			icon.setAttributeNS(null, "stroke", 'black');
			icon.setAttributeNS(null, "stroke-width", 4);
			icon.setAttributeNS(null, "fill", kingdomColorArray[territoryStateInfo[terID].occupiedByPlayer]);
			icon.id = 'unitIconTer' + terID;
			document.getElementById('gameBoardSVG').appendChild(icon);
			document.getElementById('unitIconTer' + terID).classList.add('territoryCircle');
			document.getElementById('unitIconTer' + terID).classList.add('territoryArea');
			var text = document.createElementNS('http:// www.w3.org/2000/svg','text');
			text.setAttributeNS(null, "x", tempX - 1);
			text.setAttributeNS(null, "y", tempY + 5);
			text.setAttributeNS(null, "font-size", '290%');
			text.setAttributeNS(null, "alignment-baseline", 'middle');
			text.setAttributeNS(null, "text-anchor", 'middle');
			text.setAttributeNS(null, "font-family", 'arial');
			text.id = 'unitNumbersTer' + terID;
			document.getElementById('gameBoardSVG').appendChild(text);
			document.getElementById('unitNumbersTer' + terID).classList.add('territoryText');
			document.getElementById('unitNumbersTer' + terID).classList.add('territoryArea');
			var nonWallUnits = 0;
			for (var units = 0; units < territoryStateInfo[terID].occupiedByUnits.length; units++) {
				if (referenceCards[territoryStateInfo[terID].occupiedByUnits[units]].name !== 'Wall') {
					nonWallUnits++;
				}
			}
			d3.select('#unitNumbersTer' + terID).text(nonWallUnits.toString());
			iconsInUse++;
		}
		if (displayedIcons[1] === 1) {
			var tempX = 3840 / 100 * territoryShapeInfo[terID][(territoryShapeInfo[terID].length - 1)][nOfIcons][iconsInUse].x
			var tempY = 2160 / 100 * territoryShapeInfo[terID][(territoryShapeInfo[terID].length - 1)][nOfIcons][iconsInUse].y
			var icon = document.createElementNS('http:// www.w3.org/2000/svg','polygon');
			if (territoryStateInfo[terID].capital === true) {
				// FUTURE FIX: either its shitty pixel placement or this star is not perfectly shaped. May have to use... math *brrr* to determine this
				icon.setAttributeNS(null, "points",
					(tempX - (3840 / 100 * 0.65)) + ',' + (tempY + (2160 / 100 * 1.4)) + ' ' +
					(tempX - (3840 / 100 * 0.6)) + ',' + (tempY + (2160 / 100 * 0.5)) + ' ' +
					(tempX - (3840 / 100 * 0.85)) + ',' + (tempY - (2160 / 100 * 0.25)) + ' ' +
					(tempX - (3840 / 100 * 0.35)) + ',' + (tempY - (2160 / 100 * 0.65)) + ' ' +
					tempX + ',' + (tempY - (2160 / 100 * 1.7)) + ' ' +
					(tempX + (3840 / 100 * 0.35)) + ',' + (tempY - (2160 / 100 * 0.65)) + ' ' +
					(tempX + (3840 / 100 * 0.85)) + ',' + (tempY - (2160 / 100 * 0.25)) + ' ' +
					(tempX + (3840 / 100 * 0.6)) + ',' + (tempY + (2160 / 100 * 0.5)) + ' ' +
					(tempX + (3840 / 100 * 0.65)) + ',' + (tempY + (2160 / 100 * 1.4)) + ' ' +
					tempX + ',' + (tempY + (2160 / 100 * 1)));
			} else {
				icon.setAttributeNS(null, "points",
					(tempX - (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
					(tempX - (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
					(tempX - (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
					(tempX - (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 0.9)) + ' ' +
					(tempX + (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 0.9)) + ' ' +
					(tempX + (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
					(tempX + (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
					(tempX + (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)));
			}
			icon.setAttributeNS(null, "style", 'stroke:black;stroke-width:4;fill:' + kingdomColorArray[territoryStateInfo[terID].occupiedByPlayer]);
			icon.id = 'defIconTer' + terID;
			document.getElementById('gameBoardSVG').appendChild(icon);
			document.getElementById('defIconTer' + terID).classList.add('territoryCircle');
			document.getElementById('defIconTer' + terID).classList.add('territoryArea');
			var text = document.createElementNS('http:// www.w3.org/2000/svg','text');
			text.setAttributeNS(null, "x", tempX);
			text.setAttributeNS(null, "y", tempY + 5);
			text.setAttributeNS(null, "font-size", '290%');
			text.setAttributeNS(null, "alignment-baseline", 'middle');
			text.setAttributeNS(null, "text-anchor", 'middle');
			text.setAttributeNS(null, "font-family", 'arial');
			text.id = 'defNumbersTer' + terID;
			document.getElementById('gameBoardSVG').appendChild(text);
			document.getElementById('defNumbersTer' + terID).classList.add('territoryText');
			document.getElementById('defNumbersTer' + terID).classList.add('territoryArea');
			var wallLevel = 0;
			for (var units = 0; units < territoryStateInfo[terID].occupiedByUnits.length; units++) {
				if (referenceCards[territoryStateInfo[terID].occupiedByUnits[units]].name === 'Wall') {
					wallLevel = 1;
					for (var levels = 0; levels < referenceCards[territoryStateInfo[terID].occupiedByUnits[units]].appliedEffects.length; levels++) {
						wallLevel++;
					}
				}
			}
			d3.select('#defNumbersTer' + terID).text(wallLevel.toString());
			iconsInUse++;
		}
		if (displayedIcons[2] === 1) {
			var tempX = 3840 / 100 * territoryShapeInfo[terID][(territoryShapeInfo[terID].length - 1)][nOfIcons][iconsInUse].x
			var tempY = 2160 / 100 * territoryShapeInfo[terID][(territoryShapeInfo[terID].length - 1)][nOfIcons][iconsInUse].y
			if (territoryStateInfo[terID].naturalHazardIDs.length > 1) {
				// general natural hazard icon with number of hazards
				var icon = document.createElementNS('http:// www.w3.org/2000/svg','polygon');
				icon.setAttributeNS(null, "points",
					(tempX - (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
					tempX + ',' + (tempY - (2160 / 100 * 1.5)) + ' ' +
					(tempX + (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)));
				icon.setAttributeNS(null, "style", 'stroke:black;stroke-width:3;fill:lightgray');
				icon.id = 'nhIconTer' + terID;
				document.getElementById('gameBoardSVG').appendChild(icon);
				document.getElementById('nhIconTer' + terID).classList.add('territoryIcon');
				document.getElementById('nhIconTer' + terID).classList.add('territoryArea');
				var text = document.createElementNS('http:// www.w3.org/2000/svg','text');
				text.setAttributeNS(null, "x", tempX);
				text.setAttributeNS(null, "y", tempY + 7);
				text.setAttributeNS(null, "font-size", '280%');
				text.setAttributeNS(null, "alignment-baseline", 'middle');
				text.setAttributeNS(null, "text-anchor", 'middle');
				text.setAttributeNS(null, "font-family", 'arial');
				text.id = 'nhNumbersTer' + terID;
				document.getElementById('gameBoardSVG').appendChild(text);
				document.getElementById('nhNumbersTer' + terID).classList.add('territoryText');
				document.getElementById('nhNumbersTer' + terID).classList.add('territoryArea');
				d3.select('#nhNumbersTer' + terID).text(territoryStateInfo[terID].naturalHazardIDs.length.toString());
			} else {
				// FUTURE FIX: change icons to represent each natural hazard
				switch(referenceCards[territoryStateInfo[terID].naturalHazardIDs[0]].name) {
					case 'Earthquake':
						var icon = document.createElementNS('http:// www.w3.org/2000/svg','polygon');
						icon.setAttributeNS(null, "points",
							(tempX - (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX - (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							tempX + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 1)) + ' ' +
							(tempX + (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX + (3840 / 100 * 0.15)) + ',' + (tempY + (2160 / 100 * 0.4)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.10)) + ',' + (tempY - (2160 / 100 * 0.8)) + ' ' +
							(tempX - (3840 / 100 * 0.05)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY + (2160 / 100 * 0.4)) + ' ' +
							(tempX - (3840 / 100 * 0.10)) + ',' + (tempY + (2160 / 100 * 1.1)));
						icon.setAttributeNS(null, "style", 'stroke:black;stroke-width:4;fill:lightgray');
						icon.id = 'nhIconTer' + terID;
						document.getElementById('gameBoardSVG').appendChild(icon);
						document.getElementById('nhIconTer' + terID).classList.add('territoryIcon');
						document.getElementById('nhIconTer' + terID).classList.add('territoryArea');
						break;
					case 'Lightning Storm':
						var icon = document.createElementNS('http:// www.w3.org/2000/svg','polygon');
						icon.setAttributeNS(null, "points",
							(tempX - (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX - (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							tempX + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 1)) + ' ' +
							(tempX + (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX + (3840 / 100 * 0.15)) + ',' + (tempY + (2160 / 100 * 0.4)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.10)) + ',' + (tempY - (2160 / 100 * 0.8)) + ' ' +
							(tempX - (3840 / 100 * 0.05)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY + (2160 / 100 * 0.4)) + ' ' +
							(tempX - (3840 / 100 * 0.10)) + ',' + (tempY + (2160 / 100 * 1.1)));
						icon.setAttributeNS(null, "style", 'stroke:black;stroke-width:4;fill:lightgray');
						icon.id = 'nhIconTer' + terID;
						document.getElementById('gameBoardSVG').appendChild(icon);
						document.getElementById('nhIconTer' + terID).classList.add('territoryIcon');
						document.getElementById('nhIconTer' + terID).classList.add('territoryArea');
						break;
					case 'Maelstrom':
						var icon = document.createElementNS('http:// www.w3.org/2000/svg','polygon');
						icon.setAttributeNS(null, "points",
							(tempX - (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX - (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							tempX + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 1)) + ' ' +
							(tempX + (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX + (3840 / 100 * 0.15)) + ',' + (tempY + (2160 / 100 * 0.4)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.10)) + ',' + (tempY - (2160 / 100 * 0.8)) + ' ' +
							(tempX - (3840 / 100 * 0.05)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY + (2160 / 100 * 0.4)) + ' ' +
							(tempX - (3840 / 100 * 0.10)) + ',' + (tempY + (2160 / 100 * 1.1)));
						icon.setAttributeNS(null, "style", 'stroke:black;stroke-width:4;fill:lightgray');
						icon.id = 'nhIconTer' + terID;
						document.getElementById('gameBoardSVG').appendChild(icon);
						document.getElementById('nhIconTer' + terID).classList.add('territoryIcon');
						document.getElementById('nhIconTer' + terID).classList.add('territoryArea');
						break;
					case 'Sandstorm':
						var icon = document.createElementNS('http:// www.w3.org/2000/svg','polygon');
						icon.setAttributeNS(null, "points",
							(tempX - (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX - (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							tempX + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 1)) + ' ' +
							(tempX + (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX + (3840 / 100 * 0.15)) + ',' + (tempY + (2160 / 100 * 0.4)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.10)) + ',' + (tempY - (2160 / 100 * 0.8)) + ' ' +
							(tempX - (3840 / 100 * 0.05)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY + (2160 / 100 * 0.4)) + ' ' +
							(tempX - (3840 / 100 * 0.10)) + ',' + (tempY + (2160 / 100 * 1.1)));
						icon.setAttributeNS(null, "style", 'stroke:black;stroke-width:4;fill:lightgray');
						icon.id = 'nhIconTer' + terID;
						document.getElementById('gameBoardSVG').appendChild(icon);
						document.getElementById('nhIconTer' + terID).classList.add('territoryIcon');
						document.getElementById('nhIconTer' + terID).classList.add('territoryArea');
						break;
					case 'Tornado':
						var icon = document.createElementNS('http:// www.w3.org/2000/svg','polygon');
						icon.setAttributeNS(null, "points",
							(tempX - (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX - (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							tempX + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 1)) + ' ' +
							(tempX + (3840 / 100 * 0.25)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY - (2160 / 100 * 1.4)) + ' ' +
							(tempX + (3840 / 100 * 0.75)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY + (2160 / 100 * 1.1)) + ' ' +
							(tempX + (3840 / 100 * 0.15)) + ',' + (tempY + (2160 / 100 * 0.4)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.10)) + ',' + (tempY - (2160 / 100 * 0.8)) + ' ' +
							(tempX - (3840 / 100 * 0.05)) + ',' + (tempY - (2160 / 100 * 0.3)) + ' ' +
							(tempX + (3840 / 100 * 0.05)) + ',' + (tempY + (2160 / 100 * 0.4)) + ' ' +
							(tempX - (3840 / 100 * 0.10)) + ',' + (tempY + (2160 / 100 * 1.1)));
						icon.setAttributeNS(null, "style", 'stroke:black;stroke-width:4;fill:lightgray');
						icon.id = 'nhIconTer' + terID;
						document.getElementById('gameBoardSVG').appendChild(icon);
						document.getElementById('nhIconTer' + terID).classList.add('territoryIcon');
						document.getElementById('nhIconTer' + terID).classList.add('territoryArea');
						break;
				}
			}
		}
	}
	for (var ter = 0; ter < territoryStateInfo.length; ter++) {
		refreshTerStateVisuals(ter);
	}

	function flyCardFly(startX, startY, endX, endY, time) {
		console.log('flyCardFly()');
		$('#flyingCard').offset({top:startY, left:startX});
		$('#flyingCard').show();
		var frameTime = 20;
		var frameNumber = 0;
		var frameMax = Math.round(time / frameTime);
		var awayHeGoes = setInterval(updateFrame, frameTime);
		function updateFrame() {
			if (frameNumber >= frameMax) {
				$('#flyingCard').hide();
				clearInterval(awayHeGoes);
			} else {
				frameNumber++;
				var posX = startX - (((startX - endX) / frameMax) * frameNumber);
				var posY = startY - (((startY - endY) / frameMax) * frameNumber);
				$('#flyingCard').offset({top:posY, left:posX});
			}
		}
	}
	function createCardVisuals(cardID) {
		console.log('createCardVisuals()');
		var tempPos = (altCardPiles[((playerNumber * 3) + 1)].length + 1);
		document.getElementById('cardVisualsName' + tempPos).innerHTML = referenceCards[cardID].name;
		if (referenceCards[cardID].hasOwnProperty('trainingTime')) {
			document.getElementById('cardVisualsDuration' + tempPos).innerHTML = referenceCards[cardID].trainingTime + 'TR';
		} else if (referenceCards[cardID].hasOwnProperty('duration')) {
			switch (referenceCards[cardID].duration) {
				case 0: break;
				case 999: document.getElementById('cardVisualsDuration' + tempPos).innerHTML = 'Perm.'; break;
				default: document.getElementById('cardVisualsDuration' + tempPos).innerHTML = referenceCards[cardID].duration + 'TR'; break;
			}
		}
		if (referenceCards[cardID].cardType === 0) {
			document.getElementById('cardVisualsSpeed' + tempPos).innerHTML = referenceCards[cardID].maxSpeed + 'SP';
		}
		if (referenceCards[cardID].cardType === 0) {
			document.getElementById('cardVisualsAttack' + tempPos).innerHTML = referenceCards[cardID].attack + 'ATK';
		}
		if (referenceCards[cardID].cardType === 0) {
			document.getElementById('cardVisualsHP' + tempPos).innerHTML = referenceCards[cardID].maxHP + 'HP';
		}
		document.getElementById('cardVisualsImage' + tempPos).src = referenceCards[cardID].image;
		if (referenceCards[cardID].cardType === 0) {
			switch (referenceCards[cardID].size) {
				case 0: document.getElementById('cardVisualsSizeType' + tempPos).innerHTML = 'Unit'; break;
				case 1: document.getElementById('cardVisualsSizeType' + tempPos).innerHTML = 'Large unit'; break;
				case 2: document.getElementById('cardVisualsSizeType' + tempPos).innerHTML = 'Huge unit'; break;
				case 3: document.getElementById('cardVisualsSizeType' + tempPos).innerHTML = 'Colossal unit'; break;
				case 99: document.getElementById('cardVisualsSizeType' + tempPos).innerHTML = 'Structure'; break;
			}
		} else if (referenceCards[cardID].cardType === 1) {
			document.getElementById('cardVisualsSizeType' + tempPos).innerHTML = 'Trap';
		} else if (referenceCards[cardID].cardType === 2) {
			document.getElementById('cardVisualsSizeType' + tempPos).innerHTML = 'Utility';
		}
		if (referenceCards[cardID].cardType === 0) {
			switch (referenceCards[cardID].mechanical) {
				case 0: document.getElementById('cardVisualsMechanical' + tempPos).innerHTML = 'Non-Mech.'; break;
				case 1: document.getElementById('cardVisualsMechanical' + tempPos).innerHTML = 'Half-Mech.'; break;
				case 2: document.getElementById('cardVisualsMechanical' + tempPos).innerHTML = 'Full-Mech.'; break;
			}
		}
		document.getElementById('cardVisualsDescription' + tempPos).innerHTML = referenceCards[cardID].description;
		nOfCards[playerNumber] = altCardPiles[((playerNumber * 3) + 1)].length;
		refreshInteractibility();
		targetCard = -1;
	}
	function clearCardVisuals(cardIndex) {
		console.log('clearCardVisuals()');
        // socket.emit('clear card visuals', GRID, playerNumber);
		for (var pos = (cardIndex + 1); pos < altCardPiles[((playerNumber * 3) + 1)].length; pos++) {
			document.getElementById('cardVisualsName' + pos).innerHTML = '';
			document.getElementById('cardVisualsDuration' + pos).innerHTML = '';
			document.getElementById('cardVisualsSpeed' + pos).innerHTML = '';
			document.getElementById('cardVisualsAttack' + pos).innerHTML = '';
			document.getElementById('cardVisualsHP' + pos).innerHTML = '';
			document.getElementById('cardVisualsImage' + pos).src = '';
			document.getElementById('cardVisualsSizeType' + pos).innerHTML = '';
			document.getElementById('cardVisualsMechanical' + pos).innerHTML = '';
			document.getElementById('cardVisualsDescription' + pos).innerHTML = '';

			document.getElementById('cardVisualsName' + pos).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].name;
			if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].hasOwnProperty('trainingTime')) {
				document.getElementById('cardVisualsDuration' + pos).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].trainingTime + 'TR';
			} else if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].hasOwnProperty('duration')) {
				switch (referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].duration) {
					case 0: break;
					case 999: document.getElementById('cardVisualsDuration' + pos).innerHTML = 'Perm.'; break;
					default: document.getElementById('cardVisualsDuration' + pos).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].duration + 'TR'; break;
				}
			}
			if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].cardType === 0) {
				document.getElementById('cardVisualsSpeed' + pos).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].maxSpeed + 'SP';
			}
			if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].cardType === 0) {
				document.getElementById('cardVisualsAttack' + pos).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].attack + 'ATK';
			}
			if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].cardType === 0) {
				document.getElementById('cardVisualsHP' + pos).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].maxHP + 'HP';
			}
			document.getElementById('cardVisualsImage' + pos).src = referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].image;
			if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].cardType === 0) {
				switch (referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].size) {
					case 0: document.getElementById('cardVisualsSizeType' + pos).innerHTML = 'Unit'; break;
					case 1: document.getElementById('cardVisualsSizeType' + pos).innerHTML = 'Large unit'; break;
					case 2: document.getElementById('cardVisualsSizeType' + pos).innerHTML = 'Huge unit'; break;
					case 3: document.getElementById('cardVisualsSizeType' + pos).innerHTML = 'Colossal unit'; break;
					case 99: document.getElementById('cardVisualsSizeType' + pos).innerHTML = 'Structure'; break;
				}
			} else if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].cardType === 1) {
				document.getElementById('cardVisualsSizeType' + pos).innerHTML = 'Trap';
			} else if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].cardType === 2) {
				document.getElementById('cardVisualsSizeType' + pos).innerHTML = 'Utility';
			}
			if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].cardType === 0) {
				switch (referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].mechanical) {
					case 0: document.getElementById('cardVisualsMechanical' + pos).innerHTML = 'Non-Mech.'; break;
					case 1: document.getElementById('cardVisualsMechanical' + pos).innerHTML = 'Half-Mech.'; break;
					case 2: document.getElementById('cardVisualsMechanical' + pos).innerHTML = 'Full-Mech.'; break;
				}
			}
			document.getElementById('cardVisualsDescription' + pos).innerHTML = referenceCards[altCardPiles[((playerNumber * 3) + 1)][pos]].description;
		}
		document.getElementById('cardVisualsName' + altCardPiles[((playerNumber * 3) + 1)].length).innerHTML = '';
		document.getElementById('cardVisualsDuration' + altCardPiles[((playerNumber * 3) + 1)].length).innerHTML = '';
		document.getElementById('cardVisualsSpeed' + altCardPiles[((playerNumber * 3) + 1)].length).innerHTML = '';
		document.getElementById('cardVisualsAttack' + altCardPiles[((playerNumber * 3) + 1)].length).innerHTML = '';
		document.getElementById('cardVisualsHP' + altCardPiles[((playerNumber * 3) + 1)].length).innerHTML = '';
		document.getElementById('cardVisualsImage' + altCardPiles[((playerNumber * 3) + 1)].length).src = '';
		document.getElementById('cardVisualsSizeType' + altCardPiles[((playerNumber * 3) + 1)].length).innerHTML = '';
		document.getElementById('cardVisualsMechanical' + altCardPiles[((playerNumber * 3) + 1)].length).innerHTML = '';
		document.getElementById('cardVisualsDescription' + altCardPiles[((playerNumber * 3) + 1)].length).innerHTML = '';
		// FUTURE FIX: remove selectability
		altCardPiles[((playerNumber * 3) + 1)].splice(cardIndex,1);
		nOfCards[playerNumber] = altCardPiles[((playerNumber * 3) + 1)].length;
		activeCard = -1;
		refreshInteractibility();
	}
    function displayTargetCard(topText, cardID) {
        // I mightve missed some places where this function should also be executed
        document.getElementById('singleCardTopText').innerHTML = topText;
        document.getElementById('singleCardVisualsName').innerHTML = referenceCards[cardID].name;
        if (referenceCards[cardID].hasOwnProperty('trainingTime')) {
            document.getElementById('singleCardVisualsDuration').innerHTML = referenceCards[cardID].trainingTime + 'TR';
        } else if (referenceCards[cardID].hasOwnProperty('duration')) {
            switch (referenceCards[cardID].duration) {
                case 0: break;
                case 999: document.getElementById('singleCardVisualsDuration').innerHTML = 'Perm.'; break;
                default: document.getElementById('singleCardVisualsDuration').innerHTML = referenceCards[cardID].duration + 'TR'; break;
            }
        }
        if (referenceCards[cardID].cardType === 0) {
            document.getElementById('singleCardVisualsSpeed').innerHTML = referenceCards[cardID].maxSpeed + 'SP';
            document.getElementById('singleCardVisualsSpeed').style.color = 'black';
        }
        if (referenceCards[cardID].cardType === 0) {
            document.getElementById('singleCardVisualsAttack').innerHTML = referenceCards[cardID].attack + 'ATK';
            document.getElementById('singleCardVisualsAttack').style.color = 'black';
        }
        if (referenceCards[cardID].cardType === 0) {
            document.getElementById('singleCardVisualsHP').innerHTML = referenceCards[cardID].maxHP + 'HP';
            document.getElementById('singleCardVisualsHP').style.color = 'black';
        }
        document.getElementById('singleCardVisualsImage').src = referenceCards[cardID].image;
        if (referenceCards[cardID].cardType === 0) {
            switch (referenceCards[cardID].size) {
                case 0: document.getElementById('singleCardVisualsSizeType').innerHTML = 'Unit'; break;
                case 1: document.getElementById('singleCardVisualsSizeType').innerHTML = 'Large unit'; break;
                case 2: document.getElementById('singleCardVisualsSizeType').innerHTML = 'Huge unit'; break;
                case 3: document.getElementById('singleCardVisualsSizeType').innerHTML = 'Colossal unit'; break;
                case 99: document.getElementById('singleCardVisualsSizeType').innerHTML = 'Structure'; break;
            }
            document.getElementById('singleCardVisualsSizeType').style.color = 'black';
        } else if (referenceCards[cardID].cardType === 1) {
            document.getElementById('singleCardVisualsSizeType').innerHTML = 'Trap';
        } else if (referenceCards[cardID].cardType === 2) {
            document.getElementById('singleCardVisualsSizeType').innerHTML = 'Utility';
        }
        if (referenceCards[cardID].cardType === 0) {
            switch (referenceCards[cardID].mechanical) {
                case 0: document.getElementById('singleCardVisualsMechanical').innerHTML = 'Non-Mech.'; break;
                case 1: document.getElementById('singleCardVisualsMechanical').innerHTML = 'Half-Mech.'; break;
                case 2: document.getElementById('singleCardVisualsMechanical').innerHTML = 'Full-Mech.'; break;
            }
            document.getElementById('singleCardVisualsMechanical').style.color = 'black';
        }
        document.getElementById('singleCardVisualsDescription').innerHTML = referenceCards[cardID].description;
        document.getElementById('singleCardVisualsDescription').style.color = 'black';
        $('#singleCardWindow').fadeIn(150);
        setTimeout(function() {
            $('#singleCardWindow').fadeOut(150);
        }, 2000);
    }

	function selectCard(cardID, thisCard) {
		console.log('selectCard()');
		$('#territoryArea' + activeTer).removeClass('selected');
		activeTer = -1;
		document.getElementById('terGenInfo').innerHTML = '';
		document.getElementById('terUnitInfo').innerHTML = '';
		for (var ter = 0; ter < territoryStateInfo.length; ter++) {
			$('#territoryArea' + ter).removeClass('viableMovement');
			$('#territoryArea' + ter).removeClass('viableLoadIn');
            $('#territoryArea' + ter).removeClass('viableAttackTarget');
			$('#territoryArea' + ter).removeClass('viableRangedTarget');
            $('#territoryArea' + ter).removeClass('passingThrough');
            $('#territoryArea' + ter).removeClass('attackPath');
		}
		if (activeCard !== cardID) {
			$('#cardImage' + (altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1)).removeClass('selected');
			activeCard = cardID;
			$(thisCard).addClass('selected');
			if (referenceCards[activeCard].cardType === 0) {
				// unit card
				for (var ter = 0; ter < territoryShapeInfo.length; ter++) {
					if (territoryStateInfo[ter].type === 0 && (referenceCards[activeCard].type === 0 || referenceCards[activeCard].type === 2 || referenceCards[activeCard].type === 3 || referenceCards[activeCard].type === 5) && territoryStateInfo[ter].ownedByPlayer === playerNumber && (territoryStateInfo[ter].occupiedByPlayer === playerNumber || territoryStateInfo[ter].occupiedByPlayer === -1)) {
						var tempWallDetect = 0;
						for (var unit = 0; unit < territoryStateInfo[ter].occupiedByUnits.length; unit++) {
							if (referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].name === 'Wall') {
								tempWallDetect = 1;
							}
						}
						if (referenceCards[activeCard].name !== 'Wall' || tempWallDetect === 0) {
							$('#territoryArea' + ter).addClass('viableTarget');
						}
					}
					// naval territories are only viable if adjacent to owned land territory or occupied by naval unit
					for (var adj = 0; adj < territoryStateInfo[ter].adjacentTer.length; adj++) {
						var tempAdjID = territoryStateInfo[ter].adjacentTer[adj];
						if (territoryStateInfo[ter].type === 1 && (referenceCards[activeCard].type === 1 || referenceCards[activeCard].type === 2 || referenceCards[activeCard].type === 4 || referenceCards[activeCard].type === 5) && (territoryStateInfo[ter].occupiedByPlayer === playerNumber || territoryStateInfo[ter].occupiedByPlayer === -1) && (/*owned land territory*/territoryStateInfo[ter].ownedByPlayer === playerNumber || /*adjacent to owned land territory*/(territoryStateInfo[tempAdjID].type === 0 && territoryStateInfo[tempAdjID].ownedByPlayer === playerNumber) || /*adjacent to friendly occupied naval*/(territoryStateInfo[tempAdjID].type === 1 && territoryStateInfo[tempAdjID].occupiedByPlayer === playerNumber))) {
							$('#territoryArea' + ter).addClass('viableTarget');
							break;
						}
					}
				}
			} else if (referenceCards[activeCard].cardType === 2) {
				placeUtility();
			}
		} else {
			activeCard = -1;
			$(thisCard).removeClass('selected');
			for (var ter = 0; ter < territoryShapeInfo.length; ter++) {
				$('#territoryArea' + ter).removeClass('viableTarget');
			}
		}
		// console.log(activeCard);
	}
	function placeUnit(terID) {
		console.log('placeUnit()');
        // socket.emit('place unit', GRID, playerNumber, activeCard, terID);
		playedCard = true;
		addToCardHistory(activeCard, playerNumber);
		territoryStateInfo[terID].occupiedByUnits.push(activeCard);
        territoryStateInfo[terID].occupiedByPlayer = playerNumber;
		for (var ter = 0; ter < territoryStateInfo.length; ter++) {
			$('#territoryArea' + ter).removeClass('viableTarget');
		}
		// made as array in case the Schnee Dust Company card is no longer unique per deck in the future. effect won't stack, though
		var schneeID = [];
		for (var obj = 0; obj < referenceCards.length; obj++) {
			if (referenceCards[obj].name === 'Schnee Dust Company') {
				schneeID.push(obj);
			}
		}
		for (var arr = 0; arr < schneeID.length; arr++) {
			if (altCardPiles[((playerNumber * 3) + 2)].indexOf(schneeID[arr]) !== -1) {
				referenceCards[activeCard].attack = referenceCards[activeCard].attack + 5;
				break;
			}
		}
		$('#cardImage' + (altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1)).removeClass('selected');
        clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard));
		altCardPiles[((playerNumber * 3) + 2)].push(activeCard);
		activeCard = -1;
		refreshTerStateVisuals(terID);
		refreshInteractibility();
	}
	var viableCards = [];
	var cardSource = -1;
	var carouselCurrentIndex = 0;
	var tempReturn = -1;
	var lastPlayerVictory = -1;
	function placeUtility() {
		console.log('placeUtility()');
        var tempSelected = false;
		switch(referenceCards[activeCard].name) {
			case 'Amethyst Grove Saboteur':
				for (var p = 1; p < 4; p++) {
					if (altCardPiles[((p * 3) + 3)].length > 0) {
						$('#p' + p + 'Area').click(
							(function(p) {
								return function() {
									if (tempSelected === false) {
                                        tempSelected = true;
										viableCards = [];
										playedCard = true;
                                        targetPlayer = playerByPos[p-1];
										addToCardHistory(activeCard, playerNumber);
										for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 1)].length; card++) {
											if (referenceCards[altCardPiles[((targetPlayer * 3) + 1)][card]].cardType === 1) {
												viableCards.push(altCardPiles[((targetPlayer * 3) + 1)][card]);
											}
										}
                                        var deletedCardIndex = -1;
										if (viableCards.length > 0) {
											var deletedCardIndex = altCardPiles[((targetPlayer * 3) + 1)].indexOf(viableCards[Math.floor(Math.random() * (viableCards.length - 1))]);
											altCardPiles[((targetPlayer * 3) + 1)].splice(altCardPiles[((targetPlayer * 3) + 1)][deletedCardIndex], 1);
										}
                                        // socket.emit('place amethyst grove saboteur', GRID, playerNumber, targetPlayer, activeCard, deletedCardIndex);
										nOfCards[targetPlayer] = altCardPiles[((targetPlayer * 3) + 1)].length;
										clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
										refreshInteractibility();
									}
								};
							})(p)
						);
					}
				}
				break;
			case 'Atlesian Engineers':
                if (tempSelected === false) {
                    tempSelected = true;
    				playedCard = true;
    				addToCardHistory(activeCard, playerNumber);
    				// FUTURE FIX: check with every repair action if this card is in player's active pile
    				$('#cardImage' + (altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1)).removeClass('selected');
    				altCardPiles[((playerNumber * 3) + 2)].push(activeCard);
    				clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                    // socket.emit('place atlesian engineers', GRID, playerNumber, activeCard);
                }
			case 'Concentrated Dust':
				var viableUtilityTargets = [];
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					viableUtilityTargets.push([]);
					for (var unit = 0; unit < territoryStateInfo[ter].occupiedByUnits.length; unit++) {
						if (referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].trainingTime === 0 && territoryStateInfo[ter].occupiedByPlayer === playerNumber) {
							var incompatibleEffect = false;
							for (var effect = 0; effect < referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects.length; effect++) {
								if (referenceCards[referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects[effect]].compatibilityGroup === 1) {
									incompatibleEffect = true;
									break;
								}
							}
							if (incompatibleEffect === true) {
								break;
							}
							viableUtilityTargets[ter].push(territoryStateInfo[ter].occupiedByUnits[unit]);
							if ($('#territoryArea' + ter).hasClass !== 'viableTarget') {
								$('#territoryArea' + ter).addClass('viableTarget');
								$('#territoryArea' + ter).click(
									(function(ter) {
										return function() {
                                            if (tempSelected === false) {
                                                // FUTURE FIX: currently doesnt allow you to change ters once selected. May need a different approach to allow players to check units per ter before finalizing decision
                                                tempSelected = true;
                                                playedCard = true;
                                                addToCardHistory(activeCard, playerNumber);
                                                applyUtility(viableUtilityTargets[ter]);
                                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                            }
										};
									})(ter)
								);
							}
						}
					}
				}
				break;
			case 'Desert Scavenge':
				for (var p = 1; p < 4; p++) {
					if (altCardPiles[((p * 3) + 3)].length > 0) {
						$('#p' + p + 'Area').click(
							(function(p) {
								return function() {
									if (tempSelected === false) {
                                        tempSelected = true;
										viableCards = [];
										targetPlayer = playerByPos[p-1];
										for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 3)].length; card++) {
											if (referenceCards[altCardPiles[((targetPlayer * 3) + 3)][card]].cardType !== 0) {
												viableCards.push(altCardPiles[((targetPlayer * 3) + 3)][card]);
											}
										}
										if (viableCards.length > 0) {
											playedCard = true;
											addToCardHistory(activeCard, playerNumber);
											// FUTURE FIX: highlight valid targets or grey out invalid targets to show where players have to click
											carouselCurrentIndex = 0;
											drawRandomFromPlayer(targetPlayer, 2);
											clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                            // socket.emit('place desert scavenge', GRID, playerNumber, activeCard);
										}
									}
								};
							})(p)
						);
					}
				}
				if (altCardPiles[((playerNumber * 3) + 3)].length > 0) {
					$('#kingdomImage').click(function() {
						if (tempSelected === false) {
                            tempSelected = true;
							viableCards = [];
							targetPlayer = playerByPos[p-1];
							for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 3)].length; card++) {
								if (referenceCards[altCardPiles[((targetPlayer * 3) + 3)][card]].cardType !== 0) {
									viableCards.push(altCardPiles[((targetPlayer * 3) + 3)][card]);
								}
							}
							if (viableCards.length > 0) {
								playedCard = true;
								addToCardHistory(activeCard, playerNumber);
								carouselCurrentIndex = 0;
								drawRandomFromPlayer(playerNumber, 2);
								clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                // socket.emit('place desert scavenge', GRID, playerNumber, activeCard);
							}
						}
					});
				}
				break;
			case 'Earthquake':
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					var hasNH = false;
					for (var nh = 0; nh < territoryStateInfo[ter].naturalHazardIDs.length; nh++) {
						if (referenceCards[territoryStateInfo[ter].naturalHazardIDs[nh]].name === 'Earthquake') {
							hasNH = true;
						}
					}
					if (hasNH === true) {
						break;
					} else {
						for (var adjacent = 0; adjacent < territoryStateInfo[ter].adjacentTer.length; adjacent++) {
							var tempAdjID = territoryStateInfo[ter].adjacentTer[adjacent];
							if (territoryStateInfo[ter].type === 0 && (/*on own territory*/territoryStateInfo[ter].ownedByPlayer === playerNumber || /*occupied by friendly*/territoryStateInfo[ter].occupiedByPlayer === playerNumber || /*adjacent 	to occupied territory*/territoryStateInfo[tempAdjID].occupiedByPlayer === playerNumber) && $('#territoryArea' + ter).hasClass('viableTarget') === false) {
								$('#territoryArea' + ter).addClass('viableTarget');
								$('#territoryArea' + ter).click(
									(function(ter) {
										return function() {
                                            if (tempSelected === false) {
                                                tempSelected = true;
                                                playedCard = true;
                                                addToCardHistory(activeCard, playerNumber);
                                                applyNH(ter);
                                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                                for (var tempTer = 0; tempTer < territoryStateInfo.length; tempTer++) {
                                                    $('#territoryArea' + tempTer).removeClass('viableTarget');
                                                }
                                                refreshInteractibility();
                                            }
										};
									})(ter)
								);
								break;
							}
						}
					}
				}
				break;
			case 'First Aid':
				var viableUtilityTargets = [];
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					viableUtilityTargets.push([]);
					for (var unit = 0; unit < territoryStateInfo[ter].occupiedByUnits.length; unit++) {
						if (referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].mechanical !== 2 && referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].trainingTime === 0 && territoryStateInfo[ter].occupiedByPlayer === playerNumber && referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].currentHP < referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].maxHP) {
							viableUtilityTargets[ter].push(territoryStateInfo[ter].occupiedByUnits[unit]);
							if ($('#territoryArea' + ter).hasClass !== 'viableTarget') {
								$('#territoryArea' + ter).addClass('viableTarget');
								$('#territoryArea' + ter).click(
									(function(ter) {
										return function() {
                                            if (tempSelected === false) {
                                                tempSelected = true;
                                                playedCard = true;
                                                addToCardHistory(activeCard, playerNumber);
                                                applyUtility(viableUtilityTargets[ter]);
                                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                            }
										};
									})(ter)
								);
							}
						}
					}
				}
				break;
			case 'Infused Armor':
				var viableUtilityTargets = [];
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					viableUtilityTargets.push([]);
					for (var unit = 0; unit < territoryStateInfo[ter].occupiedByUnits.length; unit++) {
						if (referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].mechanical === 0 && referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].trainingTime === 0 && territoryStateInfo[ter].occupiedByPlayer === playerNumber) {
							var hasEffect = false;
							for (var effect = 0; effect < referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects.length; effect++) {
								if (referenceCards[referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects[effect]].name === 'Infused Armor') {
									hasEffect = true;
									break;
								}
							}
							if (hasEffect === true) {
								break;
							}
							viableUtilityTargets[ter].push(territoryStateInfo[ter].occupiedByUnits[unit]);
							if ($('#territoryArea' + ter).hasClass !== 'viableTarget') {
								$('#territoryArea' + ter).addClass('viableTarget');
								$('#territoryArea' + ter).click(
									(function(ter) {
										return function() {
                                            if (tempSelected === false) {
                                                tempSelected = true;
                                                playedCard = true;
                                                addToCardHistory(activeCard, playerNumber);
                                                applyUtility(viableUtilityTargets[ter]);
                                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                            }
										};
									})(ter)
								);
							}
						}
					}
				}
				break;
			case 'Lightning Storm':
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					var hasNH = false;
					for (var nh = 0; nh < territoryStateInfo[ter].naturalHazardIDs.length; nh++) {
						if (referenceCards[territoryStateInfo[ter].naturalHazardIDs[nh]].name === 'Lightning Storm') {
							hasNH = true;
						}
					}
					if (hasNH === true) {
						break;
					} else {
						for (var adjacent = 0; adjacent < territoryStateInfo[ter].adjacentTer.length; adjacent++) {
							var tempAdjID = territoryStateInfo[ter].adjacentTer[adjacent];
							if ((/*on own territory*/territoryStateInfo[ter].ownedByPlayer === playerNumber || /*occupied by friendly*/territoryStateInfo[ter].occupiedByPlayer === playerNumber || /*adjacent 	to occupied territory*/territoryStateInfo[tempAdjID].occupiedByPlayer === playerNumber) && $('#territoryArea' + ter).hasClass('viableTarget') === false) {
								$('#territoryArea' + ter).addClass('viableTarget');
								$('#territoryArea' + ter).click(
									(function(ter) {
										return function() {
                                            if (tempSelected === false) {
                                                tempSelected = true;
                                                playedCard = true;
                                                addToCardHistory(activeCard, playerNumber);
                                                applyNH(ter);
                                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                                for (var tempTer = 0; tempTer < territoryStateInfo.length; tempTer++) {
                                                    $('#territoryArea' + tempTer).removeClass('viableTarget');
                                                }
                                                refreshInteractibility();
                                            }
										};
									})(ter)
								);
								break;
							}
						}
					}
				}
				break;
			case 'Maelstrom':
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					var hasNH = false;
					for (var nh = 0; nh < territoryStateInfo[ter].naturalHazardIDs.length; nh++) {
						if (referenceCards[territoryStateInfo[ter].naturalHazardIDs[nh]].name === 'Maelstrom') {
							hasNH = true;
						}
					}
					if (hasNH === true) {
						break;
					} else {
						for (var adjacent = 0; adjacent < territoryStateInfo[ter].adjacentTer.length; adjacent++) {
							var tempAdjID = territoryStateInfo[ter].adjacentTer[adjacent];
							if (territoryStateInfo[ter].type === 1 && (/*on own territory*/territoryStateInfo[ter].ownedByPlayer === playerNumber || /*occupied by friendly*/territoryStateInfo[ter].occupiedByPlayer === playerNumber || /*adjacent 	to occupied territory*/territoryStateInfo[tempAdjID].occupiedByPlayer === playerNumber) && $('#territoryArea' + ter).hasClass('viableTarget') === false) {
								$('#territoryArea' + ter).addClass('viableTarget');
								$('#territoryArea' + ter).click(
									(function(ter) {
										return function() {
                                            if (tempSelected === false) {
                                                tempSelected = true;
                                                playedCard = true;
                                                addToCardHistory(activeCard, playerNumber);
                                                applyNH(ter);
                                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                                for (var tempTer = 0; tempTer < territoryStateInfo.length; tempTer++) {
                                                    $('#territoryArea' + tempTer).removeClass('viableTarget');
                                                }
                                                refreshInteractibility();
                                            }
										};
									})(ter)
								);
								break;
							}
						}
					}
				}
				break;
			case 'Mistral Trade Route':
                if (tempSelected === false) {
                    tempSelected = true;
                    playedCard = true;
                    addToCardHistory(activeCard, playerNumber);
                    // FUTURE FIX: check with every battle victory if this card is in player's active pile
                    $('#cardImage' + (altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1)).removeClass('selected');
                    altCardPiles[((playerNumber * 3) + 2)].push(activeCard);
                    // socket.emit('place mistral trade route', GRID, playerNumber, activeCard);
                    clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                }
			case 'Naval Ram':
				var viableUtilityTargets = [];
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					viableUtilityTargets.push([]);
					for (var unit = 0; unit < territoryStateInfo[ter].occupiedByUnits.length; unit++) {
						if (referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].type === 1 && referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].trainingTime === 0 && territoryStateInfo[ter].occupiedByPlayer === playerNumber) {
							var incompatibleEffect = false;
							for (var effect = 0; effect < referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects.length; effect++) {
								if (referenceCards[referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects[effect]].compatibilityGroup === 1) {
									incompatibleEffect = true;
									break;
								}
							}
							if (incompatibleEffect === true) {
								break;
							}
							viableUtilityTargets[ter].push(territoryStateInfo[ter].occupiedByUnits[unit]);
							if ($('#territoryArea' + ter).hasClass !== 'viableTarget') {
								$('#territoryArea' + ter).addClass('viableTarget');
								$('#territoryArea' + ter).click(
									(function(ter) {
										return function() {
                                            if (tempSelected === false) {
                                                tempSelected = true;
                                                playedCard = true;
                                                addToCardHistory(activeCard, playerNumber);
                                                applyUtility(viableUtilityTargets[ter]);
                                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                            }
										};
									})(ter)
								);
							}
						}
					}
				}
				break;
			case 'Perimeter Defenses':
				var viableUtilityTargets = [];
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					viableUtilityTargets.push([]);
					for (var unit = 0; unit < territoryStateInfo[ter].occupiedByUnits.length; unit++) {
						if ((referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].type === 3 || referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].type === 4) && referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].trainingTime === 0 && territoryStateInfo[ter].occupiedByPlayer === playerNumber) {
							var stack = 0;
							for (var effect = 0; effect < referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects.length; effect++) {
								if (referenceCards[referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects[effect]].name === 'Perimeter Defenses') {
									stack++;
								}
							}
							if (stack < 5) {
								viableUtilityTargets[ter].push(territoryStateInfo[ter].occupiedByUnits[unit]);
								if ($('#territoryArea' + ter).hasClass !== 'viableTarget') {
									$('#territoryArea' + ter).addClass('viableTarget');
									$('#territoryArea' + ter).click(
										(function(ter) {
											return function() {
                                                if (tempSelected === false) {
                                                    tempSelected = true;
                                                    playedCard = true;
                                                    addToCardHistory(activeCard, playerNumber);
                                                    applyUtility(viableUtilityTargets[ter]);
                                                    clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                                }
											};
										})(ter)
									);
								}
							}
						}
					}
				}
				break;
			case 'Prototype Weaponry':
				var viableUtilityTargets = [];
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					viableUtilityTargets.push([]);
					for (var unit = 0; unit < territoryStateInfo[ter].occupiedByUnits.length; unit++) {
						if ((referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].type !== 3 || referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].type !== 4) && referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].trainingTime === 0 && territoryStateInfo[ter].occupiedByPlayer === playerNumber) {
							var incompatibleEffect = false;
							for (var effect = 0; effect < referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects.length; effect++) {
								if (referenceCards[referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects[effect]].compatibilityGroup === 1) {
									incompatibleEffect = true;
									break;
								}
							}
							if (incompatibleEffect === true) {
								break;
							}
							viableUtilityTargets[ter].push(territoryStateInfo[ter].occupiedByUnits[unit]);
							if ($('#territoryArea' + ter).hasClass !== 'viableTarget') {
								$('#territoryArea' + ter).addClass('viableTarget');
								$('#territoryArea' + ter).click(
									(function(ter) {
										return function() {
                                            if (tempSelected === false) {
                                                tempSelected = true;
                                                playedCard = true;
                                                addToCardHistory(activeCard, playerNumber);
                                                applyUtility(viableUtilityTargets[ter]);
                                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                            }
										};
									})(ter)
								);
							}
						}
					}
				}
				break;
			case 'Reinforce Structure':
				var viableUtilityTargets = [];
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					viableUtilityTargets.push([]);
					for (var unit = 0; unit < territoryStateInfo[ter].occupiedByUnits.length; unit++) {
						if ((referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].type === 3 || referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].type === 4) && referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].trainingTime === 0 && territoryStateInfo[ter].occupiedByPlayer === playerNumber) {
							var stack = 0;
							for (var effect = 0; effect < referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects.length; effect++) {
								if (referenceCards[referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects[effect]].name === 'Reinforce Structure') {
									stack++;
								}
							}
							if (stack < 5) {
								viableUtilityTargets[ter].push(territoryStateInfo[ter].occupiedByUnits[unit]);
								if ($('#territoryArea' + ter).hasClass !== 'viableTarget') {
									$('#territoryArea' + ter).addClass('viableTarget');
									$('#territoryArea' + ter).click(
										(function(ter) {
											return function() {
                                                if (tempSelected === false) {
                                                    tempSelected = true;
                                                    playedCard = true;
                                                    addToCardHistory(activeCard, playerNumber);
                                                    applyUtility(viableUtilityTargets[ter]);
                                                    clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                                }
											};
										})(ter)
									);
								}
							}
						}
					}
				}
				break;
			case 'Resourceful Raider':
				for (var p = 1; p < 4; p++) {
					if (altCardPiles[((p * 3) + 3)].length > 0) {
						$('#p' + p + 'Area').click(
							(function(p) {
								return function() {
									if (tempSelected === false) {
                                        tempSelected = true;
										viableCards = [];
										targetPlayer = playerByPos[p-1];
										for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 3)].length; card++) {
											if (referenceCards[altCardPiles[((targetPlayer * 3) + 3)][card]].mechanical === 2) {
												viableCards.push(altCardPiles[((targetPlayer * 3) + 3)][card]);
											}
										}
										if (viableCards.length > 0) {
											playedCard = true;
											addToCardHistory(activeCard, playerNumber);
											// FUTURE FIX: highlight valid targets or grey out invalid targets to show where players have to click
											carouselCurrentIndex = 0;
											cardSource = 0;
											pickCard();
											showCardCarousel();
											clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
										}
									}
								};
							})(p)
						);
					}
				}
				if (altCardPiles[((playerNumber * 3) + 3)].length > 0) {
					$('#kingdomImage').click(function() {
						if (tempSelected === false) {
                            tempSelected = true;
							viableCards = [];
							targetPlayer = playerNumber;
							for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 3)].length; card++) {
								if (referenceCards[altCardPiles[((targetPlayer * 3) + 3)][card]].mechanical === 2) {
									viableCards.push(altCardPiles[((targetPlayer * 3) + 3)][card]);
								}
							}
							if (viableCards.length > 0) {
								playedCard = true;
								addToCardHistory(activeCard, playerNumber);
								carouselCurrentIndex = 0;
								cardSource = 0;
								pickCard();
								showCardCarousel();
								clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
							}
						}
					});
				}
				break;
			case 'Sandstorm':
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					var hasNH = false;
					for (var nh = 0; nh < territoryStateInfo[ter].naturalHazardIDs.length; nh++) {
						if (referenceCards[territoryStateInfo[ter].naturalHazardIDs[nh]].name === 'Sandstorm') {
							hasNH = true;
						}
					}
					if (hasNH === true) {
						break;
					} else {
						for (var adjacent = 0; adjacent < territoryStateInfo[ter].adjacentTer.length; adjacent++) {
							var tempAdjID = territoryStateInfo[ter].adjacentTer[adjacent];
							if (territoryStateInfo[ter].type === 0 && (/*on own territory*/territoryStateInfo[ter].ownedByPlayer === playerNumber || /*occupied by friendly*/territoryStateInfo[ter].occupiedByPlayer === playerNumber || /*adjacent 	to occupied territory*/territoryStateInfo[tempAdjID].occupiedByPlayer === playerNumber) && $('#territoryArea' + ter).hasClass('viableTarget') === false) {
								$('#territoryArea' + ter).addClass('viableTarget');
								$('#territoryArea' + ter).click(
									(function(ter) {
										return function() {
                                            if (tempSelected === false) {
                                                tempSelected = true;
                                                playedCard = true;
                                                addToCardHistory(activeCard, playerNumber);
                                                applyNH(ter);
                                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                                for (var tempTer = 0; tempTer < territoryStateInfo.length; tempTer++) {
                                                    $('#territoryArea' + tempTer).removeClass('viableTarget');
                                                }
                                                refreshInteractibility();
                                            }
										};
									})(ter)
								);
								break;
							}
						}
					}
				}
				break;
			case 'Schnee Dust Company':
                if (tempSelected === false) {
    				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
                        if (territoryStateInfo.occupiedByPlayer === playerNumber) {
        					for (var unit = 0; unit < territoryStateInfo[ter].occupiedByUnits.length; unit++) {
        						if (referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].mechanical !== 0) {
        							referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects.push(activeCard);
        							referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].attack = referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].attack + 5;
        						}
        					}
                        }
    				}
    				playedCard = true;
    				addToCardHistory(activeCard, playerNumber);
    				$('#cardImage' + (altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1)).removeClass('selected');
    				altCardPiles[((playerNumber * 3) + 2)].push(activeCard);
                    // socket.emit('place schnee dust company', GRID, playerNumber, activeCard);
    				clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                }
			case 'Silver Eyes':
				var viableUtilityTargets = [];
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					viableUtilityTargets.push([]);
					for (var unit = 0; unit < territoryStateInfo[ter].occupiedByUnits.length; unit++) {
						if (referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].mechanical !== 2 && referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].trainingTime === 0 && territoryStateInfo[ter].occupiedByPlayer === playerNumber) {
							var hasEffect = false;
							for (var effect = 0; effect < referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects.length; effect++) {
								if (referenceCards[referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects[effect]].name === 'Silver Eyes') {
									hasEffect = true;
									break;
								}
							}
							if (hasEffect === true) {
								break;
							}
							viableUtilityTargets[ter].push(territoryStateInfo[ter].occupiedByUnits[unit]);
							if ($('#territoryArea' + ter).hasClass !== 'viableTarget') {
								$('#territoryArea' + ter).addClass('viableTarget');
								$('#territoryArea' + ter).click(
									(function(ter) {
										return function() {
                                            if (tempSelected === false) {
                                                tempSelected = true;
                                                playedCard = true;
                                                addToCardHistory(activeCard, playerNumber);
                                                applyUtility(viableUtilityTargets[ter]);
                                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                            }
										};
									})(ter)
								);
							}
						}
					}
				}
				break;
			case 'Smugglers of Wind Path':
				if (lastPlayerVictory !== -1) {
					for (var p = 1; p < 4; p++) {
						// FUTURE FIX: highlight valid targets or grey out invalid targets to show where players have to click
						if (nOfCards[p] > 0) {
							$('#p' + p + 'Area').click(
								(function(p) {
									return function() {
										if (tempSelected === false) {
                                            tempSelected = false;
											playedCard = true;
											addToCardHistory(activeCard, playerNumber);
                                            // socket.emit('place smugglers of wind path', GRID, playerNumber, activeCard);
											drawRandomFromPlayer(playerByPos[p - 1], 1);
											clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
										}
									};
								})(p)
							);
						}
					}
				}
				break;
			case 'Thruster Packs':
				var viableUtilityTargets = [];
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					viableUtilityTargets.push([]);
					for (var unit = 0; unit < territoryStateInfo[ter].occupiedByUnits.length; unit++) {
						if (referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].mechanical !== 2 && referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].type === 0 && referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].size === 0 && referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].trainingTime === 0 && territoryStateInfo[ter].occupiedByPlayer === playerNumber) {
							var hasEffect = false;
							for (var effect = 0; effect < referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects.length; effect++) {
								if (referenceCards[referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects[effect]].name === 'Thruster Packs') {
									hasEffect = true;
									break;
								}
							}
							if (hasEffect === true) {
								break;
							}
							viableUtilityTargets[ter].push(territoryStateInfo[ter].occupiedByUnits[unit]);
							if ($('#territoryArea' + ter).hasClass !== 'viableTarget') {
								$('#territoryArea' + ter).addClass('viableTarget');
								$('#territoryArea' + ter).click(
									(function(ter) {
										return function() {
                                            if (tempSelected === false) {
                                                tempSelected = true;
                                                playedCard = true;
                                                addToCardHistory(activeCard, playerNumber);
                                                applyUtility(viableUtilityTargets[ter]);
                                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                            }
										};
									})(ter)
								);
							}
						}
					}
				}
				break;
			case 'Tornado':
				for (var ter = 0; ter < territoryStateInfo.length; ter++) {
					var hasNH = false;
					for (var nh = 0; nh < territoryStateInfo[ter].naturalHazardIDs.length; nh++) {
						if (referenceCards[territoryStateInfo[ter].naturalHazardIDs[nh]].name === 'Tornado') {
							hasNH = true;
							break;
						}
					}
					if (hasNH === true) {
						break;
					} else {
						for (var adjacent = 0; adjacent < territoryStateInfo[ter].adjacentTer.length; adjacent++) {
							var tempAdjID = territoryStateInfo[ter].adjacentTer[adjacent];
							if ((/*on own territory*/territoryStateInfo[ter].ownedByPlayer === playerNumber || /*occupied by friendly*/territoryStateInfo[ter].occupiedByPlayer === playerNumber || /*adjacent 	to occupied territory*/territoryStateInfo[tempAdjID].occupiedByPlayer === playerNumber) && $('#territoryArea' + ter).hasClass('viableTarget') === false) {
								$('#territoryArea' + ter).addClass('viableTarget');
								$('#territoryArea' + ter).click(
									(function(ter) {
										return function() {
                                            if (tempSelected === false) {
                                                tempSelected = true;
                                                playedCard = true;
                                                addToCardHistory(activeCard, playerNumber);
                                                applyNH(ter);
                                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
                                                for (var tempTer = 0; tempTer < territoryStateInfo.length; tempTer++) {
                                                    $('#territoryArea' + tempTer).removeClass('viableTarget');
                                                }
                                                refreshInteractibility();
                                            }
										};
									})(ter)
								);
								break;
							}
						}
					}
				}
				break;
		}
	}
    /*
	function createRadial(terID) {
		console.log('createRadial()');
		activeTer = terID;
		var outerDiv = document.createElement('div');
		outerDiv.id = 'outerRadial1';
		outerDiv.style.left = '0%';
		outerDiv.style.top = '-50%';
		document.getElementById('gameBoard').appendChild(outerDiv);
		$('#outerRadial1').addClass('outerRadial');
		var innerDiv = document.createElement('div');
		innerDiv.id = 'innerRadial1';
		document.getElementById('outerRadial1').appendChild(innerDiv);
		$('#innerRadial1').addClass('innerRadial');
		for (var items = 0; items < territoryStateInfo[terID].occupiedByUnits.length; items++) {
			var unitDiv = document.createElement('div');
			unitDiv.id = 'radialItem' + items;
			document.getElementById('innerRadial1').appendChild(unitDiv);
			unitDiv.innerHTML = 'vvv';
			$('#innerRadial1').addClass('radialItem');
		}
		document.getElementById('innerRadial1').classList.toggle('open');

		var units = document.querySelectorAll('.radialItem');
		for(var i = 0; i < units.length; i++) {
			units[i].style.left = (50 + 35*Math.sin(-0.5 * Math.PI - 2*(1/units.length)*i*Math.PI)).toFixed(4) + "%";
			units[i].style.top = (50 + 35*Math.sin(-0.5 * Math.PI - 2*(1/units.length)*i*Math.PI)).toFixed(4) + "%";
		}
		refreshInteractibility();
		// outerDiv.remove();
	}
	function removeRadial(terID) {
		console.log('removeRadial()');
		// document.getElementById('outerRadial1').remove();
		// $('#outerRadial1').remove();
	}
    */
	function showTerState(terID, thisTer) {
		console.log('showTerState()');
		$(thisTer).toggleClass('selected');
		/*removing all selections*/
			if (activeTer !== terID) {
				$('#territoryArea' + activeTer).removeClass('selected');
				activeTer = terID;
			} else {
				activeTer = -1;
			}
			activeUnits = [];
			document.getElementById('terGenInfo').innerHTML = '';
			document.getElementById('terUnitInfo').innerHTML = '';
			for (var i = 0; i < 50; i++) {
				if (document.getElementById('terUnitTooltip' + i) !== null) {
					document.getElementById('terUnitTooltip' + i).remove();
					break;
				}
			}
			for (var ter = 0; ter < territoryStateInfo.length; ter++) {
				$('#territoryArea' + ter).removeClass('viableMovement');
				$('#territoryArea' + ter).removeClass('viableLoadIn');
				$('#territoryArea' + ter).removeClass('viableAttackTarget');
                $('#territoryArea' + ter).removeClass('viableRangedTarget');
                $('#territoryArea' + ter).removeClass('passingThrough');
                $('#territoryArea' + ter).removeClass('attackPath');
			}
			$('#transporterList').remove();
		if (activeTer !== -1) {
			if (territoryStateInfo[terID].naturalHazardIDs.length > 0) {
				var tr = document.createElement('tr');
				var td = document.createElement('td');
				var textNode = document.createTextNode('textNode');
				var text = 'Natural Hazards:';
				for (var item = 0; item < territoryStateInfo[terID].naturalHazardIDs.length; item++) {
					text += '<BR>' + referenceCards[territoryStateInfo[terID].naturalHazardIDs[item]].name;
				}
				textNode.nodeValue = text;
				td.appendChild(textNode);
				tr.appendChild(td);
				document.getElementById('terGenInfo').appendChild(tr);
				document.getElementById('terGenInfo').style.borderBottom = '2px solid black';
			}
            var viableUnits = [];
            for (var unit = 0; unit < territoryStateInfo[terID].occupiedByUnits.length; unit++) {
                if (referenceCards[territoryStateInfo[terID].occupiedByUnits[unit]].name !== 'Wall') {
                    viableUnits.push(territoryStateInfo[terID].occupiedByUnits[unit]);
                }
            }
            for (var item = 0; item < viableUnits.length; item++) {
				var unitID = viableUnits[item];
				var tr = document.createElement('tr');
				var td = document.createElement('td');
				td.id = 'terUnitInfo' + item;
				var textNode = document.createTextNode('textNode');
				textNode.nodeValue = referenceCards[unitID].name;
				td.appendChild(textNode);
				tr.appendChild(td);
				document.getElementById('terUnitInfo').appendChild(tr);
				if (territoryStateInfo[terID].occupiedByPlayer === playerNumber) {
					$('#terUnitInfo' + item).click(
                        (function(item) {
                            return function() {
        						$(this).toggleClass('selected');
        						if (activeUnits.indexOf(unitID) === -1) {
        							activeUnits.push(unitID);
        						} else {
        							activeUnits.splice(activeUnits.indexOf(unitID), 1);
        							if (activeUnits.length === 0) {
        								for (var ter = 0; ter < territoryStateInfo.length; ter++) {
        									$('#territoryArea' + ter).removeClass('viableMovement');
        									$('#territoryArea' + ter).removeClass('viableLoadIn');
        									$('#territoryArea' + ter).removeClass('viableAttackTarget');
        									$('#territoryArea' + ter).removeClass('viableRangedTarget');
                                            $('#territoryArea' + ter).removeClass('passingThrough');
                                            $('#territoryArea' + ter).removeClass('attackPath');
        								}
        							}
        						}
                                console.log(activeUnits);
        						if (activeUnits.length > 0) {
        							unitMoveAttackVisuals();
        						}
                            };
                        })(item)
					);
                    /*$('#terUnitInfo' + item).click(function() {
                        $(this).toggleClass('selected');
                        if (activeUnits.indexOf(unitID) === -1) {
                            activeUnits.push(unitID);
                        } else {
                            activeUnits.splice(activeUnits.indexOf(unitID), 1);
                            if (activeUnits.length === 0) {
                                for (var ter = 0; ter < territoryStateInfo.length; ter++) {
                                    $('#territoryArea' + ter).removeClass('viableMovement');
                                    $('#territoryArea' + ter).removeClass('viableLoadIn');
                                    $('#territoryArea' + ter).removeClass('viableAttackTarget');
                                    $('#territoryArea' + ter).removeClass('viableRangedTarget');
                                    $('#territoryArea' + ter).removeClass('passingThrough');
                                    $('#territoryArea' + ter).removeClass('attackPath');
                                }
                            }
                        }
                        if (activeUnits.length > 0) {
                            unitMoveAttackVisuals();
                        }
                    });*/
				}
				// creating tooltip
				var tooltipContainer = document.createElement('div');
				tooltipContainer.id = 'terUnitTooltip' + item;
				var tooltipTable = document.createElement('table');
				/*TR*/
					var tooltipNameTR = document.createElement('tr');
					var tooltipCardTypeTR = document.createElement('tr');
					var tooltipAffiliationTR = document.createElement('tr');
					if (referenceCards[unitID].size !== 99) {
						var tooltipSizeTR = document.createElement('tr');
					}
					var tooltipTypeTR = document.createElement('tr');
					var tooltipMechanicalTR = document.createElement('tr');
					var tooltipHPTR = document.createElement('tr');
					if (referenceCards[unitID].attack !== 0) {
						var tooltipAttackTR = document.createElement('tr');
					}
					var tooltipSpeedTR = document.createElement('tr');
					if (referenceCards[unitID].trainingTime > 0) {
						var tooltipTrainingTimeTR = document.createElement('tr');
					}
				/*TD*/
					var tooltipNameTD = document.createElement('td');
					tooltipNameTD.style.borderBottom = '2px solid white';
					var tooltipCardTypeTD = document.createElement('td');
					var tooltipAffiliationTD = document.createElement('td');
					var tooltipSizeTD = document.createElement('td');
					var tooltipTypeTD = document.createElement('td');
					var tooltipMechanicalTD = document.createElement('td');
					var tooltipHPTD = document.createElement('td');
					var tooltipAttackTD = document.createElement('td');
					var tooltipSpeedTD = document.createElement('td');
					if (referenceCards[unitID].trainingTime > 0) {
						var tooltipTrainingTimeTD = document.createElement('td');
					}
				/*TextNode*/
					var tooltipNameText = document.createTextNode('textName');
					tooltipNameText.nodeValue = referenceCards[unitID].name;
					var tooltipCardTypeText = document.createTextNode('textCardType');
					switch (referenceCards[unitID].cardType) {
						case 0: tooltipCardTypeText.nodeValue = 'Unit'; break;
						case 1: tooltipCardTypeText.nodeValue = 'Trap'; break;
						case 2: tooltipCardTypeText.nodeValue = 'Utility'; break;
					}
					var tooltipAffiliationText = document.createTextNode('textAffiliation');
					switch (referenceCards[unitID].affiliation) {
						case 'None': tooltipAffiliationText.nodeValue = 'Affiliation: none'; break;
						case 'Mantle': tooltipAffiliationText.nodeValue = 'Affiliation: Mantle'; break;
						case 'Mistral': tooltipAffiliationText.nodeValue = 'Affiliation: Mistral'; break;
						case 'Vacuo': tooltipAffiliationText.nodeValue = 'Affiliation: Vacuo'; break;
						case 'Vale': tooltipAffiliationText.nodeValue = 'Affiliation: Vale'; break;
					}
					var tooltipSizeText = document.createTextNode('textSize');
					switch (referenceCards[unitID].size) {
						case 0: tooltipSizeText.nodeValue = 'Size: normal'; break;
						case 1: tooltipSizeText.nodeValue = 'Size: large'; break;
						case 2: tooltipSizeText.nodeValue = 'Size: huge'; break;
						case 3: tooltipSizeText.nodeValue = 'Size: colossal'; break;
					}
					var tooltipTypeText = document.createTextNode('textType');
					switch (referenceCards[unitID].type) {
						case 0: tooltipTypeText.nodeValue = 'Type: ground'; break;
						case 1: tooltipTypeText.nodeValue = 'Type: naval'; break;
						case 2: tooltipTypeText.nodeValue = 'Type: flying'; break;
						case 3: tooltipTypeText.nodeValue = 'Type: structure (ground)'; break;
						case 4: tooltipTypeText.nodeValue = 'Type: structure (naval)'; break;
						case 5: tooltipTypeText.nodeValue = 'Type: ground/naval'; break;
					}
					var tooltipMechanicalText = document.createTextNode('textMechanical');
					switch (referenceCards[unitID].mechanical) {
						case 0: tooltipMechanicalText.nodeValue = 'Non-mechanical'; break;
						case 1: tooltipMechanicalText.nodeValue = 'Half-mechanical'; break;
						case 2: tooltipMechanicalText.nodeValue = 'Full-mechanical'; break;
					}
					var tooltipHPText = document.createTextNode('textHP');
					// var referenceCards[unitID].currentHP = 1;
					tooltipHPText.nodeValue = 'HP: ' + referenceCards[unitID].currentHP.toString() + '/' + referenceCards[unitID].maxHP.toString();
					var tooltipAttackText = document.createTextNode('textAttack');
					tooltipAttackText.nodeValue = 'Attack: ' + referenceCards[unitID].attack.toString();
					var tooltipSpeedText = document.createTextNode('textSpeed');
					if (referenceCards[unitID].maxSpeed === 0) {
						tooltipSpeedText.nodeValue = 'Immobile';
					} else {
						tooltipSpeedText.nodeValue = 'Movement speed: ' + referenceCards[unitID].currentSpeed.toString() + '/' + referenceCards[unitID].maxSpeed.toString();
					}
					if (referenceCards[unitID].trainingTime > 0) {
					var tooltipTrainingTimeText = document.createTextNode('textTrainingTime');
						tooltipTrainingTimeText.nodeValue = 'Training time remaining: ' + referenceCards[unitID].trainingTime.toString();
					}
				/*appending everything*/
					tooltipNameTD.appendChild(tooltipNameText);
					tooltipNameTR.appendChild(tooltipNameTD);
					tooltipTable.appendChild(tooltipNameTR);
					tooltipCardTypeTD.appendChild(tooltipCardTypeText);
					tooltipCardTypeTR.appendChild(tooltipCardTypeTD);
					tooltipTable.appendChild(tooltipCardTypeTR);
					tooltipAffiliationTD.appendChild(tooltipAffiliationText);
					tooltipAffiliationTR.appendChild(tooltipAffiliationTD);
					tooltipTable.appendChild(tooltipAffiliationTR);
					if (referenceCards[unitID].size !== 99) {
						tooltipSizeTD.appendChild(tooltipSizeText);
						tooltipSizeTR.appendChild(tooltipSizeTD);
						tooltipTable.appendChild(tooltipSizeTR);
					}
					tooltipTypeTD.appendChild(tooltipTypeText);
					tooltipTypeTR.appendChild(tooltipTypeTD);
					tooltipTable.appendChild(tooltipTypeTR);
					tooltipMechanicalTD.appendChild(tooltipMechanicalText);
					tooltipMechanicalTR.appendChild(tooltipMechanicalTD);
					tooltipTable.appendChild(tooltipMechanicalTR);
					tooltipHPTD.appendChild(tooltipHPText);
					tooltipHPTR.appendChild(tooltipHPTD);
					tooltipTable.appendChild(tooltipHPTR);
					if (referenceCards[unitID].attack !== 0) {
						tooltipAttackTD.appendChild(tooltipAttackText);
						tooltipAttackTR.appendChild(tooltipAttackTD);
						tooltipTable.appendChild(tooltipAttackTR);
					}
					tooltipSpeedTD.appendChild(tooltipSpeedText);
					tooltipSpeedTR.appendChild(tooltipSpeedTD);
					tooltipTable.appendChild(tooltipSpeedTR);
					if (referenceCards[unitID].trainingTime > 0) {
						tooltipTrainingTimeTD.appendChild(tooltipTrainingTimeText);
						tooltipTrainingTimeTR.appendChild(tooltipTrainingTimeTD);
						tooltipTable.appendChild(tooltipTrainingTimeTR);
					}
					tooltipContainer.appendChild(tooltipTable);
				document.getElementById('gameInfo').appendChild(tooltipContainer);
				$('#terUnitTooltip' + item).addClass('tooltip');
				$('#terUnitInfo' + item).hover(function() {
					$('#terUnitTooltip' + item).toggleClass('showTooltip');
					// $('#terUnitTooltip' + item).toggle();
					// console.log(item);
					$(this).toggleClass('hoveredUnit');
				});
				// $('#terUnitTooltip' + item).hide();
				// console.log(item);
				/*$('#terUnitInfo' + item).hover(function(){
					// $('#terUnitTooltip' + item).toggleClass('showTooltip');
					$('#terUnitTooltip' + item - 1).toggle();
					console.log(item - 1);
				});*/
			}
		}
	}
    // FUTURE FIX: too many (and sometimes the wrong) terIDs are pushed to each pathToTer
	function unitMoveAttackVisuals() {
		console.log('unitMoveAttackVisuals()');
		var maxSpeed = 99;
		// var movementMethod = -1;
		movementMethods = [];
		// moveable/attackeable by: 0=ground, 1=naval, 2, flying
		var canMoveFrom = [1,1,1];
		var canAttackFrom = [1,1,1];
		var canMoveTo = [1,1,1];
		var canAttackTo = [1,1,1];
		for (var unit = 0; unit < activeUnits.length; unit++) {
			if (movementMethods.indexOf(referenceCards[activeUnits[unit]].type) === -1) {
				movementMethods.push(referenceCards[activeUnits[unit]].type);
			}
			if (referenceCards[activeUnits[unit]].currentSpeed < maxSpeed) {
				maxSpeed = referenceCards[activeUnits[unit]].currentSpeed;
			}
			if (referenceCards[activeUnits[unit]].hasOwnProperty('ranged')) {
				switch(hasRanged) {
					case -1: hasRanged = 2; break;
					case 0: hasRanged = 1; break;
					case 1: break;
					case 2: break;
				}
			} else {
				switch(hasRanged) {
					case -1: hasRanged = 0; break;
					case 0: break;
					case 1: break;
					case 2: hasRanged = 1; break;
				}
			}
			if (referenceCards[activeUnits[unit]].name === 'Wall') {
				canMoveFrom = [0,0,0];
				canAttackFrom = [0,0,0];
				canMoveTo = [0,0,0];
				canAttackTo = [0,0,0];
			}
			if (frostDustBombs.findIndex(x => x.unitID === activeUnits[unit]) !== -1 && frostDustBombs.findIndex(x => x.unitID === activeUnits[unit]) !== 0) {
				canMoveFrom = [0,0,0];
				canAttackFrom = [0,0,0];
				canMoveTo = [0,0,0];
				canAttackTo = [0,0,0];
			}
            if (rustingMists.findIndex(x => x.unitID === activeUnits[unit]) !== -1 && rustingMists.findIndex(x => x.unitID === activeUnits[unit]) !== 0) {
                canMoveFrom = [0,0,0];
                canAttackFrom = [0,0,0];
                canMoveTo = [0,0,0];
                canAttackTo = [0,0,0];
            }
            if (referenceCards[activeUnits[unit]].hasAttacked === true) {
                canAttackFrom = [0,0,0];
                canAttackTo = [0,0,0];
            }
		}
		for (var ter = 0; ter < territoryStateInfo.length; ter++) {
			$('#territoryArea' + ter).removeClass('viableMovement');
			$('#territoryArea' + ter).removeClass('viableLoadIn');
			$('#territoryArea' + ter).removeClass('viableAttackTarget');
            $('#territoryArea' + ter).removeClass('viableRangedTarget');
            $('#territoryArea' + ter).removeClass('passingThrough');
            $('#territoryArea' + ter).removeClass('attackPath');
			territoryStateInfo[ter].speedSpent = 99;
			territoryStateInfo[ter].pathToTer = [];
		}
		$('#transporterList').remove();
		var checkedTers = [activeTer];
		var oldCheckedTers = 0;
		var newCheckedTers = 0;
		console.log('maxSpeed: ' + maxSpeed);
		for (var speedI = 0; speedI < maxSpeed + 1; speedI++) {
            console.log('speedI: ' + speedI);
			newCheckedTers = checkedTers.length;
			// console.log('oldCheckedTers: ' + oldCheckedTers);
			// console.log('newCheckedTers: ' + newCheckedTers);
			for (var currentTer = oldCheckedTers; currentTer < newCheckedTers; currentTer++) {
				console.log('currentTer ' + currentTer + ': ' + checkedTers[currentTer]);
				// console.log(checkedTers);
				if (territoryStateInfo[currentTer].naturalHazardIDs.length > 0) {
					for (var hazard = 0; hazard < territoryStateInfo[currentTer].naturalHazardIDs.length; hazard++) {
						switch(referenceCards[territoryStateInfo[currentTer].naturalHazardIDs[hazard]].name) {
							case 'Earthquake':
								canMoveFrom[0] = 0;
								break;
							case 'Lightning Storm':
								canAttackFrom[2] = 0;
								canMoveFrom[2] = 0;
								break;
							case 'Maelstrom':
								canMoveFrom[1] = 0;
								canAttackFrom[1] = 0;
								break;
							case 'Sandstorm':
								canAttackFrom[0] = 0;
								canAttackFrom[2] = 0;
								canMoveFrom[0] = 0;
								canMoveFrom[2] = 0;
								break;
							case 'Tornado':
								canMoveFrom[0] = 0;
								canMoveFrom[1] = 0;
								canMoveFrom[2] = 0;
								break;
						}
					}
				}
				for (var adj = 0; adj < territoryStateInfo[checkedTers[currentTer]].adjacentTer.length; adj++) {
					// FUTURE FIX: all pathToTer's are added every time this is triggered, regardless of actual path
					var tempAdjID = territoryStateInfo[checkedTers[currentTer]].adjacentTer[adj];
					// console.log('%c tempAdj: ' + tempAdjID, 'background: green; color: white; display: block;');
					if (checkedTers.indexOf(tempAdjID) === -1/* || (checkedTers.indexOf(tempAdjID) !== -1 && (speedI + 1) < territoryStateInfo[tempAdjID].speedSpent)*/) {
                        for (var p = 0; p < forgedArmistice.length; p++) {
                            if (forgedArmistice[p].player === playerNumber && forgedArmistice[p].cannotAttack === territoryStateInfo[tempAdjID].occupiedByPlayer) {
                                canAttackFrom = [0,0,0];
                                canAttackTo = [0,0,0];
                                break;
                            }
                        }
						switch(territoryStateInfo[tempAdjID].type) {
							case 0: /*ground*/
								if (territoryStateInfo[tempAdjID].naturalHazardIDs.length > 0) {
									for (var hazard = 0; hazard < territoryStateInfo[tempAdjID].naturalHazardIDs.length; hazard++) {
										switch(referenceCards[territoryStateInfo[tempAdjID].naturalHazardIDs[hazard]].name) {
											case 'Earthquake':
												canMoveTo[0] = 0;
												break;
											case 'Lightning Storm':
												canMoveTo[2] = 0;
												canAttackTo[2] = 0;
												break;
											case 'Sandstorm':
												canMoveTo[0] = 0;
												canMoveTo[2] = 0;
												canAttackTo[0] = 0;
												canAttackTo[2] = 0;
												break;
											case 'Tornado':
												canMoveTo[0] = 0;
												canMoveTo[2] = 0;
												break;
										}
									}
								}
								if (territoryStateInfo[tempAdjID].occupiedByPlayer === -1 || territoryStateInfo[tempAdjID].occupiedByPlayer === playerNumber) {
									// console.log('ter ' + tempAdjID + ' occupied by p' + territoryStateInfo[tempAdjID].occupiedByPlayer);
									// console.log(movementMethods);
									// console.log(movementMethods.indexOf(1));
									if ((movementMethods.indexOf(0) === -1 || (canMoveTo[0] === 1 && canMoveFrom[0] === 1)) && movementMethods.indexOf(1) === -1 && (movementMethods.indexOf(2) === -1 || (canMoveTo[2] === 1 && canMoveFrom[2] === 1)) && movementMethods.indexOf(3) === -1 && movementMethods.indexOf(4) === -1 && (movementMethods.indexOf(5) === -1 || (canMoveTo[0] === 1 && canMoveFrom[0] === 1 && canMoveTo[1] === 1 && canMoveFrom[1] === 1)) && speedI < maxSpeed/* && $('#territoryArea' + tempAdjID).hasClass('viableMovement') === false*/) {
										console.log('checking moveable land ter ' + tempAdjID);
										$('#territoryArea' + tempAdjID).addClass('viableMovement');
										checkedTers.push(tempAdjID);
										territoryStateInfo[tempAdjID].speedSpent = speedI + 1;
										territoryStateInfo[tempAdjID].pathToTer = territoryStateInfo[checkedTers[currentTer]].pathToTer;
										territoryStateInfo[tempAdjID].pathToTer.push(checkedTers[currentTer]);
										// FUTURE FIX: how can 33 and 35 both be in checkedTers after only 1 iteration added a ter to checkedTers?
										// console.log(checkedTers);
										// console.log(tempAdjID);
										console.log(territoryStateInfo[tempAdjID].pathToTer);
									}
								} else {
									if ((movementMethods.indexOf(0) === -1 || (canAttackTo[0] === 1 && canAttackFrom[0] === 1)) && (movementMethods.indexOf(1) === -1 || (canAttackTo[1] === 1 && canAttackFrom[1] === 1)) && (movementMethods.indexOf(2) === -1 || (canAttackTo[2] === 1 && canAttackFrom[2] === 1)) && (movementMethods.indexOf(3) === -1 || (canAttackTo[0] === 1 && canAttackFrom[0] === 1)) && (movementMethods.indexOf(4) === -1 || (canAttackTo[1] === 1 && canAttackFrom[1] === 1)) && (movementMethods.indexOf(5) === -1 || (canAttackTo[0] === 1 && canAttackFrom[0] === 1 && canAttackTo[1] === 1 && canAttackFrom[1] === 1))) {
                                        console.log('checking attackable land ter ' + tempAdjID);
										$('#territoryArea' + tempAdjID).addClass('viableAttackTarget');
										territoryStateInfo[tempAdjID].speedSpent = speedI;
										territoryStateInfo[tempAdjID].pathToTer = territoryStateInfo[checkedTers[currentTer]].pathToTer;
										territoryStateInfo[tempAdjID].pathToTer.push(checkedTers[currentTer]);
										if (movementMethods.indexOf(0) === -1 && movementMethods.indexOf(1) === -1 && movementMethods.indexOf(2) !== -1 && movementMethods.indexOf(3) === -1 && movementMethods.indexOf(4) === -1 && movementMethods.indexOf(5) === -1) {
											checkedTers.push(tempAdjID);
										}
										// console.log(checkedTers[currentTer]);
										// console.log(territoryStateInfo[tempAdjID].pathToTer);
									}
								}
								break;
							case 1: /*naval*/
								if (territoryStateInfo[tempAdjID].naturalHazardIDs.length > 0) {
									for (var hazard = 0; hazard < territoryStateInfo[tempAdjID].naturalHazardIDs.length; hazard++) {
										switch(referenceCards[territoryStateInfo[tempAdjID].naturalHazardIDs[hazard]].name) {
											case 'Lightning Storm':
												canMoveTo[2] = 0;
												canAttackTo[2] = 0;
												break;
											case 'Maelstrom':
												canMoveTo[0] = 0;
												canMoveTo[1] = 0;
												canAttackTo[1] = 0;
												break;
											case 'Tornado':
												canMoveTo[0] = 0;
												canMoveTo[1] = 0;
												canMoveTo[2] = 0;
												break;
										}
									}
								}
								if (territoryStateInfo[tempAdjID].occupiedByPlayer === -1 || territoryStateInfo[tempAdjID].occupiedByPlayer === playerNumber) {
									// console.log('ter ' + tempAdjID + ' occupied by p' + territoryStateInfo[tempAdjID].occupiedByPlayer);
									// console.log('movementMethods:');
									// console.log(movementMethods);
									// console.log(movementMethods.indexOf(1));
									if ((movementMethods.indexOf(0) === -1 || (canMoveTo[0] === 1 && canMoveFrom[0] === 1)) && (movementMethods.indexOf(1) === -1 || (canMoveTo[1] === 1 && canMoveFrom[1] === 1)) && (movementMethods.indexOf(2) === -1 || (canMoveTo[2] === 1 && canMoveFrom[2] === 1)) && movementMethods.indexOf(3) === -1 && movementMethods.indexOf(4) === -1 && (movementMethods.indexOf(5) === -1 || (canMoveTo[0] === 1 && canMoveFrom[0] === 1 && canMoveTo[1] === 1 && canMoveFrom[1] === 1)) && speedI < maxSpeed) {
										if (movementMethods.indexOf(0) !== -1) {
											for (var tranporter = 0; tranporter < territoryStateInfo[tempAdjID].occupiedByUnits.length; tranporter++) {
												if (referenceCards[territoryStateInfo[tempAdjID].occupiedByUnits[tranporter]].hasOwnProperty('transportSize')) {
                                                    console.log('checking transportable naval ter ' + tempAdjID);
													$('#territoryArea' + tempAdjID).addClass('viableLoadIn');
													checkedTers.push(tempAdjID);
													territoryStateInfo[tempAdjID].speedSpent = speedI + 1;
													territoryStateInfo[tempAdjID].pathToTer = territoryStateInfo[checkedTers[currentTer]].pathToTer;
													territoryStateInfo[tempAdjID].pathToTer.push(checkedTers[currentTer]);
													// console.log('pushed pathToTer 1');
													break;
												}
											}
										} else {
                                            console.log('checking moveable naval ter ' + tempAdjID);
											$('#territoryArea' + tempAdjID).addClass('viableMovement');
											checkedTers.push(tempAdjID);
											territoryStateInfo[tempAdjID].speedSpent = speedI + 1;
											territoryStateInfo[tempAdjID].pathToTer = territoryStateInfo[checkedTers[currentTer]].pathToTer;
											// console.log(tempAdjID);
											// console.log(territoryStateInfo[checkedTers[currentTer]].pathToTer)
											territoryStateInfo[tempAdjID].pathToTer.push(checkedTers[currentTer]);
											// console.log('pushed ' + checkedTers[currentTer] + ' to ' + tempAdjID + '.pathToTer');
										}
									}
								} else {
									if ((movementMethods.indexOf(0) === -1 || (canAttackTo[0] === 1 && canAttackFrom[0] === 1)) && (movementMethods.indexOf(1) === -1 || (canAttackTo[1] === 1 && canAttackFrom[1] === 1)) && (movementMethods.indexOf(2) === -1 || (canAttackTo[2] === 1 && canAttackFrom[2] === 1)) && (movementMethods.indexOf(3) === -1 || (canAttackTo[0] === 1 && canAttackFrom[0] === 1)) && (movementMethods.indexOf(4) === -1 || (canAttackTo[1] === 1 && canAttackFrom[1] === 1)) && (movementMethods.indexOf(5) === -1 || (canAttackTo[0] === 1 && canAttackFrom[0] === 1 && canAttackTo[1] === 1 && canAttackFrom[1] === 1))) {
                                        console.log('checking attackable naval ter ' + tempAdjID);
										$('#territoryArea' + tempAdjID).addClass('viableAttackTarget');
										territoryStateInfo[tempAdjID].speedSpent = speedI;
										territoryStateInfo[tempAdjID].pathToTer = territoryStateInfo[checkedTers[currentTer]].pathToTer;
										territoryStateInfo[tempAdjID].pathToTer.push(checkedTers[currentTer]);
										// console.log('pushed pathToTer 3');
										if (movementMethods.indexOf(0) === -1 && movementMethods.indexOf(1) === -1 && movementMethods.indexOf(2) !== -1 && movementMethods.indexOf(3) === -1 && movementMethods.indexOf(4) === -1 && movementMethods.indexOf(5) === -1) {
											checkedTers.push(tempAdjID);
										}
									}
								}
								break;
						}
					}
				}
			}
			oldCheckedTers = newCheckedTers;
		}
		refreshInteractibility();
	}
	function moveToTer(targetTerID) {
		console.log('movetoter()');
        // socket.emit('move to ter', GRID, playerNumber, activeUnits, activeTer, targetTerID);
		var tempX1 = 3840 / 100 * territoryShapeInfo[activeTer][(territoryShapeInfo[activeTer].length - 1)][0][0].x;
		var tempY1 = 2160 / 100 * territoryShapeInfo[activeTer][(territoryShapeInfo[activeTer].length - 1)][0][0].y;
		var tempX2 = 3840 / 100 * territoryShapeInfo[targetTerID][(territoryShapeInfo[targetTerID].length - 1)][0][0].x;
		var tempY2 = 2160 / 100 * territoryShapeInfo[targetTerID][(territoryShapeInfo[targetTerID].length - 1)][0][0].y;
		moveArrowSVG.setAttribute("x1", tempX1);
		moveArrowSVG.setAttribute("y1", tempY1);
		moveArrowSVG.setAttribute("x2", tempX2);
		moveArrowSVG.setAttribute("y2", tempY2);
		moveArrowSVG.style.visibility = 'visible';
		setTimeout(function() {
			// FUTURE FIX: adjust to make useable for all players after sent through socket.io?
            // ^ probably not, since this function also contains the socket emit
			/*var tempX = 3840 / 100 * territoryShapeInfo[targetTerID][(territoryShapeInfo[targetTerID].length - 1)].x
			var tempY = 2160 / 100 * territoryShapeInfo[targetTerID][(territoryShapeInfo[targetTerID].length - 1)].y
			if (territoryStateInfo[targetTerID].occupiedByUnits.length === 0) {
				var circle = document.createElementNS('http:// www.w3.org/2000/svg','circle');
				circle.setAttributeNS(null, "cx", tempX);
				circle.setAttributeNS(null, "cy", tempY);
				circle.setAttributeNS(null, "r", 2160 / 100 * 2);
				circle.setAttributeNS(null, "stroke", 'black');
				circle.setAttributeNS(null, "stroke-width", 3);
				circle.setAttributeNS(null, "fill", kingdomColorArray[playerNumber]);
				circle.id = 'unitCircleTer' + targetTerID;
				document.getElementById('gameBoardSVG').appendChild(circle);
				document.getElementById('unitCircleTer' + targetTerID).classList.add('territoryCircle');
				document.getElementById('unitCircleTer' + targetTerID).classList.add('territoryArea');
				var text = document.createElementNS('http:// www.w3.org/2000/svg','text');
				text.setAttributeNS(null, "x", tempX);
				text.setAttributeNS(null, "y", tempY + 5);
				text.setAttributeNS(null, "font-size", '350%');
				text.setAttributeNS(null, "alignment-baseline", 'middle');
				text.setAttributeNS(null, "text-anchor", 'middle');
				text.setAttributeNS(null, "font-family", 'arial');
				text.id = 'unitNumbersTer' + targetTerID;
				document.getElementById('gameBoardSVG').appendChild(text);
				document.getElementById('unitNumbersTer' + targetTerID).classList.add('territoryText');
				document.getElementById('unitNumbersTer' + targetTerID).classList.add('territoryArea');
				territoryStateInfo[targetTerID].ownedByPlayer = playerNumber;
				territoryStateInfo[targetTerID].occupiedByPlayer = playerNumber;
			}*/
			for (var tempActiveUnit = 0; tempActiveUnit < activeUnits.length; tempActiveUnit++) {
				territoryStateInfo[targetTerID].occupiedByUnits.push(activeUnits[tempActiveUnit]);
				territoryStateInfo[activeTer].occupiedByUnits.splice(territoryStateInfo[activeTer].occupiedByUnits.indexOf(activeUnits[tempActiveUnit]), 1);
				referenceCards[activeUnits[tempActiveUnit]].currentSpeed = referenceCards[activeUnits[tempActiveUnit]].currentSpeed - territoryStateInfo[targetTerID].speedSpent;
			}
			// d3.select('#unitNumbersTer' + targetTerID).text(territoryStateInfo[targetTerID].occupiedByUnits.length.toString());
			/*if (territoryStateInfo[activeTer].occupiedByUnits.length === 0) {
				$('#unitCircleTer' + activeTer).remove();
				$('#unitNumbersTer' + activeTer).remove();
			} else {
				d3.select('#unitNumbersTer' + activeTer).text(territoryStateInfo[activeTer].occupiedByUnits.length.toString());
			}*/
			territoryStateInfo[targetTerID].occupiedByPlayer = playerNumber;
			for (var continent = 0; continent < continentArray.length; continent++) {
				if (targetTerID === continentArray[continent].capital && territoryStateInfo[targetTerID].occupiedByPlayer !== territoryStateInfo[targetTerID].ownedByPlayer) {
                    socket.emit('capital taken over', playerNumber, territoryStateInfo[targetTerID].ownedByPlayer, targetTerID);
					for (var ter = continentArray[continent].start; ter <= continentArray[continent].end; ter++) {
						territoryStateInfo[ter].ownedByPlayer = playerNumber;
					}
					nOfCapitals++;
				}
			}
			refreshTerStateVisuals(targetTerID);
			refreshTerStateVisuals(activeTer);
			// clearing selections
			for (var item = 0; item < territoryStateInfo[activeTer].occupiedByUnits.length; item++) {
				$('#terUnitInfo' + item).remove();
				document.getElementById('terUnitTooltip' + item).remove();
			}
			for (var ter = 0; ter < territoryShapeInfo.length; ter++) {
				$('#territoryArea' + ter).removeClass('viableMovement');
				$('#territoryArea' + ter).removeClass('viableAttackTarget');
				$('#territoryArea' + ter).removeClass('viableRangedTarget');
                $('#territoryArea' + ter).removeClass('passingThrough');
                $('#territoryArea' + ter).removeClass('attackPath');
				$('#territoryArea' + ter).removeClass('viableLoadIn');
				$('#territoryArea' + activeTer).removeClass('selected');
				territoryStateInfo[ter].speedSpent = 99;
			}
			activeTer = -1;
			activeUnits = [];
			refreshInteractibility();
            setTimeout(function() {
                moveArrowSVG.style.visibility = 'hidden';
            }, 500);
		}, 1000);
	}
	function loadInTransport(tempAdjID) {
		console.log('loadInTransport()');
        var viableLoadUnits = [];
        var minRequiredSlots = 99;
        for (var active = 0; active < activeUnits.length; active++) {
            if (referenceCards[activeUnits[active]].type === 0) {
                viableLoadUnits.push(activeUnits[active]);
                if (referenceCards[activeUnits[active]].size < minRequiredSlots) {
                    minRequiredSlots = referenceCards[activeUnits[active]].size;
                }
            }
        }
        var viableTransport = [];
        for (var tranporter = 0; tranporter < territoryStateInfo[tempAdjID].occupiedByUnits.length; tranporter++) {
            if (referenceCards[territoryStateInfo[tempAdjID].occupiedByUnits[tranporter]].hasOwnProperty('transportSize') && referenceCards[territoryStateInfo[tempAdjID].occupiedByUnits[tranporter]].transportMaxSpots - referenceCards[territoryStateInfo[tempAdjID].occupiedByUnits[tranporter]].transportFilledSlots >= minRequiredSlots) {
                viableTransport.push(territoryStateInfo[tempAdjID].occupiedByUnits[tranporter]);
            }
        }
		if (viableTransport.length > 0) {
            refreshTransportManager(viableTransport, viableLoadUnits, viableLoadUnits);
        }

        /*
        var tempRequiredSpots = 0;
        var tempRequiredSize = 0;
        for (var active = 0; active < activeUnits.length; active++) {
            if (referenceCards[activeUnits[active]].type === 0) {
                tempRequiredSpots = tempRequiredSpots + sizeMultipliers[referenceCards[activeUnits[active]].size];
                if (tempRequiredSize < referenceCards[activeUnits[active]].size) {
                    tempRequiredSize = referenceCards[activeUnits[active]].size;
                }
            }
        }
        var viableTransport = [];
        for (var tranporter = 0; tranporter < territoryStateInfo[tempAdjID].occupiedByUnits.length; tranporter++) {
            if (referenceCards[territoryStateInfo[tempAdjID].occupiedByUnits[tranporter]].hasOwnProperty('transportSize')) {
                if (referenceCards[territoryStateInfo[tempAdjID].occupiedByUnits[tranporter]].transportSize >= tempRequiredSize && referenceCards[territoryStateInfo[tempAdjID].occupiedByUnits[tranporter]].transportFilledSlots >= tempRequiredSpots) {
                    viableTransport.push(territoryStateInfo[tempAdjID].occupiedByUnits[tranporter];
                }
            }
        }
			// creating window with list of all transporters and eligible units to load into them
            // TO DO (optional): create window in html, add show/hide functions, keep content generation here
			var transporterListContainer = document.createElement('div');
			transporterListContainer.id = 'transporterList';
			var transporterListTable = document.createElement('table');
			transporterListTable.id = 'transporterTable';
			for (var tp = 0; tp < viableTransport.length; tp++) {
				var tranporterTR = document.createElement('tr');
				var tranporterTD = document.createElement('td');
				var tranporterText = document.createTextNode('textName');
				tranporterText.nodeValue = referenceCards[viableTransport[tp]].name;
				tranporterTD.appendChild(tranporterText);
				tranporterTR.appendChild(tranporterTD);
				var tranporterLoadTD = document.createElement('td');
				var tranporterLoadText = document.createTextNode('textName');
				tranporterLoadText.nodeValue = referenceCards[viableTransport[tp]].transportFilledSlots + '/' + referenceCards[viableTransport[tp]].transportMaxSpots;
				tranporterLoadTD.appendChild(tranporterLoadText);
				tranporterTR.appendChild(tranporterLoadTD);
				// document.getElementById('transportManagerTable').appendChild(tranporterTR);
			}
			transporterListContainer.appendChild(transporterListTable);
			var unitListTable = document.createElement('table');
			unitListTable.id = 'unitTable';
			for (var active = 0; active < activeUnits.length; active++) {
				if (referenceCards[activeUnits[active]].type === 0) {
					var unitTR = document.createElement('tr');
					var unitTD = document.createElement('td');
					var unitText = document.createTextNode('textName');
					unitText.nodeValue = referenceCards[activeUnits[active]].name + ' (' + sizeMultipliers[referenceCards[activeUnits[active]].size] + ')';
					unitTD.appendChild(unitText);
					unitTR.appendChild(unitTD);
					unitListTable.appendChild(unitTR);
				}
			}
			transporterListContainer.appendChild(unitListTable);
			var currentLoadText = document.createTextNode('textName');
			currentLoadText.id = 'currentLoadText';
			currentLoadText.nodeValue = 'Selected load: 0';
			transporterListContainer.appendChild(currentLoadText);
			document.getElementById('gameInfo').appendChild(transporterListContainer);

            // optional code to have window be placed near the target territory (perhaps just keep it simple instead?)
			/*var tempXperc = territoryShapeInfo[tempAdjID][(territoryShapeInfo[tempAdjID].length - 1)].x - 11;
			if (territoryShapeInfo[tempAdjID][(territoryShapeInfo[tempAdjID].length - 1)].x <= 11) {
				tempXperc = tempXperc + 22;
			}
			document.getElementById('tranporterList').style.left = 3840 / 100 * tempXperc;
			var tempYperc = territoryShapeInfo[tempAdjID][(territoryShapeInfo[tempAdjID].length - 1)].y - ($('#transporterList').height() + 2);
			if (territoryShapeInfo[tempAdjID][(territoryShapeInfo[tempAdjID].length - 1)].x <= ($('#transporterList').height() + 2)) {
				tempYperc = tempYperc + (($('#transporterList').height() + 2) * 2);
			}
			document.getElementById('tranporterList').style.top = 3840 / 100 * tempYperc;
			// maybe add code to highlight on hover

			// maybe 'drag/drop' units to the slots each transporter has?
		}
        */

		// alternative mass-loading code
			/*var tempRequiredSize = [0,0,0];
			for (var active = 0; active < activeUnits.length; active++) {
				if (referenceCards[activeUnits[active]].type === 0) {
					tempRequiredSize[referenceCards[activeUnits[active]].size]++;
				}
			}
			var tempTransportIDs = [];
			var tempTransportMaxSizes = [];
			var tempTransportSpots = [];
			for (var tranporter = 0; tranporter < territoryStateInfo[tempAdjID].occupiedByUnits.length; tranporter++) {
				if (referenceCards[territoryStateInfo[tempAdjID].occupiedByUnits[tranporter]].hasOwnProperty('transportSize')) {
					tempTransportIDs.push(territoryStateInfo[tempAdjID].occupiedByUnits[tranporter]);
					tempTransportMaxSizes.push(referenceCards[territoryStateInfo[tempAdjID].occupiedByUnits[tranporter]].transportSize);
					// check for spots already in use
					tempTransportSpots.push(referenceCards[territoryStateInfo[tempAdjID].occupiedByUnits[tranporter]].transportFilledSlots);
				}
			}
			// subtract huge/large/normal units from transport spots
			for (var hugeUnits = 0; hugeUnits < tempRequiredSize[2]; hugeUnits++) {
				
			}*/
	}
    function refreshTransportManager(viableTransport, allLoadUnits, remainingLoadUnits) {
        // TO DO (and test): modify css for proper visualization
        $("#transportAndButtonTable tr").remove();
        $("#activeUnitsTable tr").remove();
        // left column: list of transporters and units they carry
        for (var tp = 0; tp < viableTransport.length; tp++) {
            console.log(viableTransport[tp]);
            // FUTUE FIX: why is the card id number recognized, but its referenceCards entry isnt?
            console.log(referenceCards[viableTransport[tp]].name);
            var tempTransportingUnitsArray = referenceCards[viableTransport[tp]].transportingUnits;
            var transporterTR = document.createElement('tr');
            // transporterTR.colSpan = 2;
            var transporterTD = document.createElement('td');
            transporterTD.className += 'transporterTD';
            var transporterText = document.createTextNode('textName');
            transporterText.nodeValue = referenceCards[viableTransport[tp]].name + ' (' + referenceCards[viableTransport[tp]].transportFilledSlots + '/' + referenceCards[viableTransport[tp]].transportMaxSpots + ')';
            transporterTD.appendChild(transporterText);
            transporterTR.appendChild(transporterTD);
            document.getElementById('transportAndButtonTable').appendChild(transporterTR);
            // center column: buttons the size of the transport+transported units rows to transfer units in and out (only activeUnits can be moved back out)
            // create button before adding units due to onclick function
            var transporterButtonTD = document.createElement('td');
            transporterButtonTD.className += 'transporterTD';
            var transporterButton = document.createElement('button');
            transporterButton.className += 'transporterButton';
            transporterButton.id = 'transporterButton' + tp;
            transporterButton.innerHTML = '<-->';
            transporterButton.disabled = true;
            transporterButtonTD.rowSpan = tempTransportingUnitsArray.length + 1;
            transporterButtonTD.appendChild(transporterButton);
            transporterTR.appendChild(transporterButtonTD);
            for (var unit = 0; unit < tempTransportingUnitsArray.length; unit++) {
                var unitTR = document.createElement('tr');
                var blankTD = document.createElement('td');
                blankTD.className += 'blankTransportTD';
                var unitTD = document.createElement('td');
                unitTD.className += 'unitTransportTD';
                unitTD.id = 'boardedUnitTD' + unit;
                if (allLoadUnits.indexOf(tempTransportingUnitsArray[unit]) === -1) {
                    // this unit was already in here and will not be manipulable
                    unitTD.className += 'unmovableUnitTransportTD';
                } else {
                    // this unit has been loaded in now and will be manipulable
                    // unitTD.className += 'movableUnitTransportTD';
                    $('#unitTransportTD' + unit).hover(
                        function() {
                            $(this).toggleClass('hoveredTD');
                        }
                    );
                    $('#unitTransportTD' + unit).click(
                        (function(item) {
                            return function() {
                                if ($('#boardedUnitTD' + unit).hasClass('selected') === true) {
                                    $('#boardedUnitTD' + unit).removeClass('selected');
                                    transporterButton.innerHTML = '<-->';
                                    transporterButton.disabled = true;
                                } else {
                                    for (var i = 0; i < tempTransportingUnitsArray.length; i++) {
                                        $('#boardedUnitTD' + i).removeClass('selected');
                                    }
                                    $('#boardedUnitTD' + unit).addClass('selected');
                                    transporterButton.innerHTML = '->';
                                    transporterButton.disabled = false;
                                    transporterButton.onclick = function() {
                                        remainingLoadUnits.push(tempTransportingUnitsArray[unit]);
                                        referenceCards[viableTransport[tp]].transportingUnits.splice(tempTransportingUnitsArray.indexOf(tempTransportingUnitsArray[unit]), 1);
                                        refreshTransportManager(viableTransport, allLoadUnits, remainingLoadUnits);
                                    }
                                }
                            };
                        })(unit)
                    );
                }
                var unitText = document.createTextNode('textName');
                unitText.nodeValue = tempTransportingUnitsArray[unit].name;
                unitTD.appendChild(unitText);
                unitTR.appendChild(blankTD);
                unitTR.appendChild(unitTD);
                document.getElementById('transportAndButtonTable').appendChild(unitTR);
            }
        }
        // right column: all activeUnits that can be loaded in
        for (var unit = 0; unit < remainingLoadUnits.length; unit++) {
            var unitTR = document.createElement('tr');
            var unitTD = document.createElement('td');
            unitTD.className += 'unitTD';
            unitTD.id = 'boardingUnitTD' + unit;
            var unitText = document.createTextNode('textName');
            unitText.nodeValue = referenceCards[remainingLoadUnits[unit]].name;
            $('#boardingUnitTD' + unit).hover(
                function() {
                    $(this).toggleClass('hoveredTD');
                }
            );
            $('#boardingUnitTD' + unit).click(
                (function(item) {
                    return function() {
                        if ($('#boardingUnitTD' + unit).hasClass('selected') === true) {
                            $('#boardingUnitTD' + unit).removeClass('selected');
                            for (var tp = 0; tp < viableTransport.length; tp++) {
                                document.getElementById('transporterButton' + tp).innerHTML = '<-->';
                                document.getElementById('transporterButton' + tp).disabled = true;
                            }
                        } else {
                            for (var i = 0; i < remainingLoadUnits.length; i++) {
                                $('#boardingUnitTD' + i).removeClass('selected');
                            }
                            $('#boardingUnitTD' + unit).addClass('selected');
                            for (var tp = 0; tp < viableTransport.length; tp++) {
                                document.getElementById('transporterButton' + tp).innerHTML = '<-';
                                document.getElementById('transporterButton' + tp).disabled = false;
                                document.getElementById('transporterButton' + tp).onclick = (function(tp) {
                                    return function() {
                                        referenceCards[viableTransport[tp]].transportingUnits.push(remainingLoadUnits[unit]);
                                        remainingLoadUnits.splice(remainingLoadUnits.indexOf(remainingLoadUnits[unit]), 1);
                                        refreshTransportManager(viableTransport, allLoadUnits, remainingLoadUnits);
                                    };
                                })(tp)
                            }
                        }
                    };
                })(unit)
            );
            unitTD.appendChild(unitText);
            unitTR.appendChild(unitTD);
            document.getElementById('activeUnitsTable').appendChild(unitTR);
        }
    }

    // order of attack functions: selectPriorityTargets, selectTrap (x2), activateTrap, attackTer
	function selectPriorityTargets(targetTerID) {
		console.log('selectPriorityTargets()');
		viableTargets = [];
		for (var unit = 0; unit < territoryStateInfo[targetTerID].occupiedByUnits.length; unit++) {
			var r1 = document.getElementById('priorityTargetsTable').insertRow(unit);
			r1.onclick = function() {
				if (viableTargets.indexOf(territoryStateInfo[targetTerID].occupiedByUnits[this.rowIndex]) === -1) {
					viableTargets.push(territoryStateInfo[targetTerID].occupiedByUnits[this.rowIndex]);
				} else {
					viableTargets.splice(viableTargets.indexOf(territoryStateInfo[targetTerID].occupiedByUnits[this.rowIndex]), 1);
				}
				document.getElementById('priorityTargetsNumbers').innerHTML = viableTargets.length + ' targets will take priority when attacking';
			}
			r1.onmouseover = function() {
				document.getElementById('cardPreviewArea').style.backgroundColor = kingdomColorArray[playerNumber];
			}
			r1.onmouseout = function() {
				document.getElementById('cardPreviewArea').style.backgroundColor = 'transparent';
			}
			var cName = r1.insertCell(0);
			$(cName).addClass('priorityTargetsName');
			cName.style.paddingLeft = '1%';
			var cHealth = r1.insertCell(1);
			var cEffects = r1.insertCell(2);
			cName.innerHTML = referenceCards[territoryStateInfo[targetTerID].occupiedByUnits[unit]].name;
			cHealth.innerHTML = '<div class="maxHealthBar"><div class="currentHealthBar"></div></div>';
			console.log(unit);
			// FUTURE FIX: why is getElementsByClassName undefined on the second iteration?
			cHealth.getElementsByClassName('maxHealthBar')[unit].getElementsByClassName('currentHealthBar')[0].style.width = ((referenceCards[territoryStateInfo[targetTerID].occupiedByUnits[unit]].currentHP / referenceCards[territoryStateInfo[targetTerID].occupiedByUnits[unit]].maxHP) * 100) + '%';
			// FUTURE FIX: fix image size
			// FUTURE FIX: add hover to show card details
			var t = document.createElement('table');
			t.className = 'priorityTargetsEffects';
			var rowCellWidth = 5;
			for (var row = 0; row < Math.ceil(referenceCards[territoryStateInfo[targetTerID].occupiedByUnits[unit]].appliedEffects.length / rowCellWidth); row++) {
				var r2 = t.insertRow(row);
				var tempCellCount = referenceCards[territoryStateInfo[targetTerID].occupiedByUnits[unit]].appliedEffects.length - (row * rowCellWidth);
				if (tempCellCount > 5) {
					tempCellCount = 5;
				}
				for (var cell = 0; cell < tempCellCount; cell++) {
					var cEffectImage = r2.insertCell(cell);
					cEffectImage.style.width = '20%';
					var img = document.createElement('img');
					img.src = referenceCards[referenceCards[territoryStateInfo[targetTerID].occupiedByUnits[unit]].appliedEffects[(row * rowCellWidth) + cell]].image;
					img.style.width = '100%';
					img.style.height = 'auto';
					cEffectImage.appendChild(img);
				}
			}
			cEffects.appendChild(t);
		}
		$('#priorityTargetsConfirmButton').unbind('click');
		document.getElementsByClassName('priorityTargetsConfirmButton').onclick = function() {
            targetPlayer = territoryStateInfo[targetTerID].occupiedByPlayer;
            // socket.emit('select trap', GRID, targetPlayer, playerNumber, targetPlayer, activeTer, tergetTerID, activeUnits, targetedUnits, -1);
			selectTrap(targetPlayer, playerNumber, targetPlayer, activeTer, targetTerID, activeUnits, targetedUnits, -1);
			hidePriorityTargets();
		}
		showPriorityTargets();
	}
	function selectTrap(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, sAactiveUnits, sTargetedUnits, firstTrap) {
        // TO DO (optional): change UI to include information on which units are attacking (to see which traps are best), possibly by showing combat window while selecting traps. Windows together may be too much to fit reasonably on screen
        console.log('selectTrap()');
		var hasTraps = false;
		var tempSelected = false;
		var hasActiveUtility = false;
		for (var card = 0; card < altCardPiles[((playerNumber * 3) + 1)].length; card++) {
			var tempCard = card + 1;
			if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][card]].cardType !== 1) {
				// FUTURE FIX: add greyed out overlay
			} else if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][card]].name === 'Dismantler' || referenceCards[altCardPiles[((playerNumber * 3) + 1)][card]].name === 'Distraction') {
				if (firstTrap !== -1) {
					hasTraps = true;
					if (referenceCards[altCardPiles[((playerNumber * 3) + 1)][card]].name === 'Distraction') {
						for (var i = 0; i < altCardPiles[((defendingPlayer * 3) + 2)].length; i++) {
							altCardPiles[((defendingPlayer * 3) + 2)][i]
							if (referenceCards[altCardPiles[((defendingPlayer * 3) + 2)][i]].duration === 999) {
								hasActiveUtility = true;
								break;
							}
						}
						if (hasActiveUtility === true) {
							$('#cardImage' + tempCard).click(
								(function(card) {
									return function() {
										if (tempSelected === false) {
											tempSelected = true;
											addToCardHistory(altCardPiles[((playerNumber * 3) + 1)][card], playerNumber);
                                            // socket.emit('show played trap', GRID, defendingPlayer, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, altCardPiles[((playerNumber * 3) + 1)][card]);
                                            /* this part should be deleted if the above socket works just fine
                                            // socket.emit('activate trap', GRID, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, altCardPiles[((playerNumber * 3) + 1)][card]);
                                            */
                                            activateTrap(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, altCardPiles[((playerNumber * 3) + 1)][card]);
										}
									};
								})(card)
							);
						} else {
							// FUTURE FIX: add greyed out overlay
						}
					} else {
						$('#cardImage' + tempCard).click(
							(function(card) {
								return function() {
									if (tempSelected === false) {
										tempSelected = true;
										addToCardHistory(altCardPiles[((playerNumber * 3) + 1)][card], playerNumber);
                                        // socket.emit('show played trap', GRID, defendingPlayer, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, altCardPiles[((playerNumber * 3) + 1)][card]);
                                        /* this part should be deleted if the above socket works just fine
                                        */
                                        activateTrap(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, altCardPiles[((playerNumber * 3) + 1)][card]);
									}
								};
							})(card)
						);
					}
				} else {
					// FUTURE FIX: add greyed out overlay
				}
			} else {
				if (referenceCards[firstTrap].name === 'Liquid Death') {
					var skip = true;
                    for (var allyUnit = 0; allyUnit < territoryStateInfo[sTargetTerID].occupiedByUnits.length; allyUnit++) {
                        if (referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[allyUnit]].name === 'Wall') {
        					for (var enemyUnit = 0; enemyUnit < territoryStateInfo[sTargetTerID].occupiedByUnits.length; enemyUnit++) {
        						if (referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[enemyUnit]].type === 0 && referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[enemyUnit]].hasOwnProperty('ranged') === false) {
        							skip = false;
        							break;
        						}
        					}
                            break;
                        }
                    }
					if (skip === true) {
						continue;
					}
				} else if (referenceCards[firstTrap].name === 'Royal Reinstatement') {
					var skip = true;
					for (var enemyUnit = 0; enemyUnit < territoryStateInfo[sTargetTerID].occupiedByUnits.length; enemyUnit++) {
						if (referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[enemyUnit]].affiliation === kingdomNameArray[kingdom[playerNumber]]) {
							skip = false;
							break;
						}
					}
					if (skip === true) {
						continue;
					}
				} else if (referenceCards[firstTrap].name === 'Rusting Mists') {
					var skip = true;
					for (var enemyUnit = 0; enemyUnit < territoryStateInfo[sTargetTerID].occupiedByUnits.length; enemyUnit++) {
						if (referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[enemyUnit]].mechanical !== 0) {
							skip = false;
							break;
						}
					}
					if (skip === true) {
						continue;
					}
				} else if (referenceCards[firstTrap].name === 'Trapping Pit') {
					var skip = true;
					for (var enemyUnit = 0; enemyUnit < territoryStateInfo[sTargetTerID].occupiedByUnits.length; enemyUnit++) {
						if (referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[enemyUnit]].size !== 2 && referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[enemyUnit]].size !== 3 && referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[enemyUnit]].size !== 99 && referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[enemyUnit]].type === 0) {
							skip = false;
							break;
						}
					}
					if (skip === true) {
						continue;
					}
				}
				hasTraps = true;
				$('#cardImage' + tempCard).click(
					(function(card) {
						return function() {
							if (tempSelected === false) {
								tempSelected = true;
								addToCardHistory(altCardPiles[((playerNumber * 3) + 1)][card], playerNumber);
                                // socket.emit('show played trap', GRID, attackingPlayer, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, altCardPiles[((playerNumber * 3) + 1)][card], -1);
                                /* this part should be deleted if the above socket works just fine
                                // socket.emit('select trap', GRID, attackingPlayer, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, altCardPiles[((playerNumber * 3) + 1)][card]);
                                */
                                selectTrap(attackingPlayer, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, altCardPiles[((playerNumber * 3) + 1)][card]);
							}
						};
					})(card)
				);
			}
		}
		if (hasTraps === false) {
			document.getElementById('dontUseTrapsText').innerHTML = 'You don\'t have any viable traps in your hand';
		} else {
			document.getElementById('dontUseTrapsText').innerHTML = 'Select a trap to activate, or';
		}
		$('#dontUseTrapsButton').unbind('click');
		$('#dontUseTrapsButton').click(
			function() {
                socket.emit('attack ter', playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, -1);
				attackTer(sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, -1);
				hideDontUseTraps();
				refreshInteractibility();
			}
		);
		showDontUseTraps();
	}
	function activateTrap(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
        // TO DO: make this universal to the attacking and defending player
        if (playerNumber === attackingPlayer || playerNumber === defendingPlayer) {
            for (var item = 0; item < territoryStateInfo[sActiveTerID].occupiedByUnits.length; item++) {
                $('#terUnitInfo' + item).remove();
                document.getElementById('terUnitTooltip' + item).remove();
            }
            if (counterTrap !== -1) {
                if (attackingPlayer === playerNumber) {
                    clearCardVisuals(altCardPiles[((attackingPlayer * 3) + 1)].indexOf(counterTrap));
                }
                switch(referenceCards[counterTrap].name) {
                    case 'Dismantler':
                        if (attackingPlayer === playerNumber) {
                            // TO DO: select utility to destroy before combat starts
                            attackTer(sTargetTerID, sTargetedUnits, -1);
                        }
                        break;
                    case 'Distraction':
                        if (attackingPlayer === playerNumber) {
                            // TO DO: replace all altCardPiles pushes with socket commands
                            // socket.emit('push to discard pile', GRID, attackingPlayer, counterTrap);
                            altCardPiles[((attackingPlayer * 3) + 3)].push(counterTrap);
                        }
                        // copy of code below
                            if (defendingPlayer === playerNumber) {
                                clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(firstTrap));
                                // socket.emit('push to discard pile', GRID, playerNumber, firstTrap);
                                altCardPiles[((playerNumber * 3) + 3)].push(firstTrap);
                            }
                            switch(referenceCards[firstTrap].name) {
                                case 'Abanea Trenchdiggers':
                                    if (defendingPlayer === playerNumber) {
                                        // socket.emit('attack ter', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                        attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                    }
                                    break;
                                case 'Distraction':
                                    if (defendingPlayer === playerNumber) {
                                        // socket.emit('attack ter', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                        attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                    }
                                    break;
                                case 'Forged Armistice':
                                    if (defendingPlayer === playerNumber) {
                                        // TO DO (check): does this socket know who the target is and who the immune player is, regardless of whether this is firstTrap or counterTrap?
                                        // socket.emit('push to forgedArmistice', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, 1);
                                        forgedArmistice.push({player:attackingPlayer, cannotAttack:defendingPlayer, turnsLeft:1});
                                        break;
                                    }
                                case 'Frost Dust Bombs':
                                    if (defendingPlayer === playerNumber) {
                                        // socket.emit('push to frostDustBombs', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, 1);
                                        for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                                            referenceCards[attackingUnits[attacker]].currentSpeed = 0;
                                            if (referenceCards[attackingUnits[attacker]].type === 2) {
                                                referenceCards[attackingUnits[attacker]].currentHP = referenceCards[attackingUnits[attacker]].currentHP - (referenceCards[attackingUnits[attacker]].maxHP * 0.4);
                                                if (Math.round(referenceCards[attackingUnits[attacker]].currentHP) <= 0) {
                                                    territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(attackingUnits[attacker]), 1);
                                                    unit--;
                                                } else {
                                                    frostDustBombs.push({unitID:attackingUnits[attacker], turnsLeft:1});
                                                }
                                            }
                                        }
                                        refreshTerStateVisuals(sActiveTerID);
                                        if (attackingUnits.length > 0) {
                                            attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                        }
                                    }
                                    break;
                                case 'Giant Nevermore':
                                    if (defendingPlayer === playerNumber) {
                                        // TO DO (optional): send socketIO notification to other players that a GN target is being selected by player X
                                        selectGiantNevermoreTarget(sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap);
                                    }
                                    break;
                                case 'Grimm Attack':
                                    if (defendingPlayer === playerNumber) {
                                        // socket.emit('attack ter', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                        attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                    }
                                    break;
                                case 'Liquid Death':
                                    if (defendingPlayer === playerNumber) {
                                        for (var defender = 0; defender < territoryStateInfo[sTargetTerID].occupiedByUnits.length; defender++) {
                                            if (referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[defender]].name === 'Wall') {
                                                // TO DO: 
                                                // socket.emit('liquid death', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, territoryStateInfo[sTargetTerID].occupiedByUnits[defender], 1);
                                                liquidDeath.push({unitID:territoryStateInfo[sTargetTerID].occupiedByUnits[defender], turnsLeft:1});
                                                break;
                                            }
                                        }
                                        attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                    }
                                    break;
                                case 'Minefield':
                                    if (defendingPlayer === playerNumber) {
                                        // socket.emit('minefield', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                        for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                                            if (referenceCards[attackingUnits[attacker]].hasOwnProperty('ranged') && referenceCards[attackingUnits[attacker]].type === 0) {
                                                referenceCards[attackingUnits[attacker]].currentHP = referenceCards[attackingUnits[attacker]].currentHP - 15;
                                            }
                                        }
                                        for (var unit = 0; unit < territoryStateInfo[sActiveTerID].occupiedByUnits.length; unit++) {
                                            if (Math.round(referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].currentHP) <= 0) {
                                                territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[unit]), 1);
                                                unit--;
                                            }
                                        }
                                        refreshTerStateVisuals(sActiveTerID);
                                        if (attackingUnits.length > 0) {
                                            attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                        }
                                    }
                                    break;
                                case 'Naval Minefield':
                                    if (defendingPlayer === playerNumber) {
                                        // socket.emit('naval minefield', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                        for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                                            if (referenceCards[attackingUnits[attacker]].type === 1) {
                                                referenceCards[attackingUnits[attacker]].currentHP = referenceCards[attackingUnits[attacker]].currentHP - 15;
                                            }
                                        }
                                        for (var unit = 0; unit < territoryStateInfo[sActiveTerID].occupiedByUnits.length; unit++) {
                                            if (Math.round(referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].currentHP) <= 0) {
                                                territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[unit]), 1);
                                                unit--;
                                            }
                                        }
                                        refreshTerStateVisuals(sActiveTerID);
                                        if (attackingUnits.length > 0) {
                                            attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                        }
                                    }
                                    break;
                                case 'Royal Reinstatement':
                                    if (defendingPlayer === playerNumber) {
                                        // socket.emit('royal reinstatement', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                        for (var enemy = 0; enemy < territoryStateInfo[sActiveTerID].occupiedByUnits.length; enemy++) {
                                            if (referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[enemy]].affiliation === kingdomNameArray[kingdom[playerNumber]]) {
                                                territoryStateInfo[sActiveTerID].occupiedByUnits.push(territoryStateInfo[sActiveTerID].occupiedByUnits[enemy]);
                                                territoryStateInfo[sActiveTerID].occupiedByUnits.splice(enemy, 1);
                                                unit--;
                                            }
                                        }
                                        // FUTURE FIX: optionally add visuals displaying how many move over
                                        refreshTerStateVisuals();
                                        if (territoryStateInfo[sActiveTerID].occupiedByUnits.length > 0) {
                                            attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                        }
                                    }
                                    break;
                                case 'Rusting Mists':
                                    if (defendingPlayer === playerNumber) {
                                        // socket.emit('rusting mists', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, 1);
                                        var rustbucketCount = 0;
                                        for (var ally = 0; ally < attackingUnits.length; ally++) {
                                            if (referenceCards[attackingUnits[ally]].mechanical !== 0) {
                                                rustbucketCount++;
                                                rustingMists.push({unitID:attackingUnits[ally], turnsLeft:1});
                                            }
                                        }
                                        if (rustbucketCount < attackingUnits.length) {
                                            attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                        }
                                    }
                                    break;
                                case 'Stealthy Commandeering':
                                    if (defendingPlayer === playerNumber) {
                                        selectStealthyCommandeeringTarget(sActiveTerID, sTargetTerID, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap);
                                    }
                                    break;
                                case 'Trapping Pit':
                                    if (defendingPlayer === playerNumber) {
                                        // socket.emit('trapping pit', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, 1);
                                        // optional: also prevent repair
                                        for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                                            referenceCards[attackingUnits[attacker]].currentSpeed = 0;
                                            if (referenceCards[attackingUnits[attacker]].size !== 2 && referenceCards[attackingUnits[attacker]].size !== 3 && referenceCards[attackingUnits[attacker]].size !== 99 && referenceCards[attackingUnits[attacker]].type === 0) {
                                                trappingPit.push({unitID:attackingUnits[attacker], turnsLeft:1});
                                            }
                                        }
                                        attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                                    }
                                    break;
                            }
                        viableCards = [];
                        for (var card = 0; card < altCardPiles[((playerNumber * 3) + 2)].length; card++) {
                            if (altCardPiles[((playerNumber * 3) + 2)][card].cardType === 2 && altCardPiles[((playerNumber * 3) + 2)][card].duration === 999) {
                                viableCards.push(altCardPiles[((playerNumber * 3) + 2)][card]);
                            }
                        }
                        cardSource = 1;
                        pickCard();
                        break;
                }
            } else {
                if (defendingPlayer === playerNumber) {
                    clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(firstTrap));
                    // socket.emit('push to discard pile', GRID, playerNumber, firstTrap);
                    altCardPiles[((playerNumber * 3) + 3)].push(firstTrap);
                }
                switch(referenceCards[firstTrap].name) {
                    case 'Abanea Trenchdiggers':
                        if (defendingPlayer === playerNumber) {
                            // socket.emit('attack ter', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                            attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                        }
                        break;
                    case 'Distraction':
                        if (defendingPlayer === playerNumber) {
                            // socket.emit('attack ter', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                            attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                        }
                        break;
                    case 'Forged Armistice':
                        if (defendingPlayer === playerNumber) {
                            // socket.emit('push to forgedArmistice', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, 1);
                            forgedArmistice.push({player:attackingPlayer, cannotAttack:defendingPlayer, turnsLeft:1});
                            break;
                        }
                    case 'Frost Dust Bombs':
                        if (defendingPlayer === playerNumber) {
                            // socket.emit('push to frostDustBombs', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, 1);
                            for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                                referenceCards[attackingUnits[attacker]].currentSpeed = 0;
                                if (referenceCards[attackingUnits[attacker]].type === 2) {
                                    referenceCards[attackingUnits[attacker]].currentHP = referenceCards[attackingUnits[attacker]].currentHP - (referenceCards[attackingUnits[attacker]].maxHP * 0.4);
                                    if (Math.round(referenceCards[attackingUnits[attacker]].currentHP) <= 0) {
                                        territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(attackingUnits[attacker]), 1);
                                        unit--;
                                    } else {
                                        frostDustBombs.push({unitID:attackingUnits[attacker], turnsLeft:1});
                                    }
                                }
                            }
                            refreshTerStateVisuals(sActiveTerID);
                            if (attackingUnits.length > 0) {
                                attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                            }
                        }
                        break;
                    case 'Giant Nevermore':
                        if (defendingPlayer === playerNumber) {
                            // TO DO (optional): send socketIO notification to other players that a GN target is being selected by player X
                            selectGiantNevermoreTarget(sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap);
                        }
                        break;
                    case 'Grimm Attack':
                        if (defendingPlayer === playerNumber) {
                            // socket.emit('attack ter', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                            attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                        }
                        break;
                    case 'Liquid Death':
                        if (defendingPlayer === playerNumber) {
                            for (var defender = 0; defender < territoryStateInfo[sTargetTerID].occupiedByUnits.length; defender++) {
                                if (referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[defender]].name === 'Wall') {
                                    // TO DO: 
                                    // socket.emit('liquid death', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, territoryStateInfo[sTargetTerID].occupiedByUnits[defender], 1);
                                    liquidDeath.push({unitID:territoryStateInfo[sTargetTerID].occupiedByUnits[defender], turnsLeft:1});
                                    break;
                                }
                            }
                            attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                        }
                        break;
                    case 'Minefield':
                        if (defendingPlayer === playerNumber) {
                            // socket.emit('minefield', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                            for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                                if (referenceCards[attackingUnits[attacker]].hasOwnProperty('ranged') && referenceCards[attackingUnits[attacker]].type === 0) {
                                    referenceCards[attackingUnits[attacker]].currentHP = referenceCards[attackingUnits[attacker]].currentHP - 15;
                                }
                            }
                            for (var unit = 0; unit < territoryStateInfo[sActiveTerID].occupiedByUnits.length; unit++) {
                                if (Math.round(referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].currentHP) <= 0) {
                                    territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[unit]), 1);
                                    unit--;
                                }
                            }
                            refreshTerStateVisuals(sActiveTerID);
                            if (attackingUnits.length > 0) {
                                attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                            }
                        }
                        break;
                    case 'Naval Minefield':
                        if (defendingPlayer === playerNumber) {
                            // socket.emit('naval minefield', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                            for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                                if (referenceCards[attackingUnits[attacker]].type === 1) {
                                    referenceCards[attackingUnits[attacker]].currentHP = referenceCards[attackingUnits[attacker]].currentHP - 15;
                                }
                            }
                            for (var unit = 0; unit < territoryStateInfo[sActiveTerID].occupiedByUnits.length; unit++) {
                                if (Math.round(referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].currentHP) <= 0) {
                                    territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[unit]), 1);
                                    unit--;
                                }
                            }
                            refreshTerStateVisuals(sActiveTerID);
                            if (attackingUnits.length > 0) {
                                attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                            }
                        }
                        break;
                    case 'Royal Reinstatement':
                        if (defendingPlayer === playerNumber) {
                            // socket.emit('royal reinstatement', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                            for (var enemy = 0; enemy < territoryStateInfo[sActiveTerID].occupiedByUnits.length; enemy++) {
                                if (referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[enemy]].affiliation === kingdomNameArray[kingdom[playerNumber]]) {
                                    territoryStateInfo[sActiveTerID].occupiedByUnits.push(territoryStateInfo[sActiveTerID].occupiedByUnits[enemy]);
                                    territoryStateInfo[sActiveTerID].occupiedByUnits.splice(enemy, 1);
                                    unit--;
                                }
                            }
                            // FUTURE FIX: optionally add visuals displaying how many move over
                            refreshTerStateVisuals();
                            if (territoryStateInfo[sActiveTerID].occupiedByUnits.length > 0) {
                                attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                            }
                        }
                        break;
                    case 'Rusting Mists':
                        if (defendingPlayer === playerNumber) {
                            // socket.emit('rusting mists', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, 1);
                            var rustbucketCount = 0;
                            for (var ally = 0; ally < attackingUnits.length; ally++) {
                                if (referenceCards[attackingUnits[ally]].mechanical !== 0) {
                                    rustbucketCount++;
                                    rustingMists.push({unitID:attackingUnits[ally], turnsLeft:1});
                                }
                            }
                            if (rustbucketCount < attackingUnits.length) {
                                attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                            }
                        }
                        break;
                    case 'Stealthy Commandeering':
                        if (defendingPlayer === playerNumber) {
                            selectStealthyCommandeeringTarget(sActiveTerID, sTargetTerID, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap);
                        }
                        break;
                    case 'Trapping Pit':
                        if (defendingPlayer === playerNumber) {
                            // socket.emit('trapping pit', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, 1);
                            // optional: also prevent repair
                            for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                                referenceCards[attackingUnits[attacker]].currentSpeed = 0;
                                if (referenceCards[attackingUnits[attacker]].size !== 2 && referenceCards[attackingUnits[attacker]].size !== 3 && referenceCards[attackingUnits[attacker]].size !== 99 && referenceCards[attackingUnits[attacker]].type === 0) {
                                    trappingPit.push({unitID:attackingUnits[attacker], turnsLeft:1});
                                }
                            }
                            attackTer(playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
                        }
                        break;
                }
            }
        }
	}
	function selectGiantNevermoreTarget(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
		console.log('selectGiantNevermoreTarget()');
		document.getElementById('giantNevermoreTable').innerHTML = '';
		var selectionMade = false;
		for (var unit = 0; unit < territoryStateInfo[sActiveTerID].occupiedByUnits.length; unit++) {
			// optional: exclude walls from possible Nevermore targets
			var r1 = document.getElementById('giantNevermoreTable').insertRow(unit);
			r1.onclick = function() {
				if (selectionMade === false) {
					selectionMade = true;
					// FUTURE FIX: insert visuals here
					var target = Math.round(Math.random());
					if (target === 0) {
						// enemy target
                        // socket.emit('assault of the giant nevermore', GRID, playerNumber, sActiveTerID, sTargetTerID, target, attackingUnits, territoryStateInfo[sActiveTerID].occupiedByUnits[this.rowIndex], -1);
						if (sTargetedUnits.indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[this.rowIndex]) !== -1) {
							sTargetedUnits.splice(sTargetedUnits.indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[this.rowIndex]), 1);
						}
                        referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[this.rowIndex]].currentHP = 0;
                        altCardPiles[((territoryStateInfo[sActiveTerID].occupiedByPlayer * 3) + 2)].splice(altCardPiles[((territoryStateInfo[sActiveTerID].occupiedByPlayer * 3) + 2)].indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[this.rowIndex]), 1);
                        territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[this.rowIndex]), 1);
                        refreshTerStateVisuals(sActiveTerID);
						if (territoryStateInfo[sActiveTerID].occupiedByUnits.length > 0) {
							attackTer(sActiveTerID, sTargetedUnits, firstTrap);
						}
					} else {
						// friendly target
						var tempAllies = [];
						for (var ally = 0; ally < territoryStateInfo[sTargetTerID].occupiedByUnits.length; ally++) {
							// optional: exclude walls from possible Nevermore targets
							tempAllies.push(territoryStateInfo[sTargetTerID].occupiedByUnits[ally]);
						}
						for (var adj = 0; adj < territoryStateInfo[sTargetTerID].adjacentTer.length; adj++) {
							for (var ally = 0; ally < territoryStateInfo[territoryStateInfo[sTargetTerID].adjacentTer[adj]].occupiedByUnits.length; ally++) {
								// optional: exclude walls from possible Nevermore targets
								tempAllies.push(territoryStateInfo[territoryStateInfo[sTargetTerID].adjacentTer[adj]].occupiedByUnits[ally]);
							}
						}
						target = Math.floor(Math.random() * (tempAllies.length + 1));
						var tempTargetAlly = tempAllies[target];
                        // socket.emit('assault of the giant nevermore', GRID, playerNumber, sActiveTerID, sTargetTerID, target, attackingUnits, -1, tempTargetAlly);
						for (var ally = 0; ally < territoryStateInfo[sTargetTerID].occupiedByUnits.length; ally++) {
							if (territoryStateInfo[sTargetTerID].occupiedByUnits[ally] === tempTargetAlly) {
								territoryStateInfo[sTargetTerID].occupiedByUnits.splice(territoryStateInfo[sTargetTerID].occupiedByUnits[ally], 1);
                                // TO DO: add this statement only for the attacking player?
                                /*if (defendingUnits.indexOf(tempTargetAlly) !== -1) {
                                    defendingUnits.splice(defendingUnits.indexOf(tempTargetAlly), 1);
                                }*/
                                refreshTerStateVisuals(sTargetTerID);
                                if (sTargetedUnits.indexOf(tempTargetAlly) !== -1) {
                                    sTargetedUnits.splice(sTargetedUnits.indexOf(tempTargetAlly), 1);
                                }
							}
						}
						for (var adj = 0; adj < territoryStateInfo[sTargetTerID].adjacentTer.length; adj++) {
							for (var ally = 0; ally < territoryStateInfo[territoryStateInfo[sTargetTerID].adjacentTer[adj]].occupiedByUnits.length; ally++) {
								if (territoryStateInfo[territoryStateInfo[sTargetTerID].adjacentTer[adj]].occupiedByUnits[ally] === tempTargetAlly) {
									territoryStateInfo[territoryStateInfo[sTargetTerID].adjacentTer[adj]].occupiedByUnits.splice(territoryStateInfo[territoryStateInfo[sTargetTerID].adjacentTer[adj]].occupiedByUnits[ally], 1);
                                    refreshTerStateVisuals(territoryStateInfo[sTargetTerID].adjacentTer[adj]);
								}
							}
						}
						referenceCards[tempTargetAlly].currentHP = 0;
                        altCardPiles[((defendingPlayer * 3) + 2)].splice(altCardPiles[((defendingPlayer * 3) + 2)].indexOf(tempTargetAlly), 1);
                        territoryStateInfo[sTargetTerID].occupiedByUnits.splice(territoryStateInfo[sTargetTerID].occupiedByUnits.indexOf(tempTargetAlly), 1);
                        refreshTerStateVisuals(sActiveTerID);
						if (territoryStateInfo[sTargetTerID].occupiedByUnits.length > 0) {
							attackTer(sActiveTerID, sTargetedUnits, firstTrap);
                        }
					}
				}
			}
			r1.onmouseover = function() {
				document.getElementById('cardPreviewArea').style.backgroundColor = kingdomColorArray[territoryStateInfo[sActiveTerID].occupiedByPlayer];
			}
			r1.onmouseout = function() {
				document.getElementById('cardPreviewArea').style.backgroundColor = 'transparent';
			}
			var cName = r1.insertCell(0);
			$(cName).addClass('giantNevermoreName');
			cName.style.paddingLeft = '1%';
			var cHealth = r1.insertCell(1);
			var cEffects = r1.insertCell(2);
			cName.innerHTML = referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].name;
			cHealth.innerHTML = '<div class="maxHealthBar"><div class="currentHealthBar"></div></div>';
			cHealth.getElementsByClassName('maxHealthBar')[unit].getElementsByClassName('currentHealthBar')[0].style.width = ((referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].currentHP / referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].maxHP) * 100) + '%';
			// FUTURE FIX: fix image size
			// FUTURE FIX: add hover to show card details
			var t = document.createElement('table');
			t.className = 'utilityEffects';
			// document.getElementsByClassName('utilityEffects')[unit].innerHTML = '';
			var rowCellWidth = 5;
			for (var row = 0; row < Math.ceil(referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].appliedEffects.length / rowCellWidth); row++) {
				var r2 = t.insertRow(row);
				var tempCellCount = referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].appliedEffects.length - (row * rowCellWidth);
				if (tempCellCount > 5) {
					tempCellCount = 5;
				}
				for (var cell = 0; cell < tempCellCount; cell++) {
					var cEffectImage = r2.insertCell(cell);
					cEffectImage.style.width = '20%';
					var img = document.createElement('img');
					img.src = referenceCards[referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].appliedEffects[(row * rowCellWidth) + cell]].image;
					img.style.width = '100%';
					img.style.height = 'auto';
					cEffectImage.appendChild(img);
				}
			}
			cEffects.appendChild(t);
		}
		// FUTURE FIX: close button does not appear
		showGiantNevermore();
		document.getElementById('giantNevermore').style.marginLeft = '-' + (document.getElementById('giantNevermore').offsetWidth / 2) + 'px';
		document.getElementById('giantNevermore').style.marginTop = (window.innerHeight / 2) - (document.getElementById('giantNevermore').offsetHeight / 2) + 'px';
	}
	function selectStealthyCommandeeringTarget(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
		console.log('selectStealthyCommandeeringTarget()');
		document.getElementById('stealthyCommandeeringTable').innerHTML = '';
		var selectionMade = false;
        var tempViableTargets = [];
        for (var unit = 0; unit < territoryStateInfo[sActiveTerID].occupiedByUnits.length; unit++) {
            if (referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].mechanical === 2 && referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].hasOwnProperty(transportSize) === false) {
                tempViableTargets.push(territoryStateInfo[sActiveTerID].occupiedByUnits[unit]);
            }
        }
        for (var unit = 0; unit < tempViableTargets.length; unit++) {
			var r1 = document.getElementById('stealthyCommandeeringTable').insertRow(unit);
			r1.onclick = function() {
				if (selectionMade === false && referenceCards[tempViableTargets[this.rowIndex]].mechanical === 2 && referenceCards[tempViableTargets[this.rowIndex]].hasOwnProperty(transportSize) === false) {
					selectionMade = true;
                    // socket.emit('stealthy commandeering', GRID, playerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, tempViableTargets[this.rowIndex]);
					// FUTURE FIX: insert visuals here
					if (attackingUnits.indexOf(tempViableTargets[this.rowIndex]) !== -1) {
						attackingUnits.splice(attackingUnits.indexOf(tempViableTargets[this.rowIndex]), 1);
					}
                    territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(tempViableTargets[this.rowIndex]), 1);
                    territoryStateInfo[sTargetTerID].occupiedByUnits.push(tempViableTargets[this.rowIndex]);
                    altCardPiles[((attackingPlayer * 3) + 2)].splice(altCardPiles[((attackingPlayer * 3) + 2)].indexOf(tempViableTargets[this.rowIndex]), 1);
                    altCardPiles[((defendingPlayer * 3) + 2)].push(tempViableTargets[this.rowIndex]);
                    refreshTerStateVisuals(sActiveTerID);
                    refreshTerStateVisuals(sTargetTerID);
					if (territoryStateInfo[sActiveTerID].occupiedByUnits.length > 0) {
						attackTer(sActiveTerID, sTargetedUnits, firstTrap);
					}
				}
			}
			r1.onmouseover = function() {
				document.getElementById('cardPreviewArea').style.backgroundColor = kingdomColorArray[territoryStateInfo[sActiveTerID].occupiedByPlayer];
			}
			r1.onmouseout = function() {
				document.getElementById('cardPreviewArea').style.backgroundColor = 'transparent';
			}
			var cName = r1.insertCell(0);
			$(cName).addClass('stealthyCommandeeringName');
			cName.style.paddingLeft = '1%';
			var cHealth = r1.insertCell(1);
			var cEffects = r1.insertCell(2);
			cName.innerHTML = referenceCards[tempViableTargets[unit]].name;
			cHealth.innerHTML = '<div class="maxHealthBar"><div class="currentHealthBar"></div></div>';
			cHealth.getElementsByClassName('maxHealthBar')[unit].getElementsByClassName('currentHealthBar')[0].style.width = ((referenceCards[tempViableTargets[unit]].currentHP / referenceCards[tempViableTargets[unit]].maxHP) * 100) + '%';
			// FUTURE FIX: fix image size
			// FUTURE FIX: add hover to show card details
			var t = document.createElement('table');
			t.className = 'utilityEffects';
			// document.getElementsByClassName('utilityEffects')[unit].innerHTML = '';
			var rowCellWidth = 5;
			for (var row = 0; row < Math.ceil(referenceCards[tempViableTargets[unit]].appliedEffects.length / rowCellWidth); row++) {
				var r2 = t.insertRow(row);
				var tempCellCount = referenceCards[tempViableTargets[unit]].appliedEffects.length - (row * rowCellWidth);
				if (tempCellCount > 5) {
					tempCellCount = 5;
				}
				for (var cell = 0; cell < tempCellCount; cell++) {
					var cEffectImage = r2.insertCell(cell);
					cEffectImage.style.width = '20%';
					var img = document.createElement('img');
					img.src = referenceCards[referenceCards[tempViableTargets[unit]].appliedEffects[(row * rowCellWidth) + cell]].image;
					img.style.width = '100%';
					img.style.height = 'auto';
					cEffectImage.appendChild(img);
				}
			}
			cEffects.appendChild(t);
		}
		// FUTURE FIX: close button does not appear
		showStealthyCommandeering();
		document.getElementById('stealthyCommandeering').style.marginLeft = '-' + (document.getElementById('stealthyCommandeering').offsetWidth / 2) + 'px';
		document.getElementById('stealthyCommandeering').style.marginTop = (window.innerHeight / 2) - (document.getElementById('stealthyCommandeering').offsetHeight / 2) + 'px';
	}
    function attackTer(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
        console.log('attackTer()');
        /*initializing combat*/
            for (var ter = 0; ter < territoryShapeInfo.length; ter++) {
                $('#territoryArea' + ter).removeClass('viableMovement');
                $('#territoryArea' + ter).removeClass('viableAttackTarget');
                $('#territoryArea' + ter).removeClass('viableRangedTarget');
                $('#territoryArea' + ter).removeClass('passingThrough');
                $('#territoryArea' + ter).removeClass('attackPath');
                $('#territoryArea' + ter).removeClass('viableLoadIn');
            }
            $('#territoryArea' + sActiveTerID).removeClass('selected');
            var enemyUnitKilled = false;
            var priorityAttackUnits = [];
            var nonPriorityAttackUnits = [];
            var allAttackUnits = [];
            for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                if (referenceCards[attackingUnits[attacker]].hasOwnProperty('ranged') === true || referenceCards[attackingUnits[attacker]].name === 'Atlesian Bomb Drones' || referenceCards[attackingUnits[attacker]].name === 'Unstable Dust Ships') {
                    priorityAttackUnits.push(attackingUnits[attacker]);
                } else {
                    nonPriorityAttackUnits.push(attackingUnits[attacker]);
                }
                allAttackUnits.push(attackingUnits[attacker]);
                attackingUnits[attacker].hasAttacked = true;
            }
            var priorityDefenseUnits = [];
            var nonPriorityDefenseUnits = [];
            var allDefenseUnits = [];
            for (var defender = 0; defender < territoryStateInfo[sTargetTerID].occupiedByUnits.length; defender++) {
                if (referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[defender]].hasOwnProperty('ranged') === true || referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[defender]].name === 'Atlesian Bomb Drones' || referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[defender]].name === 'Unstable Dust Ships') {
                    priorityDefenseUnits.push(territoryStateInfo[sTargetTerID].occupiedByUnits[defender]);
                } else {
                    nonPriorityDefenseUnits.push(territoryStateInfo[sTargetTerID].occupiedByUnits[defender]);
                }
                allDefenseUnits.push(territoryStateInfo[sTargetTerID].occupiedByUnits[defender]);
            }
            var priorityround = 0;
            if (priorityAttackUnits.length > 0 || priorityDefenseUnits > 0) {
                priorityround = 1;
            }
            // creating visuals window
            document.getElementById('combatUnits').getElementsByClassName('combatAttackers')[0].innerHTML = '';
            document.getElementById('combatUnits').getElementsByClassName('combatDefenders')[0].innerHTML = '';
            document.getElementById('combatUnits').getElementsByClassName('combatWall')[0].innerHTML = '';
            document.getElementById('combatHeaders').getElementsByClassName('combatAttackers')[0].innerHTML = commName[attackingPlayer] + '<br>(' + kingdomNameArray[attackingPlayer] + ')';
            var t = document.createElement('table');
            t.className = 'combatUnitInfo';
            for (var unit = 0; unit < allAttackUnits.length; unit++) {
                var r = t.insertRow(unit);
                var c1 = r.insertCell(0);
                var c2 = r.insertCell(1);
                if (priorityAttackUnits.indexOf(allAttackUnits[unit]) === -1) {
                    c1.innerHTML = referenceCards[allAttackUnits[unit]].name + '<br><div class="maxHealthBar"><div class="currentHealthBar"></div></div>';
                    c2.innerHTML = '';
                    c2.className = 'priorityBlank';
                } else {
                    c1.innerHTML = '';
                    c1.className = 'priorityBlank';
                    c2.innerHTML = referenceCards[allAttackUnits[unit]].name + '<br><div class="maxHealthBar"><div class="currentHealthBar"></div></div>';
                }
            }
            document.getElementById('combatUnits').getElementsByClassName('combatAttackers')[0].appendChild(t);
            var t = document.createElement('table');
            var hasWall = false;
            for (var i = 0; i < allDefenseUnits.length; i++) {
                if (referenceCards[allDefenseUnits[i]].name === 'Wall') {
                    hasWall = true;
                    break;
                }
            }
            if (hasWall === true) {
                var largestArmy = [];
                if (allAttackUnits.length > allDefenseUnits.length) {
                    largestArmy = allAttackUnits;
                } else {
                    largestArmy = allDefenseUnits;
                }
                for (var wall = 0; wall < largestArmy.length; wall++) {
                    var r = t.insertRow(wall);
                    var c = r.insertCell(0);
                    // FUTURE FIX: change this to a visual representation of a wall that can be stretched/extended over the height of the table
                    c.innerHTML = "W";
                }
            }
            document.getElementById('combatUnits').getElementsByClassName('combatWall')[0].appendChild(t);
            document.getElementById('combatHeaders').getElementsByClassName('combatDefenders')[0].innerHTML = commName[defendingPlayer] + '<br>(' + kingdomNameArray[defendingPlayer] + ')';
            var t = document.createElement('table');
            t.className = 'combatUnitInfo';
            for (var unit = 0; unit < allDefenseUnits.length; unit++) {
                var r = t.insertRow(unit);
                if (priorityDefenseUnits.indexOf(allDefenseUnits[unit]) === -1) {
                    r.innerHTML = '<td class="combatTarget">T</td><td><div class="combatUnitName">' + referenceCards[allDefenseUnits[unit]].name + '</div><div class="maxHealthBar"><div class="currentHealthBar"></div></div></td>';
                } else {
                    r.innerHTML = '<td class="combatTarget"></td><td><div class="combatUnitName">' + referenceCards[allDefenseUnits[unit]].name + '</div><div class="maxHealthBar"><div class="currentHealthBar"></div></div></td>';
                }
            }
            document.getElementById('combatUnits').getElementsByClassName('combatDefenders')[0].appendChild(t);
            for (var i = 0; i < allAttackUnits.length; i++) {
                document.getElementById('combatUnits').getElementsByClassName('combatAttackers')[0].getElementsByClassName('currentHealthBar')[i].style.width = (referenceCards[allAttackUnits[i]].currentHP / referenceCards[allAttackUnits[i]].maxHP) * 100 + '%';
            }
            for (var i = 0; i < allDefenseUnits.length; i++) {
                document.getElementById('combatUnits').getElementsByClassName('combatDefenders')[0].getElementsByClassName('currentHealthBar')[i].style.width = (referenceCards[allDefenseUnits[i]].currentHP / referenceCards[allDefenseUnits[i]].maxHP) * 100 + '%';
            }
            showCombat();

        // priority round
        var pIteration = 0;
        if (priorityround === 1) {
            var priorityInterval = setInterval(function() {
                pIteration++;
                console.log('priority iteration ' + pIteration);
                for (var attacker = 0; attacker < priorityAttackUnits.length; attacker++) {
                    var tempCanAttack = true;
                    for (var FDB = 0; FDB < frostDustBombs.length; FDB++) {
                        if (frostDustBombs[FDB].unitID === priorityAttackUnits[attacker]) {
                            tempCanAttack = false;
                        }
                    }
                    for (var RM = 0; RM < rustingMists.length; RM++) {
                        if (rustingMists[RM].unitID === priorityAttackUnits[attacker]) {
                            tempCanAttack = false;
                        }
                    }
                    for (var TP = 0; TP < trappingPit.length; TP++) {
                        if (trappingPit[TP].unitID === priorityAttackUnits[attacker]) {
                            tempCanAttack = false;
                        }
                    }
                    if (tempCanAttack === true) {
                        // checking every iteration whether there are actually any walls or sTargetedUnits left or if they should attack all (remaining) units
                        var targetScope = [];
                        var hasWall = false;
                        for (var i = 0; i < allDefenseUnits.length; i++) {
                            if (referenceCards[allDefenseUnits[i]].name === 'Wall') {
                                hasWall = true;
                                break;
                            }
                        }
                        if (hasWall === false) {
                            for (var wall = 0; wall < document.getElementById('combatUnits').getElementsByTagName('tr').length; wall++) {
                                document.getElementById('combatUnits').getElementsByTagName('tr')[wall].getElementsByTagName('td')[0].innerHTML = '';
                            }
                        }
                        if (hasWall === true) {
                            for (var i = 0; i < allDefenseUnits.length; i++) {
                                if (referenceCards[allDefenseUnits[i]].name === 'Wall') {
                                    targetScope.push(allDefenseUnits[i]);
                                }
                            }
                        } else if (sTargetedUnits.length > 0) {
                            for (var i = 0; i < sTargetedUnits.length; i++) {
                                targetScope.push(sTargetedUnits[i]);
                            }
                        } else {
                            for (var i = 0; i < allDefenseUnits.length; i++) {
                                targetScope.push(allDefenseUnits[i]);
                            }
                        }
                        // checking which units can be attacked by any attacking unit. defaults (ranged units) can attack anything
                        var viableTargets = [];
                        for (var tempTarget = 0; tempTarget < targetScope.length; tempTarget++) {
                            // ALTERNATIVE: add viable targets property to referenceCards object
                            if (referenceCards[targetScope[tempTarget]].currentHP > 0) {
                                // FUTURE FIX: may need reworking for futureproofing
                                switch (referenceCards[priorityAttackUnits[attacker]].name) {
                                    case 'Atlesian Bomb Drones':
                                        if (referenceCards[targetScope[tempTarget]].type === 0 || referenceCards[targetScope[tempTarget]].type === 3 || (referenceCards[targetScope[tempTarget]].type === 5 && territoryStateInfo[sTargetTerID].type === 0)) {
                                            viableTargets.push(targetScope[tempTarget]);
                                            break;
                                        }
                                    case 'Unstable Dust Ships':
                                        if (referenceCards[targetScope[tempTarget]].type === 1 || referenceCards[targetScope[tempTarget]].type === 4 || (referenceCards[targetScope[tempTarget]].type === 5 && territoryStateInfo[sTargetTerID].type === 1)) {
                                            viableTargets.push(targetScope[tempTarget]);
                                            break;
                                        }
                                    default: viableTargets.push(targetScope[tempTarget]);
                                }
                            }
                        }
                        // applying damage and updating health bars
                        for (var tempTarget = 0; tempTarget < viableTargets.length; tempTarget++) {
                            var tempCanBeAttacked = true;
                            for (var TP = 0; TP < trappingPit.length; TP++) {
                                if (trappingPit[TP].unitID === viableTargets[tempTarget] && referenceCards[priorityAttackUnits[attacker]].hasOwnProperty('ranged') === false && referenceCards[priorityAttackUnits[attacker]].type === 0) {
                                    tempCanBeAttacked = false;
                                    break;
                                }
                            }
                            if (tempCanBeAttacked === true) {
                                var itemInClass = territoryStateInfo[sTargetTerID].occupiedByUnits.indexOf(viableTargets[tempTarget]);
                                var damageMultiplier = 1;
                                if (firstTrap !== -1 && referenceCards[firstTrap].name === 'Abanea Trenchdiggers' && referenceCards[viableTargets[tempTarget]].type === 0 && referenceCards[priorityAttackUnits[attacker]].type === 0) {
                                    damageMultiplier = damageMultiplier * 0.5;
                                }
                                for (var ld = 0; ld < liquidDeath.length; ld++) {
                                    if (liquidDeath[ld].unitID === priorityAttackUnits[attacker] && referenceCards[viableTargets[tempTarget]].hasOwnProperty('ranged') === false && referenceCards[viableTargets[tempTarget]].type === 0) {
                                        damageMultiplier = damageMultiplier * 2;
                                    }
                                }
                                referenceCards[viableTargets[tempTarget]].currentHP = referenceCards[viableTargets[tempTarget]].currentHP - (referenceCards[priorityAttackUnits[attacker]].attack / 10 / viableTargets.length * damageMultiplier);
                                if (referenceCards[viableTargets[tempTarget]].currentHP <= 0) {
                                    document.getElementById('combatUnits').getElementsByClassName('combatDefenders')[0].getElementsByClassName('currentHealthBar')[itemInClass].style.width = 0 + '%';
                                } else {
                                    document.getElementById('combatUnits').getElementsByClassName('combatDefenders')[0].getElementsByClassName('currentHealthBar')[itemInClass].style.width = (referenceCards[viableTargets[tempTarget]].currentHP / referenceCards[viableTargets[tempTarget]].maxHP) * 100 + '%';
                                }
                            }
                            
                        }
                    }
                }
                for (var defender = 0; defender < priorityDefenseUnits.length; defender++) {
                    var tempCanAttack = true;
                    for (var FDB = 0; FDB < frostDustBombs.length; FDB++) {
                        if (frostDustBombs[FDB].unitID === priorityDefenseUnits[defender]) {
                            tempCanAttack = false;
                        }
                    }
                    for (var RM = 0; RM < rustingMists.length; RM++) {
                        if (rustingMists[RM].unitID === priorityDefenseUnits[defender]) {
                            tempCanAttack = false;
                        }
                    }
                    for (var TP = 0; TP < trappingPit.length; TP++) {
                        if (trappingPit[TP].unitID === priorityDefenseUnits[defender]) {
                            tempCanAttack = false;
                        }
                    }
                    if (tempCanAttack === true) {
                        var viableTargets = [];
                        for (var tempTarget = 0; tempTarget < allAttackUnits.length; tempTarget++) {
                            if (referenceCards[allAttackUnits[tempTarget]].currentHP > 0) {
                                switch (referenceCards[priorityDefenseUnits[defender]].name) {
                                    case 'Atlesian Bomb Drones':
                                        if (referenceCards[allAttackUnits[tempTarget]].type === 0 || referenceCards[allAttackUnits[tempTarget]].type === 3 || (referenceCards[allAttackUnits[tempTarget]].type === 5 && territoryStateInfo[sActiveTerID].type === 0)) {
                                            viableTargets.push(allAttackUnits[tempTarget]);
                                            break;
                                        }
                                    case 'Unstable Dust Ships':
                                        if (referenceCards[allAttackUnits[tempTarget]].type === 1 || referenceCards[allAttackUnits[tempTarget]].type === 4 || (referenceCards[allAttackUnits[tempTarget]].type === 5 && territoryStateInfo[sActiveTerID].type === 1)) {
                                            viableTargets.push(allAttackUnits[tempTarget]);
                                            break;
                                        }
                                    default: viableTargets.push(allAttackUnits[tempTarget]);
                                }
                            }
                        }
                        for (var tempTarget = 0; tempTarget < viableTargets.length; tempTarget++) {
                            var tempCanBeAttacked = true;
                            for (var TP = 0; TP < trappingPit.length; TP++) {
                                if (trappingPit[TP].unitID === viableTargets[tempTarget] && referenceCards[priorityDefenseUnits[defender]].hasOwnProperty('ranged') === false && referenceCards[priorityDefenseUnits[defender]].type === 0) {
                                    tempCanBeAttacked = false;
                                    break;
                                }
                            }
                            if (tempCanBeAttacked === true) {
                                var damageMultiplier = 1;
                                for (var ld = 0; ld < liquidDeath.length; ld++) {
                                    if (liquidDeath[ld].unitID === priorityDefenseUnits[defender] && referenceCards[viableTargets[tempTarget]].hasOwnProperty('ranged') === false && referenceCards[viableTargets[tempTarget]].type === 0) {
                                        damageMultiplier = damageMultiplier * 2;
                                    }
                                }
                                var itemInClass = attackingUnits.indexOf(viableTargets[tempTarget]);
                                referenceCards[viableTargets[tempTarget]].currentHP = referenceCards[viableTargets[tempTarget]].currentHP - (referenceCards[allDefenseUnits[defender]].attack / 10 / viableTargets.length * damageMultiplier);
                                if (referenceCards[viableTargets[tempTarget]].currentHP <= 0) {
                                    document.getElementById('combatUnits').getElementsByClassName('combatAttackers')[0].getElementsByClassName('currentHealthBar')[itemInClass].style.width = 0 + '%';
                                } else {
                                    document.getElementById('combatUnits').getElementsByClassName('combatAttackers')[0].getElementsByClassName('currentHealthBar')[itemInClass].style.width = (referenceCards[viableTargets[tempTarget]].currentHP / referenceCards[viableTargets[tempTarget]].maxHP) * 100 + '%';
                                }
                            }
                        }
                    }
                }
                for (var attacker = 0; attacker < allAttackUnits.length; attacker++) {
                    if (referenceCards[allAttackUnits[attacker]].currentHP <= 0) {
                        for (var ld = 0; ld < liquidDeath.length; ld++) {
                            if (liquidDeath[ld].unitID === allAttackUnits[attacker]) {
                                liquidDeath.splice(ld, 1);
                            }
                        }
                        for (var fdb = 0; fdb < frostDustBombs.length; fdb++) {
                            if (frostDustBombs[fdb].unitID === allAttackUnits[attacker]) {
                                frostDustBombs.splice(fdb, 1);
                            }
                        }
                        for (var rm = 0; rm < rustingMists.length; rm++) {
                            if (rustingMists[rm].unitID === allAttackUnits[attacker]) {
                                rustingMists.splice(rm, 1);
                            }
                        }
                        for (var tp = 0; tp < trappingPit.length; tp++) {
                            if (trappingPit[tp].unitID === allAttackUnits[attacker]) {
                                trappingPit.splice(tp, 1);
                            }
                        }
                        if (priorityAttackUnits.indexOf(allAttackUnits[attacker]) !== -1) {
                            priorityAttackUnits.splice(priorityAttackUnits.indexOf(allAttackUnits[attacker]), 1);
                        }
                        if (nonPriorityAttackUnits.indexOf(allAttackUnits[attacker]) !== -1) {
                            nonPriorityAttackUnits.splice(nonPriorityAttackUnits.indexOf(allAttackUnits[attacker]), 1);
                        }
                        allAttackUnits.splice(allAttackUnits.indexOf(allAttackUnits[attacker]), 1);
                        attacker--;
                    }
                }
                for (var defender = 0; defender < allDefenseUnits.length; defender++) {
                    if (referenceCards[allDefenseUnits[defender]].currentHP <= 0) {
                        for (var ld = 0; ld < liquidDeath.length; ld++) {
                            if (liquidDeath[ld].unitID === allDefenseUnits[attacker]) {
                                liquidDeath.splice(ld, 1);
                            }
                        }
                        for (var fdb = 0; fdb < frostDustBombs.length; fdb++) {
                            if (frostDustBombs[fdb].unitID === allDefenseUnits[defender]) {
                                frostDustBombs.splice(fdb, 1);
                            }
                        }
                        for (var rm = 0; rm < rustingMists.length; rm++) {
                            if (rustingMists[rm].unitID === allDefenseUnits[defender]) {
                                rustingMists.splice(rm, 1);
                            }
                        }
                        for (var tp = 0; tp < trappingPit.length; tp++) {
                            if (trappingPit[tp].unitID === allDefenseUnits[defender]) {
                                trappingPit.splice(tp, 1);
                            }
                        }
                        if (sTargetedUnits.indexOf(allDefenseUnits[defender]) !== -1) {
                            sTargetedUnits.splice(sTargetedUnits.indexOf(allDefenseUnits[defender]), 1);
                        }
                        if (priorityDefenseUnits.indexOf(allDefenseUnits[defender]) !== -1) {
                            priorityDefenseUnits.splice(priorityDefenseUnits.indexOf(allDefenseUnits[defender]), 1);
                        }
                        if (nonPriorityDefenseUnits.indexOf(allDefenseUnits[defender]) !== -1) {
                            nonPriorityDefenseUnits.splice(nonPriorityDefenseUnits.indexOf(allDefenseUnits[defender]), 1);
                        }
                        allDefenseUnits.splice(allDefenseUnits.indexOf(allDefenseUnits[defender]), 1);
                        defender--;
                        enemyUnitKilled = true;
                        lastPlayerVictory = defendingPlayer;
                    }
                }
                if (pIteration >= 10) {
                    window.clearInterval(priorityInterval);
                }
            }, (100 * combatSpeed));
        }
        setTimeout(function() {
            var iteration = 0;
            var nonPriorityInterval = setInterval(function() {
                iteration++;
                for (var i = 0; i < allAttackUnits.length; i++) {
                    if (Math.round(referenceCards[allAttackUnits[i]].currentHP) <= 0) {
                        territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(allAttackUnits[i]), 1);
                        allAttackUnits.splice(allAttackUnits.indexOf(allAttackUnits[i]), 1);
                        i--;
                    }
                }
                for (var i = 0; i < allDefenseUnits.length; i++) {
                    if (Math.round(referenceCards[allDefenseUnits[i]].currentHP) <= 0) {
                        allDefenseUnits.splice(allDefenseUnits.indexOf(allDefenseUnits[i]), 1);
                        sTargetedUnits.splice(sTargetedUnits.indexOf(allDefenseUnits[i]), 1);
                        i--;
                    }
                }
                // non-priority round
                console.log('iteration ' + iteration);
                for (var attacker = 0; attacker < nonPriorityAttackUnits.length; attacker++) {
                    var tempCanAttack = true;
                    for (var FDB = 0; FDB < frostDustBombs.length; FDB++) {
                        if (frostDustBombs[FDB].unitID === nonPriorityAttackUnits[attacker]) {
                            tempCanAttack = false;
                        }
                    }
                    for (var RM = 0; RM < rustingMists.length; RM++) {
                        if (rustingMists[RM].unitID === nonPriorityAttackUnits[attacker]) {
                            tempCanAttack = false;
                        }
                    }
                    for (var TP = 0; TP < trappingPit.length; TP++) {
                        if (trappingPit[TP].unitID === nonPriorityAttackUnits[attacker]) {
                            tempCanAttack = false;
                        }
                    }
                    if (tempCanAttack === true) {
                        // checking every iteration whether there are actually any walls or sTargetedUnits left or if they should attack all (remaining) units
                        var targetScope = [];
                        var hasWall = false;
                        for (var i = 0; i < allDefenseUnits.length; i++) {
                            if (referenceCards[allDefenseUnits[i]].name === 'Wall') {
                                hasWall = true;
                                break;
                            }
                        }
                        if (hasWall === false) {
                            for (var wall = 0; wall < document.getElementById('combatUnits').getElementsByTagName('tr').length; wall++) {
                                document.getElementById('combatUnits').getElementsByTagName('tr')[wall].getElementsByTagName('td')[0].innerHTML = '';
                            }
                        }
                        if (hasWall === true) {
                            for (var i = 0; i < allDefenseUnits.length; i++) {
                                if (referenceCards[allDefenseUnits[i]].name === 'Wall') {
                                    targetScope.push(allDefenseUnits[i]);
                                }
                            }
                        } else if (sTargetedUnits.length > 0) {
                            for (var i = 0; i < sTargetedUnits.length; i++) {
                                targetScope.push(sTargetedUnits[i]);
                            }
                        } else {
                            for (var i = 0; i < allDefenseUnits.length; i++) {
                                targetScope.push(allDefenseUnits[i]);
                            }
                        }
                        var viableTargets = [];
                        for (var tempTarget = 0; tempTarget < targetScope.length; tempTarget++) {
                            // ALTERNATIVE: add viable targets property to referenceCards object
                            if (referenceCards[targetScope[tempTarget]].currentHP > 0) {
                                switch(referenceCards[nonPriorityAttackUnits[attacker]].type) {
                                    case 0:
                                        if (referenceCards[targetScope[tempTarget]].type === 0 || referenceCards[targetScope[tempTarget]].type === 3 || (referenceCards[targetScope[tempTarget]].type === 5 && territoryStateInfo[sTargetTerID].type === 0)) {
                                            viableTargets.push(targetScope[tempTarget]);
                                            break;
                                        }
                                    case 1:
                                        if (referenceCards[targetScope[tempTarget]].type === 1 || referenceCards[targetScope[tempTarget]].type === 4 || (referenceCards[targetScope[tempTarget]].type === 5 && territoryStateInfo[sTargetTerID].type === 1)) {
                                            viableTargets.push(targetScope[tempTarget]);
                                            break;
                                        }
                                    case 2:
                                        viableTargets.push(targetScope[tempTarget]);
                                        break;
                                    case 3:
                                        viableTargets.push(targetScope[tempTarget]);
                                        break;
                                    case 4:
                                        if (referenceCards[targetScope[tempTarget]].type === 1 || referenceCards[targetScope[tempTarget]].type === 4 || (referenceCards[targetScope[tempTarget]].type === 5 && territoryStateInfo[sTargetTerID].type === 1)) {
                                            viableTargets.push(targetScope[tempTarget]);
                                            break;
                                        }
                                    case 5:
                                        if (referenceCards[targetScope[tempTarget]].type !== 2) {
                                            viableTargets.push(targetScope[tempTarget]);
                                            break;
                                        }
                                }
                            }
                        }
                        for (var tempTarget = 0; tempTarget < viableTargets.length; tempTarget++) {
                            var tempCanBeAttacked = true;
                            for (var TP = 0; TP < trappingPit.length; TP++) {
                                if (trappingPit[TP].unitID === viableTargets[tempTarget] && referenceCards[viableTargets[tempTarget]].hasOwnProperty('ranged') !== true && referenceCards[viableTargets[tempTarget]].type === 0) {
                                    tempCanBeAttacked = false;
                                    break;
                                }
                            }
                            if (tempCanBeAttacked === true) {
                                var itemInClass = allDefenseUnits.indexOf(viableTargets[tempTarget]);
                                var damageMultiplier = 1;
                                if (firstTrap !== -1 && referenceCards[firstTrap].name === 'Abanea Trenchdiggers' && referenceCards[viableTargets[tempTarget]].type === 0 && referenceCards[nonPriorityAttackUnits[attacker]].type === 0) {
                                    damageMultiplier = damageMultiplier * 0.5;
                                }
                                for (var ld = 0; ld < liquidDeath.length; ld++) {
                                    if (liquidDeath[ld].unitID === nonPriorityAttackUnits[attacker] && referenceCards[viableTargets[tempTarget]].hasOwnProperty('ranged') === false && referenceCards[viableTargets[tempTarget]].type === 0) {
                                        damageMultiplier = damageMultiplier * 2;
                                    }
                                }
                                referenceCards[viableTargets[tempTarget]].currentHP = referenceCards[viableTargets[tempTarget]].currentHP - (referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[attacker]].attack / 10 / viableTargets.length * damageMultiplier);
                                if (referenceCards[viableTargets[tempTarget]].currentHP <= 0) {
                                    document.getElementById('combatUnits').getElementsByClassName('combatDefenders')[0].getElementsByClassName('currentHealthBar')[itemInClass].style.width = 0 + '%';
                                } else {
                                    document.getElementById('combatUnits').getElementsByClassName('combatDefenders')[0].getElementsByClassName('currentHealthBar')[itemInClass].style.width = (referenceCards[allDefenseUnits[itemInClass]].currentHP / referenceCards[allDefenseUnits[itemInClass]].maxHP) * 100 + '%';
                                }
                            }
                        }
                    }
                }
                for (var defender = 0; defender < nonPriorityDefenseUnits.length; defender++) {
                    var tempCanAttack = true;
                    for (var FDB = 0; FDB < frostDustBombs.length; FDB++) {
                        if (frostDustBombs[FDB].unitID === nonPriorityDefenseUnits[defender]) {
                            tempCanAttack = false;
                        }
                    }
                    for (var RM = 0; RM < rustingMists.length; RM++) {
                        if (rustingMists[RM].unitID === nonPriorityDefenseUnits[defender]) {
                            tempCanAttack = false;
                        }
                    }
                    for (var TP = 0; TP < trappingPit.length; TP++) {
                        if (trappingPit[TP].unitID === nonPriorityDefenseUnits[defender]) {
                            tempCanAttack = false;
                        }
                    }
                    if (tempCanAttack === true) {
                        var viableTargets = [];
                        for (var tempTarget = 0; tempTarget < allAttackUnits.length; tempTarget++) {
                            // ALTERNATIVE: add viable targets property to referenceCards object
                            if (referenceCards[allAttackUnits[tempTarget]].currentHP > 0) {
                                switch(referenceCards[nonPriorityDefenseUnits[defender]].type) {
                                    case 0:
                                        if (referenceCards[allAttackUnits[tempTarget]].type === 0 || referenceCards[allAttackUnits[tempTarget]].type === 3 || (referenceCards[allAttackUnits[tempTarget]].type === 5 && territoryStateInfo[sActiveTerID].type === 0)) {
                                            viableTargets.push(allAttackUnits[tempTarget]);
                                            break;
                                        }
                                    case 1:
                                        if (referenceCards[allAttackUnits[tempTarget]].type === 1 || referenceCards[allAttackUnits[tempTarget]].type === 4 || (referenceCards[allAttackUnits[tempTarget]].type === 5 && territoryStateInfo[sActiveTerID].type === 1)) {
                                            viableTargets.push(allAttackUnits[tempTarget]);
                                            break;
                                        }
                                    case 2:
                                        viableTargets.push(allAttackUnits[tempTarget]);
                                            break;
                                    case 3:
                                        viableTargets.push(allAttackUnits[tempTarget]);
                                            break;
                                    case 4:
                                        if (referenceCards[allAttackUnits[tempTarget]].type === 1 || referenceCards[allAttackUnits[tempTarget]].type === 4 || (referenceCards[allAttackUnits[tempTarget]].type === 5 && territoryStateInfo[sActiveTerID].type === 1)) {
                                            viableTargets.push(allAttackUnits[tempTarget]);
                                            break;
                                        }
                                    case 5:
                                        if (referenceCards[allAttackUnits[tempTarget]].type !== 2) {
                                            viableTargets.push(allAttackUnits[tempTarget]);
                                            break;
                                        }
                                }
                            }
                        }
                        for (var tempTarget = 0; tempTarget < viableTargets.length; tempTarget++) {
                            var tempCanBeAttacked = true;
                            for (var TP = 0; TP < trappingPit.length; TP++) {
                                if (trappingPit[TP].unitID === viableTargets[tempTarget] && referenceCards[viableTargets[tempTarget]].hasOwnProperty('ranged') !== true && referenceCards[viableTargets[tempTarget]].type === 0) {
                                    tempCanBeAttacked = false;
                                    break;
                                }
                            }
                            if (tempCanBeAttacked === true) {
                                var damageMultiplier = 1;
                                for (var ld = 0; ld < liquidDeath.length; ld++) {
                                    if (liquidDeath[ld].unitID === nonPriorityDefenseUnits[defender] && referenceCards[viableTargets[tempTarget]].hasOwnProperty('ranged') === false && referenceCards[viableTargets[tempTarget]].type === 0) {
                                        damageMultiplier = damageMultiplier * 2;
                                    }
                                }
                                var itemInClass = allAttackUnits.indexOf(viableTargets[tempTarget]);
                                referenceCards[viableTargets[tempTarget]].currentHP = referenceCards[viableTargets[tempTarget]].currentHP - (referenceCards[allDefenseUnits[defender]].attack / 10 / viableTargets.length * damageMultiplier);
                                if (referenceCards[viableTargets[tempTarget]].currentHP <= 0) {
                                    document.getElementById('combatUnits').getElementsByClassName('combatAttackers')[0].getElementsByClassName('currentHealthBar')[itemInClass].style.width = 0 + '%';
                                } else {
                                    document.getElementById('combatUnits').getElementsByClassName('combatAttackers')[0].getElementsByClassName('currentHealthBar')[itemInClass].style.width = (referenceCards[allAttackUnits[itemInClass]].currentHP / referenceCards[allAttackUnits[itemInClass]].maxHP) * 100 + '%';
                                }
                            }
                        }
                    }
                }
                if (firstTrap !== -1 && referenceCards[firstTrap].name === 'Grimm Attack') {
                    for (var attacker = 0; attacker < allAttackUnits.length; attacker++) {
                        referenceCards[allAttackUnits[attacker]].currentHP = referenceCards[allAttackUnits[attacker]].currentHP - 10;
                    }
                    for (var defender = 0; defender < allDefenseUnits.length; defender++) {
                        referenceCards[allDefenseUnits[defender]].currentHP = referenceCards[allDefenseUnits[defender]].currentHP - 10;
                    }
                }
                for (var attacker = 0; attacker < allAttackUnits.length; attacker++) {
                    if (referenceCards[allAttackUnits[attacker]].currentHP <= 0) {
                        for (var fdb = 0; fdb < frostDustBombs.length; fdb++) {
                            if (frostDustBombs[fdb].unitID === allAttackUnits[attacker]) {
                                frostDustBombs.splice(fdb, 1);
                            }
                        }
                        for (var ld = 0; ld < liquidDeath.length; ld++) {
                            if (liquidDeath[ld].unitID === allAttackUnits[attacker]) {
                                liquidDeath.splice(ld, 1);
                            }
                        }
                        for (var rm = 0; rm < rustingMists.length; rm++) {
                            if (rustingMists[rm].unitID === allAttackUnits[attacker]) {
                                rustingMists.splice(rm, 1);
                            }
                        }
                        for (var tp = 0; tp < trappingPit.length; tp++) {
                            if (trappingPit[tp].unitID === allAttackUnits[attacker]) {
                                trappingPit.splice(tp, 1);
                            }
                        }
                        if (priorityAttackUnits.indexOf(allAttackUnits[attacker]) !== -1) {
                            priorityAttackUnits.splice(priorityAttackUnits.indexOf(allAttackUnits[attacker]), 1);
                        }
                        if (nonPriorityAttackUnits.indexOf(allAttackUnits[attacker]) !== -1) {
                            nonPriorityAttackUnits.splice(nonPriorityAttackUnits.indexOf(allAttackUnits[attacker]), 1);
                        }
                        allAttackUnits.splice(allAttackUnits.indexOf(allAttackUnits[attacker]), 1);
                        attacker--;
                    }
                }
                for (var defender = 0; defender < allDefenseUnits.length; defender++) {
                    if (referenceCards[allDefenseUnits[defender]].currentHP <= 0) {
                        for (var fdb = 0; fdb < frostDustBombs.length; fdb++) {
                            if (frostDustBombs[fdb].unitID === allDefenseUnits[defender]) {
                                frostDustBombs.splice(fdb, 1);
                            }
                        }
                        for (var ld = 0; ld < liquidDeath.length; ld++) {
                            if (liquidDeath[ld].unitID === allDefenseUnits[defender]) {
                                liquidDeath.splice(ld, 1);
                            }
                        }
                        for (var rm = 0; rm < rustingMists.length; rm++) {
                            if (rustingMists[rm].unitID === allDefenseUnits[defender]) {
                                rustingMists.splice(rm, 1);
                            }
                        }
                        for (var tp = 0; tp < trappingPit.length; tp++) {
                            if (trappingPit[tp].unitID === allDefenseUnits[defender]) {
                                trappingPit.splice(tp, 1);
                            }
                        }
                        if (sTargetedUnits.indexOf(allDefenseUnits[defender]) !== -1) {
                            sTargetedUnits.splice(sTargetedUnits.indexOf(allDefenseUnits[defender]), 1);
                        }
                        if (priorityDefenseUnits.indexOf(allDefenseUnits[defender]) !== -1) {
                            priorityDefenseUnits.splice(priorityDefenseUnits.indexOf(allDefenseUnits[defender]), 1);
                        }
                        if (nonPriorityDefenseUnits.indexOf(allDefenseUnits[defender]) !== -1) {
                            nonPriorityDefenseUnits.splice(nonPriorityDefenseUnits.indexOf(allDefenseUnits[defender]), 1);
                        }
                        allDefenseUnits.splice(allDefenseUnits.indexOf(allDefenseUnits[defender]), 1);
                        defender--;
                        enemyUnitKilled = true;
                        lastPlayerVictory = defendingPlayer;
                    }
                }
                if (iteration >= 10) {
                    window.clearInterval(nonPriorityInterval);
                }
            }, (100 * combatSpeed));
        }, (((1000 * priorityround) + 500) * combatSpeed));
        setTimeout(function() {
            for (var i = 0; i < territoryStateInfo[sActiveTerID].occupiedByUnits.length; i++) {
                if (Math.round(referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[i]].currentHP) <= 0) {
                    territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[i]), 1);
                    i--;
                }
            }
            for (var i = 0; i < territoryStateInfo[sTargetTerID].occupiedByUnits.length; i++) {
                if (Math.round(referenceCards[territoryStateInfo[sTargetTerID].occupiedByUnits[i]].currentHP) <= 0) {
                    territoryStateInfo[sTargetTerID].occupiedByUnits.splice(territoryStateInfo[sTargetTerID].occupiedByUnits.indexOf(territoryStateInfo[sTargetTerID].occupiedByUnits[i]), 1);
                    i--;
                }
            }
            refreshTerStateVisuals(sActiveTerID);
            refreshTerStateVisuals(sTargetTerID);
            if (playerNumber === attackingPlayer && enemyUnitKilled === true && spoilsOfWar[defendingPlayer] > 0) {
                spoilsOfWar[defendingPlayer]--;
                chooseSpoilsOfWar(defendingPlayer);
            }
            // clearing selections
            for (var item = 0; item < territoryStateInfo[sActiveTerID].occupiedByUnits.length; item++) {
                $('#terUnitInfo' + item).remove();
                document.getElementById('terUnitTooltip' + item).remove();
            }
            hideCombat();
            if (playerNumber === attackingPlayer) {
                activeTer = -1;
                hasRanged = -1;
                refreshInteractibility();
                document.getElementById('terGenInfo').innerHTML = '';
                document.getElementById('terUnitInfo').innerHTML = '';
            }
        }, (((1000 * priorityround) + 2100) * combatSpeed));
    }
	function chooseSpoilsOfWar(tempTargetPlayer) {
		$('#spoilsOfWarPlayerImage').attr('src', kingdomPicArray[kingdom[tempTargetPlayer]]);
		$('#spoilsOfWarPlayer').unbind('click');
		$('#spoilsOfWarDrawPile').unbind('click');
		$('#spoilsOfWarPlayer').click(function() {
			drawRandomFromPlayer(tempTargetPlayer, 1);
		});
		$('#spoilsOfWarDrawPile').click(function() {
			altCardPiles[((playerNumber * 3) + 1)].push(drawPile[0]);
			drawPile.splice(0,1);
            nOfCards[4]--;
			nOfCards[playerNumber]++;
            // socket.emit('draw spoils', GRID, playerNumber, -1, -1);
			if (nOfCards[playerNumber] > 8) {
				createDiscardVisuals();
			} else {
				createCardVisuals(tempCardID);
			}
		});
		showSpoilsOfWar();
	}

	function applyUtility(viableUtilityTargets) {
		console.log('applyUtility()');
        var tempSelected = false;
		document.getElementById('utilityTable').innerHTML = '';
		for (var unit = 0; unit < viableUtilityTargets.length; unit++) {
			var r1 = document.getElementById('utilityTable').insertRow(unit);
			r1.onclick = function() {
				if (activeCard !== -1 && tempSelected === false) {
                    tempSelected = true;
                    var tempUnitID = viableUtilityTargets[this.rowIndex];
                    // socket.emit('apply utility', GRID, playerNumber, activeCard, tempUnitID);
					referenceCards[tempUnitID].appliedEffects.push(activeCard);
                    displayTargetCard('Commander ' + commName[playerTurn] + ' applies ' + referenceCards[tempUnitID] + ' to ' + referenceCards[activeCard].name, tempUnitID);
					$('#cardImage' + (altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1)).removeClass('selected');
					altCardPiles[((playerNumber * 3) + 2)].push(activeCard);
					switch(referenceCards[activeCard].name) {
						case 'Concentrated Dust':
							referenceCards[tempUnitID].attack = referenceCards[tempUnitID].attack + 10;
                            document.getElementById('singleCardVisualsAttack').style.color = '#00c800';
							break;
						case 'First Aid':
							if ((referenceCards[tempUnitID].currentHP + 20) > referenceCards[tempUnitID].maxHP) {
								referenceCards[tempUnitID].currentHP = referenceCards[tempUnitID].maxHP;
							} else {
								referenceCards[tempUnitID].currentHP = referenceCards[tempUnitID].currentHP + 20;
							}
                            document.getElementById('singleCardVisualsHP').style.color = '#00c800';
							break;
						case 'Infused Armor':
							referenceCards[tempUnitID].maxHP = referenceCards[tempUnitID].maxHP + 15;
							referenceCards[tempUnitID].currentHP = referenceCards[tempUnitID].currentHP + 15;
							referenceCards[tempUnitID].mechanical = 1;
                            document.getElementById('singleCardVisualsHP').style.color = '#00c800';
                            document.getElementById('singleCardVisualsMechanical').style.color = '#00c800';
							break;
						case 'Naval Ram':
							referenceCards[tempUnitID].attack = referenceCards[tempUnitID].attack + 10;
                            document.getElementById('singleCardVisualsAttack').style.color = '#00c800';
							break;
						case 'Perimeter Defenses ':
							referenceCards[tempUnitID].attack = referenceCards[tempUnitID].attack + 5;
                            document.getElementById('singleCardVisualsAttack').style.color = '#00c800';
							break;
						case 'Prototype Weaponry':
							referenceCards[tempUnitID].attack = referenceCards[tempUnitID].attack + 10;
                            document.getElementById('singleCardVisualsAttack').style.color = '#00c800';
							break;
						case 'Reinforce Structure':
							referenceCards[tempUnitID].maxHP = referenceCards[tempUnitID].maxHP + 10;
							referenceCards[tempUnitID].currentHP = referenceCards[tempUnitID].currentHP + 10;
                            document.getElementById('singleCardVisualsHP').style.color = '#00c800';
							break;
						case 'Silver Eyes': break;
						case 'Thruster Packs':
                            // TO DO: figure out how to best add/remove Flying to/from description
							referenceCards[tempUnitID].type = 2;
                            // document.getElementById('singleCardVisualsDescription').style.color = '#00c800';
							break;
					}
					hideUtilityApplier();
					for (var ter = 0; ter < territoryStateInfo.length; ter++) {
						$('#territoryArea' + ter).removeClass('viableTarget');
					}
					refreshInteractibility();
				}
			}
			r1.onmouseover = function() {
				document.getElementById('cardPreviewArea').style.backgroundColor = kingdomColorArray[playerNumber];
			}
			r1.onmouseout = function() {
				document.getElementById('cardPreviewArea').style.backgroundColor = 'transparent';
			}
			var cName = r1.insertCell(0);
			$(cName).addClass('utilityName');
			cName.style.paddingLeft = '1%';
			var cHealth = r1.insertCell(1);
			var cEffects = r1.insertCell(2);
			cName.innerHTML = referenceCards[viableUtilityTargets[unit]].name;
			cHealth.innerHTML = '<div class="maxHealthBar"><div class="currentHealthBar"></div></div>';
			cHealth.getElementsByClassName('maxHealthBar')[unit].getElementsByClassName('currentHealthBar')[0].style.width = ((referenceCards[viableUtilityTargets[unit]].currentHP / referenceCards[viableUtilityTargets[unit]].maxHP) * 100) + '%';
			// FUTURE FIX: fix image size
			// FUTURE FIX: add hover to show card details
			var t = document.createElement('table');
			t.className = 'utilityEffects';
			// document.getElementsByClassName('utilityEffects')[unit].innerHTML = '';
			var rowCellWidth = 5;
			for (var row = 0; row < Math.ceil(referenceCards[viableUtilityTargets[unit]].appliedEffects.length / rowCellWidth); row++) {
				var r2 = t.insertRow(row);
				var tempCellCount = referenceCards[viableUtilityTargets[unit]].appliedEffects.length - (row * rowCellWidth);
				if (tempCellCount > 5) {
					tempCellCount = 5;
				}
				for (var cell = 0; cell < tempCellCount; cell++) {
					var cEffectImage = r2.insertCell(cell);
					cEffectImage.style.width = '20%';
					var img = document.createElement('img');
					img.src = referenceCards[referenceCards[viableUtilityTargets[unit]].appliedEffects[(row * rowCellWidth) + cell]].image;
					img.style.width = '100%';
					img.style.height = 'auto';
					cEffectImage.appendChild(img);
				}
			}
			cEffects.appendChild(t);
		}
		// FUTURE FIX: close button does not appear
		showUtilityApplier();
		document.getElementById('utilityApplier').style.marginLeft = '-' + (document.getElementById('utilityApplier').offsetWidth / 2) + 'px';
		document.getElementById('utilityApplier').style.marginTop = (window.innerHeight / 2) - (document.getElementById('utilityApplier').offsetHeight / 2) + 'px';
	}
	function applyNH(terID) {
		console.log('applyNH()');
        // socket.emit('apply nh', GRID, playerNumber, activeCard, terID);
		territoryStateInfo[terID].naturalHazardIDs.push(activeCard);
		$('#cardImage' + (altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1)).removeClass('selected');
		altCardPiles[((playerNumber * 3) + 2)].push(activeCard);
        refreshTerStateVisuals(terID);
	}

	function createDiscardVisuals() {
        // socket.emit('wait for discard', GRID, playerNumber);
		var tempCardID = altCardPiles[((playerNumber * 3) + 1)][8];
		document.getElementById('discardVisualsName').innerHTML = referenceCards[tempCardID].name;
		if (referenceCards[tempCardID].hasOwnProperty('trainingTime')) {
			document.getElementById('discardVisualsDuration').innerHTML = referenceCards[tempCardID].trainingTime + 'TR';
		} else if (referenceCards[tempCardID].hasOwnProperty('duration')) {
			switch (referenceCards[tempCardID].duration) {
				case 0: break;
				case 999: document.getElementById('discardVisualsDuration').innerHTML = 'Perm.'; break;
				default: document.getElementById('discardVisualsDuration').innerHTML = referenceCards[tempCardID].duration + 'TR'; break;
			}
		}
		if (referenceCards[tempCardID].cardType === 0) {
			document.getElementById('discardVisualsSpeed').innerHTML = referenceCards[tempCardID].maxSpeed + 'SP';
		}
		if (referenceCards[tempCardID].cardType === 0) {
			document.getElementById('discardVisualsAttack').innerHTML = referenceCards[tempCardID].attack + 'ATK';
		}
		if (referenceCards[tempCardID].cardType === 0) {
			document.getElementById('discardVisualsHP').innerHTML = referenceCards[tempCardID].maxHP + 'HP';
		}
		document.getElementById('discardVisualsImage').src = referenceCards[tempCardID].image;
		if (referenceCards[tempCardID].cardType === 0) {
			switch (referenceCards[tempCardID].size) {
				case 0: document.getElementById('discardVisualsSizeType').innerHTML = 'Unit'; break;
				case 1: document.getElementById('discardVisualsSizeType').innerHTML = 'Large unit'; break;
				case 2: document.getElementById('discardVisualsSizeType').innerHTML = 'Huge unit'; break;
				case 3: document.getElementById('discardVisualsSizeType').innerHTML = 'Colossal unit'; break;
				case 99: document.getElementById('discardVisualsSizeType').innerHTML = 'Structure'; break;
			}
		} else if (referenceCards[tempCardID].cardType === 1) {
			document.getElementById('discardVisualsSizeType').innerHTML = 'Trap';
		} else if (referenceCards[tempCardID].cardType === 2) {
			document.getElementById('discardVisualsSizeType').innerHTML = 'Utility';
		}
		if (referenceCards[tempCardID].cardType === 0) {
			switch (referenceCards[tempCardID].mechanical) {
				case 0: document.getElementById('discardVisualsMechanical').innerHTML = 'Non-Mech.'; break;
				case 1: document.getElementById('discardVisualsMechanical').innerHTML = 'Half-Mech.'; break;
				case 2: document.getElementById('discardVisualsMechanical').innerHTML = 'Full-Mech.'; break;
			}
		}
		document.getElementById('discardVisualsDescription').innerHTML = referenceCards[tempCardID].description;
		showDiscardCard();
	}
	function discardCard(thisButton) {
		var tempButtonIndex = $('.discardButton').index(thisButton);
		if (tempButtonIndex !== 8) {
			clearCardVisuals(tempButtonIndex);
			createCardVisuals(targetCard);
			targetCard = -1;
		} else {
			altCardPiles[((playerNumber * 3) + 1)].splice(8,1);
			nOfCards[playerNumber] = altCardPiles[((playerNumber * 3) + 1)].length;
		}
		hideDiscardCard();
        // socket.emit('no more wait for discard', GRID, playerNumber);
	}
	function drawRandomFromPlayer(tempTargetPlayer, tempPile) {
		console.log('drawRandomFromPlayer()');
		var tempCardIndex = Math.floor(Math.random() * nOfCards[tempTargetPlayer]);
        // socket.emit('draw random from player', GRID, playerNumber, tempTargetPlayer, tempPile, tempCardIndex);
		var tempCardID = altCardPiles[((tempTargetPlayer * 3) + 1)][tempCardIndex];
		altCardPiles[((tempTargetPlayer * 3) + tempPile)].splice(tempCardIndex,1);
		altCardPiles[((playerNumber * 3) + 1)].push(tempCardID);
		nOfCards[tempTargetPlayer] = altCardPiles[((tempTargetPlayer * 3) + 1)].length;
		nOfCards[playerNumber] = altCardPiles[((playerNumber * 3) + 1)].length;
		document.getElementById('player' + tempTargetPlayer + 'Cards').innerHTML = nOfCards[tempTargetPlayer];
		clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1);
		if (nOfCards[playerNumber] > 8) {
			createDiscardVisuals();
		} else {
			createCardVisuals(tempCardID);
		}
	}
	function pickCard() {
		console.log('pickCard()');
		for (var pos = -2; pos < 3; pos++) {
			document.getElementById('carouselVisualsName' + pos).innerHTML = '';
			document.getElementById('carouselVisualsDuration' + pos).innerHTML = '';
			document.getElementById('carouselVisualsSpeed' + pos).innerHTML = '';
			document.getElementById('carouselVisualsAttack' + pos).innerHTML = '';
			document.getElementById('carouselVisualsHP' + pos).innerHTML = '';
			document.getElementById('carouselVisualsImage' + pos).src = '';
			document.getElementById('carouselVisualsSizeType' + pos).innerHTML = '';
			document.getElementById('carouselVisualsMechanical' + pos).innerHTML = '';
			document.getElementById('carouselVisualsDescription' + pos).innerHTML = '';
			var cardIndex = pos + carouselCurrentIndex;
			if (cardIndex < 0 || cardIndex > (viableCards.length - 1)) {
				$('#carouselSelect' + cardIndex).unbind('click');
				document.getElementById('carouselSelect' + pos).style.visibility = 'hidden';
				continue;
			} else {
				document.getElementById('carouselVisualsName' + pos).innerHTML = referenceCards[viableCards[cardIndex]].name;
				if (referenceCards[viableCards[cardIndex]].hasOwnProperty('trainingTime')) {
					document.getElementById('carouselVisualsDuration' + pos).innerHTML = referenceCards[viableCards[cardIndex]].trainingTime + 'T';
				} else if (referenceCards[viableCards[cardIndex]].hasOwnProperty('duration')) {
					switch (referenceCards[viableCards[cardIndex]].duration) {
						case 0: break;
						case 999: document.getElementById('carouselVisualsDuration' + pos).innerHTML = 'Perm.'; break;
						default: document.getElementById('carouselVisualsDuration' + pos).innerHTML = referenceCards[viableCards[cardIndex]].duration + 'T'; break;
					}
				}
				if (referenceCards[viableCards[cardIndex]].cardType === 0) {
					document.getElementById('carouselVisualsSpeed' + pos).innerHTML = referenceCards[viableCards[cardIndex]].maxSpeed + 'SP';
				}
				if (referenceCards[viableCards[cardIndex]].cardType === 0) {
					document.getElementById('carouselVisualsAttack' + pos).innerHTML = referenceCards[viableCards[cardIndex]].attack + 'ATK';
				}
				if (referenceCards[viableCards[cardIndex]].cardType === 0) {
					document.getElementById('carouselVisualsHP' + pos).innerHTML = referenceCards[viableCards[cardIndex]].maxHP + 'HP';
				}
				document.getElementById('carouselVisualsImage' + pos).src = referenceCards[viableCards[cardIndex]].image;
				if (referenceCards[viableCards[cardIndex]].cardType === 0) {
					switch (referenceCards[viableCards[cardIndex]].size) {
						case 0: document.getElementById('carouselVisualsSizeType' + pos).innerHTML = 'Unit'; break;
						case 1: document.getElementById('carouselVisualsSizeType' + pos).innerHTML = 'Large unit'; break;
						case 2: document.getElementById('carouselVisualsSizeType' + pos).innerHTML = 'Huge unit'; break;
						case 3: document.getElementById('carouselVisualsSizeType' + pos).innerHTML = 'Colossal unit'; break;
						case 99: document.getElementById('carouselVisualsSizeType' + pos).innerHTML = 'Structure'; break;
					}
				} else if (referenceCards[viableCards[cardIndex]].cardType === 1) {
					document.getElementById('carouselVisualsSizeType' + pos).innerHTML = 'Trap';
				} else if (referenceCards[viableCards[cardIndex]].cardType === 2) {
					document.getElementById('carouselVisualsSizeType' + pos).innerHTML = 'Utility';
				}
				if (referenceCards[viableCards[cardIndex]].cardType === 0) {
					switch (referenceCards[viableCards[cardIndex]].mechanical) {
						case 0: document.getElementById('carouselVisualsMechanical' + pos).innerHTML = 'Non-Mech.'; break;
						case 1: document.getElementById('carouselVisualsMechanical' + pos).innerHTML = 'Half-Mech.'; break;
						case 2: document.getElementById('carouselVisualsMechanical' + pos).innerHTML = 'Full-Mech.'; break;
					}
				}
				document.getElementById('carouselVisualsDescription' + pos).innerHTML = referenceCards[viableCards[cardIndex]].description;
				$('#carouselSelect' + pos).unbind('click');
				document.getElementById('carouselSelect' + pos).style.visibility = 'visible';
				$('#carouselSelect' + pos).click(
					(function(cardIndex) {
						return function() {
							drawPickedCard(cardIndex);
							hideCardCarousel();
						};
					})(cardIndex)
				);
			}
			switch(carouselCurrentIndex) {
				case 0: document.getElementById('carouselBack').style.visibility = 'hidden'; document.getElementById('carouselForward').style.visibility = 'visible'; break;
				case (viableCards.length - 1): document.getElementById('carouselBack').style.visibility = 'visible'; document.getElementById('carouselForward').style.visibility = 'hidden'; break;
				default: document.getElementById('carouselBack').style.visibility = 'visible'; document.getElementById('carouselForward').style.visibility = 'visible'; break;
			}
		}
	}
	function drawPickedCard(cardIndex) {
		console.log('drawPickedCard()');
        // socket.emit('draw picked card', GRID, playerNumber, targetPlayer, activeCard, viableCards[cardIndex]);
		switch(cardSource) {
			case 0: // player discard pile
				$('#cardImage' + (altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard) + 1)).removeClass('selected');
				clearCardVisuals(altCardPiles[((playerNumber * 3) + 1)].indexOf(activeCard));
				var tempCardIndex = altCardPiles[((targetPlayer * 3) + 3)].indexOf(viableCards[cardIndex]);
				if (nOfCards[playerNumber] > 8) {
					createDiscardVisuals();
				} else {
					createCardVisuals(altCardPiles[((targetPlayer * 3) + 3)][tempCardIndex]);
				}
				altCardPiles[((playerNumber * 3) + 1)].push(altCardPiles[((targetPlayer * 3) + 3)][tempCardIndex]);
				altCardPiles[((targetPlayer * 3) + 3)].splice(tempCardIndex,1);
				nOfCards[targetPlayer] = altCardPiles[((targetPlayer * 3) + 1)].length;
				cardSource = -1;
				break;
			case 1: // player actives (Distraction trap - deletes card instead of drawing it)
				var tempCardIndex = altCardPiles[((targetPlayer * 3) + 2)].indexOf(viableCards[cardIndex]);
				var cardFound = false;
				// FUTURE FIX: reverse all effects of utility
				switch(referenceCards[viableCards[cardIndex]].name) {
					case 'Concentrated Dust':
						for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 2)].length; card++) {
							if (cardFound === true) {
								break;
							}
							if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].cardType === 0) {
								for (var effect = 0; effect < referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
									if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects[effect] === viableCards[cardIndex]) {
										referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].attack = referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].attack - 10;
										cardFound = true;
										break;
									}
								}
							}
						}
                        break;
					case 'Infused Armor':
						for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 2)].length; card++) {
							if (cardFound === true) {
								break;
							}
							if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].cardType === 0) {
								for (var effect = 0; effect < referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
									if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects[effect] === viableCards[cardIndex]) {
										referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].maxHP = referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].maxHP - 15;
										if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].currentHP > referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].maxHP) {
											referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].currentHP = referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].maxHP;
										}
										referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].mechanical = 0;
										cardFound = true;
										break;
									}
								}
							}
						}
                        break;
					case 'Naval Ram':
						for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 2)].length; card++) {
							if (cardFound === true) {
								break;
							}
							if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].cardType === 0) {
								for (var effect = 0; effect < referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
									if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects[effect] === viableCards[cardIndex]) {
										referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].attack = referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].attack - 10;
										cardFound = true;
										break;
									}
								}
							}
						}
                        break;
					case 'Perimeter Defenses':
						for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 2)].length; card++) {
							if (cardFound === true) {
								break;
							}
							if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].cardType === 0) {
								for (var effect = 0; effect < referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
									if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects[effect] === viableCards[cardIndex]) {
										referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].attack = referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].attack - 5;
										cardFound = true;
										break;
									}
								}
							}
						}
                        break;
					case 'Prototype Weaponry':
						for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 2)].length; card++) {
							if (cardFound === true) {
								break;
							}
							if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].cardType === 0) {
								for (var effect = 0; effect < referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
									if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects[effect] === viableCards[cardIndex]) {
										referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].attack = referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].attack - 10;
										cardFound = true;
										break;
									}
								}
							}
						}
                        break;
					case 'Reinforce Structure':
						for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 2)].length; card++) {
							if (cardFound === true) {
								break;
							}
							if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].cardType === 0) {
								for (var effect = 0; effect < referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
									if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects[effect] === viableCards[cardIndex]) {
										referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].maxHP = referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].maxHP - 10;
										if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].currentHP > referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].maxHP) {
											referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].currentHP = referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].maxHP;
										}
										cardFound = true;
										break;
									}
								}
							}
						}
                        break;
					case 'Schnee Dust Company':
						for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 2)].length; card++) {
							if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].cardType === 0) {
								for (var effect = 0; effect < referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
									if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects[effect] === viableCards[cardIndex]) {
										referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].attack = referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].attack - 5;
										cardFound = true;
										break;
									}
								}
							}
						}
                        break;
					case 'Silver Eyes':
						// FUTURE FIX: not yet implemented
						break;
					case 'Thruster Packs':
						for (var card = 0; card < altCardPiles[((targetPlayer * 3) + 2)].length; card++) {
							if (cardFound === true) {
								break;
							}
							if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].cardType === 0) {
								for (var effect = 0; effect < referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
									if (referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].appliedEffects[effect] === viableCards[cardIndex]) {
										referenceCards[altCardPiles[((targetPlayer * 3) + 2)][card]].type = 0;
										cardFound = true;
										break;
									}
								}
							}
						}
                        break;
				}
				altCardPiles[((targetPlayer * 3) + 2)].splice(tempCardIndex,1);
				cardSource = -1;
				break;
		}
	}
	function addToCardHistory(cardID, tempPlayerNumber) {
		console.log('addToCardHistory()');
		lastPlayedCard = cardID;
		document.getElementById('cardHistoryList').scrollTop = 0;
		document.getElementById('cardVisualsNamePreview').innerHTML = referenceCards[cardID].name;
		if (referenceCards[cardID].hasOwnProperty('trainingTime')) {
			document.getElementById('cardVisualsDurationPreview').innerHTML = referenceCards[cardID].trainingTime + 'TR';
		} else if (referenceCards[cardID].hasOwnProperty('duration')) {
			switch (referenceCards[cardID].duration) {
				case 0: break;
				case 999: document.getElementById('cardVisualsDurationPreview').innerHTML = 'Perm.'; break;
				default: document.getElementById('cardVisualsDurationPreview').innerHTML = referenceCards[cardID].duration + 'TR'; break;
			}
		}
		if (referenceCards[cardID].cardType === 0) {
			document.getElementById('cardVisualsSpeedPreview').innerHTML = referenceCards[cardID].maxSpeed + 'SP';
		}
		if (referenceCards[cardID].cardType === 0) {
			document.getElementById('cardVisualsAttackPreview').innerHTML = referenceCards[cardID].attack + 'ATK';
		}
		if (referenceCards[cardID].cardType === 0) {
			document.getElementById('cardVisualsHPPreview').innerHTML = referenceCards[cardID].maxHP + 'HP';
		}
		document.getElementById('cardVisualsImagePreview').src = referenceCards[cardID].image;
		if (referenceCards[cardID].cardType === 0) {
			switch (referenceCards[cardID].size) {
				case 0: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Unit'; break;
				case 1: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Large unit'; break;
				case 2: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Huge unit'; break;
				case 3: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Colossal unit'; break;
				case 99: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Structure'; break;
			}
		} else if (referenceCards[cardID].cardType === 1) {
			document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Trap';
		} else if (referenceCards[cardID].cardType === 2) {
			document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Utility';
		}
		if (referenceCards[cardID].cardType === 0) {
			switch (referenceCards[cardID].mechanical) {
				case 0: document.getElementById('cardVisualsMechanicalPreview').innerHTML = 'Non-Mech.'; break;
				case 1: document.getElementById('cardVisualsMechanicalPreview').innerHTML = 'Half-Mech.'; break;
				case 2: document.getElementById('cardVisualsMechanicalPreview').innerHTML = 'Full-Mech.'; break;
			}
		}
		document.getElementById('cardVisualsDescriptionPreview').innerHTML = referenceCards[cardID].description;

		// add card to history list
		if ($('#cardHistoryTable tr').length >= 10) {
			$('#cardHistoryTable tr:last').remove();
			cardHistory.splice(9,1);
		}
		var tr = $('<tr></tr>');
		if (tempPlayerNumber !== -1) {
			tr.css('background-color', kingdomColorArray[tempPlayerNumber]);
		}
		tr.hover(
			(function(cardID) {
				return function() {
					document.getElementById('cardVisualsNamePreview').innerHTML = referenceCards[cardID].name;
					if (referenceCards[cardID].hasOwnProperty('trainingTime')) {
						document.getElementById('cardVisualsDurationPreview').innerHTML = referenceCards[cardID].trainingTime + 'TR';
					} else if (referenceCards[cardID].hasOwnProperty('duration')) {
						switch (referenceCards[cardID].duration) {
							case 0: break;
							case 999: document.getElementById('cardVisualsDurationPreview').innerHTML = 'Perm.'; break;
							default: document.getElementById('cardVisualsDurationPreview').innerHTML = referenceCards[cardID].duration + 'TR'; break;
						}
					}
					if (referenceCards[cardID].cardType === 0) {
						document.getElementById('cardVisualsSpeedPreview').innerHTML = referenceCards[cardID].maxSpeed + 'SP';
					}
					if (referenceCards[cardID].cardType === 0) {
						document.getElementById('cardVisualsAttackPreview').innerHTML = referenceCards[cardID].attack + 'ATK';
					}
					if (referenceCards[cardID].cardType === 0) {
						document.getElementById('cardVisualsHPPreview').innerHTML = referenceCards[cardID].maxHP + 'HP';
					}
					document.getElementById('cardVisualsImagePreview').src = referenceCards[cardID].image;
					if (referenceCards[cardID].cardType === 0) {
						switch (referenceCards[cardID].size) {
							case 0: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Unit'; break;
							case 1: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Large unit'; break;
							case 2: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Huge unit'; break;
							case 3: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Colossal unit'; break;
							case 99: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Structure'; break;
						}
					} else if (referenceCards[cardID].cardType === 1) {
						document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Trap';
					} else if (referenceCards[cardID].cardType === 2) {
						document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Utility';
					}
					if (referenceCards[cardID].cardType === 0) {
						switch (referenceCards[cardID].mechanical) {
							case 0: document.getElementById('cardVisualsMechanicalPreview').innerHTML = 'Non-Mech.'; break;
							case 1: document.getElementById('cardVisualsMechanicalPreview').innerHTML = 'Half-Mech.'; break;
							case 2: document.getElementById('cardVisualsMechanicalPreview').innerHTML = 'Full-Mech.'; break;
						}
					}
					document.getElementById('cardVisualsDescriptionPreview').innerHTML = referenceCards[cardID].description;
				};
			})(cardID)/*,
			(function(lastPlayedCard) {
				return function() {
					document.getElementById('cardVisualsNamePreview').innerHTML = referenceCards[lastPlayedCard].name;
					if (referenceCards[lastPlayedCard].hasOwnProperty('trainingTime')) {
						document.getElementById('cardVisualsDurationPreview').innerHTML = referenceCards[lastPlayedCard].trainingTime + 'TR';
					} else if (referenceCards[lastPlayedCard].hasOwnProperty('duration')) {
						switch (referenceCards[lastPlayedCard].duration) {
							case 0: break;
							case 999: document.getElementById('cardVisualsDurationPreview').innerHTML = 'Perm.'; break;
							default: document.getElementById('cardVisualsDurationPreview').innerHTML = referenceCards[lastPlayedCard].duration + 'TR'; break;
						}
					}
					if (referenceCards[lastPlayedCard].cardType === 0) {
						document.getElementById('cardVisualsSpeedPreview').innerHTML = referenceCards[lastPlayedCard].maxSpeed + 'SP';
					}
					if (referenceCards[lastPlayedCard].cardType === 0) {
						document.getElementById('cardVisualsAttackPreview').innerHTML = referenceCards[lastPlayedCard].attack + 'ATK';
					}
					if (referenceCards[lastPlayedCard].cardType === 0) {
						document.getElementById('cardVisualsHPPreview').innerHTML = referenceCards[lastPlayedCard].maxHP + 'HP';
					}
					document.getElementById('cardVisualsImagePreview').src = referenceCards[lastPlayedCard].image;
					if (referenceCards[lastPlayedCard].cardType === 0) {
						switch (referenceCards[lastPlayedCard].size) {
							case 0: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Unit'; break;
							case 1: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Large unit'; break;
							case 2: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Huge unit'; break;
							case 3: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Colossal unit'; break;
							case 99: document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Structure'; break;
						}
					} else if (referenceCards[lastPlayedCard].cardType === 1) {
						document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Trap';
					} else if (referenceCards[lastPlayedCard].cardType === 2) {
						document.getElementById('cardVisualsSizeTypePreview').innerHTML = 'Utility';
					}
					if (referenceCards[lastPlayedCard].cardType === 0) {
						switch (referenceCards[lastPlayedCard].mechanical) {
							case 0: document.getElementById('cardVisualsMechanicalPreview').innerHTML = 'Non-Mech.'; break;
							case 1: document.getElementById('cardVisualsMechanicalPreview').innerHTML = 'Half-Mech.'; break;
							case 2: document.getElementById('cardVisualsMechanicalPreview').innerHTML = 'Full-Mech.'; break;
						}
					}
					document.getElementById('cardVisualsDescriptionPreview').innerHTML = referenceCards[lastPlayedCard].description;
				};
			})(lastPlayedCard)*/
		);
		var td = $('<td>' + referenceCards[cardID].name + '</td>');
		tr.append(td);
		$('#cardHistoryTable').prepend(tr);
		cardHistory.splice(0,0,{card:cardID, player:playerNumber});
	}

	/*SOCKET COMMANDS (commented out in local testing)
    socket.on('send player hands 1', function() {
        socket.emit('response send player hands 1', sPlayerNumber);
    });
    socket.on('send player hands 2', function(initialHand) {
        altCardPiles[((playerNumber * 3) + 1)] = initialHand;
    });

    socket.on('next turn', function(newPlayerTurn, hasCapital) {
        nextTurn(newPlayerTurn, hasCapital);
    });
    socket.on('request game state info', function() {
        socket.emit('response game state info', GRID, playerNumber, nOfCapitals, stageOfWar, cardHistory, altCardPiles[((playerNumber * 3) + 1)], altCardPiles[((playerNumber * 3) + 2)], altCardPiles[((playerNumber * 3) + 3)], forgedArmistice, frostDustBombs, liquidDeath, rustingMists, trappingPit);
    });
    socket.on('capital taken over', function(sNewOwner, sOldOwner, sTerID) {
        if (sNewOwner !== playerNumber) {
            if (sOldOwner === playerNumber) {
                nOfCapitals[sOldOwner]--;
            }
            for (var ter = continentArray[continent].start; ter <= continentArray[continent].end; ter++) {
                territoryStateInfo[ter].ownedByPlayer = sNewOwner;
            }
        }
    });
    socket.on('player surrenders', function(sPlayerNumber) {
        document.getElementById('playerDefeatedHeader').innerHTML = 'Commander ' + commName[sPlayerNumber] + ' has surrendered';
        document.getElementById('playerDefeatedIcon').src = kingdomPicArray[sPlayerNumber];
        document.getElementById('playerDefeatedText').innerHTML = 'In the face of current events, after valliantly defending their kingdom against numerous military campaigns, commander ' + commName[sPlayerNumber] + ' of ' + kingdomNameArray[sPlayerNumber] + ' has formally declared unconditional surrender. All their units and utilities are removed from play.';
        showPlayerDefeated();
    });
    socket.on('player defeated', function(sPlayerNumber) {
        document.getElementById('playerDefeatedHeader').innerHTML = 'Commander ' + commName[sPlayerNumber] + ' was defeated';
        document.getElementById('playerDefeatedIcon').src = kingdomPicArray[sPlayerNumber];
        document.getElementById('playerDefeatedText').innerHTML = 'In the face of current events, after heroically launching their final attacks, commander ' + commName[sPlayerNumber] + ' of ' + kingdomNameArray[sPlayerNumber] + ' lost the last of their forces in combat. All that remains of the kingdom is its history.';
        showPlayerDefeated();
    });
    socket.on('player victory', function(sPlayerNumber) {
        document.getElementById('playerVictoryHeader').innerHTML = 'Commander ' + commName[sPlayerNumber] + ' was victorious';
        document.getElementById('playerVictoryIcon').src = kingdomPicArray[sPlayerNumber];
        document.getElementById('playerVictoryText').innerHTML = 'Through military and tactical superiority, commander ' + commName[sPlayerNumber] + ' has led the armies of' + kingdomNameArray[sPlayerNumber] + ' to victory and brought unity to the world of Remnant. Little does the commander know this was all just a ruse to leave their cookie jar unguarded. The king ate good that day.';
        showPlayerVictory();
    });

    socket.on('evolution of warfare', function(sCardID) {
        var tempX = $('#cardPreview').offset().left;
        var tempY = $('#cardPreview').offset().top;
        flyCardFly($('#drawPile').offset().left, $('#drawPile').offset().top, tempX, tempY, 300);
        addToCardHistory(sFirstCardID, -1);
        showEvolutionOfWarfareText();
    });
    socket.on('clear card visuals', function(sPlayerNumber) {
        if (sPlayerNumber !== playerNumber) {
            nOfCards[sPlayerNumber]--;
        }
    });
    socket.on('push to discard pile', function(sPlayerNumber, sCardID) {
        if (sPlayerNumber !== playerNumber) {
            altCardPiles[((sPlayerNumber * 3) + 3)].push(sCardID);
        }
    });
    socket.on('push to actives pile', function(sPlayerNumber, sCardID) {
        if (sPlayerNumber !== playerNumber) {
            altCardPiles[((sPlayerNumber * 3) + 2)].push(sCardID);
        }
    });
    socket.on('draw picked card', function(sPlayerNumber, sTargetPlayer, sActiveCard, sCardID) {
        if (sPlayerNumber !== playerNumber) {
            switch(cardSource) {
                case 0: // player discard pile
                    $('#cardImage' + (altCardPiles[((sPlayerNumber * 3) + 1)].indexOf(sActiveCard) + 1)).removeClass('selected');
                    clearCardVisuals(altCardPiles[((sPlayerNumber * 3) + 1)].indexOf(sActiveCard));
                    var tempCardIndex = altCardPiles[((sTargetPlayer * 3) + 3)].indexOf(sCardID);
                    if (nOfCards[sPlayerNumber] > 8) {
                        createDiscardVisuals();
                    } else {
                        createCardVisuals(altCardPiles[((sTargetPlayer * 3) + 3)][tempCardIndex]);
                    }
                    altCardPiles[((sPlayerNumber * 3) + 1)].push(altCardPiles[((sTargetPlayer * 3) + 3)][tempCardIndex]);
                    altCardPiles[((sTargetPlayer * 3) + 3)].splice(tempCardIndex,1);
                    nOfCards[sTargetPlayer] = altCardPiles[((sTargetPlayer * 3) + 1)].length;
                    cardSource = -1;
                    break;
                case 1: // player actives (Distraction trap - deletes card instead of drawing it)
                    var tempCardIndex = altCardPiles[((sTargetPlayer * 3) + 2)].indexOf(sCardID);
                    var cardFound = false;
                    // FUTURE FIX: reverse all effects of utility
                    switch(referenceCards[sCardID].name) {
                        case 'Concentrated Dust':
                            for (var card = 0; card < altCardPiles[((sTargetPlayer * 3) + 2)].length; card++) {
                                if (cardFound === true) {
                                    break;
                                }
                                if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].cardType === 0) {
                                    for (var effect = 0; effect < referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
                                        if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects[effect] === sCardID) {
                                            referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].attack = referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].attack - 10;
                                            cardFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                        case 'Infused Armor':
                            for (var card = 0; card < altCardPiles[((sTargetPlayer * 3) + 2)].length; card++) {
                                if (cardFound === true) {
                                    break;
                                }
                                if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].cardType === 0) {
                                    for (var effect = 0; effect < referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
                                        if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects[effect] === sCardID) {
                                            referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].maxHP = referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].maxHP - 15;
                                            if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].currentHP > referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].maxHP) {
                                                referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].currentHP = referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].maxHP;
                                            }
                                            referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].mechanical = 0;
                                            cardFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                        case 'Naval Ram':
                            for (var card = 0; card < altCardPiles[((sTargetPlayer * 3) + 2)].length; card++) {
                                if (cardFound === true) {
                                    break;
                                }
                                if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].cardType === 0) {
                                    for (var effect = 0; effect < referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
                                        if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects[effect] === sCardID) {
                                            referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].attack = referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].attack - 10;
                                            cardFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                        case 'Perimeter Defenses':
                            for (var card = 0; card < altCardPiles[((sTargetPlayer * 3) + 2)].length; card++) {
                                if (cardFound === true) {
                                    break;
                                }
                                if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].cardType === 0) {
                                    for (var effect = 0; effect < referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
                                        if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects[effect] === sCardID) {
                                            referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].attack = referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].attack - 5;
                                            cardFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                        case 'Prototype Weaponry':
                            for (var card = 0; card < altCardPiles[((sTargetPlayer * 3) + 2)].length; card++) {
                                if (cardFound === true) {
                                    break;
                                }
                                if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].cardType === 0) {
                                    for (var effect = 0; effect < referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
                                        if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects[effect] === sCardID) {
                                            referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].attack = referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].attack - 10;
                                            cardFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                        case 'Reinforce Structure':
                            for (var card = 0; card < altCardPiles[((sTargetPlayer * 3) + 2)].length; card++) {
                                if (cardFound === true) {
                                    break;
                                }
                                if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].cardType === 0) {
                                    for (var effect = 0; effect < referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
                                        if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects[effect] === sCardID) {
                                            referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].maxHP = referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].maxHP - 10;
                                            if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].currentHP > referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].maxHP) {
                                                referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].currentHP = referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].maxHP;
                                            }
                                            cardFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                        case 'Schnee Dust Company':
                            for (var card = 0; card < altCardPiles[((sTargetPlayer * 3) + 2)].length; card++) {
                                if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].cardType === 0) {
                                    for (var effect = 0; effect < referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
                                        if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects[effect] === sCardID) {
                                            referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].attack = referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].attack - 5;
                                            cardFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                        case 'Silver Eyes':
                            // FUTURE FIX: not yet implemented
                            break;
                        case 'Thruster Packs':
                            for (var card = 0; card < altCardPiles[((sTargetPlayer * 3) + 2)].length; card++) {
                                if (cardFound === true) {
                                    break;
                                }
                                if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].cardType === 0) {
                                    for (var effect = 0; effect < referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects.length; effect++) {
                                        if (referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].appliedEffects[effect] === sCardID) {
                                            referenceCards[altCardPiles[((sTargetPlayer * 3) + 2)][card]].type = 0;
                                            cardFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            break;
                    }
                    altCardPiles[((sTargetPlayer * 3) + 2)].splice(tempCardIndex,1);
                    cardSource = -1;
                    break;
            }
        }
    });
    socket.on('draw from drawpile', function(newPlayerTurn, cardID) {
        if (newPlayerTurn !== playerNumber) {
            var tempX = $('#p' + playerByPos.indexOf(newPlayerTurn) + 'Area').offset().left;
            var tempY = $('#p' + playerByPos.indexOf(newPlayerTurn) + 'Area').offset().top;
            flyCardFly($('#drawPile').offset().left, $('#drawPile').offset().top, tempX, tempY, 300);
            setTimeout(function() {
                // TO DO: manage drawPile length without storing drawPile content locally
                drawPile.splice(0,1);
                nOfCards[4]--;
                if (nOfCards[playerNumber] < 8) {
                    nOfCards[newPlayerTurn]++;
                }
            }, 300);
        } else {
            if (nOfCards[playerNumber] < 8) {
                var tempX = $('#cardImage' + (nOfCards[playerNumber] + 1)).offset().left;
                var tempY = $('#cardImage' + (nOfCards[playerNumber] + 1)).offset().top;
            } else {
                var tempX = (window.innerWidth / 2) - (cardSize.w / 2);
                var tempX = (window.innerHeight / 2) - (cardSize.h / 2);
            }
            flyCardFly($('#drawPile').offset().left, $('#drawPile').offset().top, tempX, tempY, 300);
            setTimeout(function() {
                altCardPiles[((playerNumber * 3) + 1)].push(cardID);
                // TO DO: manage drawPile length without storing drawPile content locally
                drawPile.splice(0,1);
                nOfCards[4]--;
                if (nOfCards[playerNumber] < 8) {
                    nOfCards[newPlayerTurn]++;
                    createCardVisuals(cardID);
                } else {
                    createDiscardVisuals();
                }
            }, 300);
        }
    });
    socket.on('wait for discard', function(sPlayerNumber) {
        if (sPlayerNumber !== playerNumber) {
            // TO DO (optional): show players a message that a card is being chosen to discard
        }
    });
    socket.on('end of wait for discard', function(sPlayerNumber) {
        if (sPlayerNumber !== playerNumber) {
            // TO DO (optional): remove message
        }
    });

    socket.on('show played trap', function(recipientPlayer, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, sAttackingUnits, sTargetedUnits, sFirstTrap, sSecondTrap) {
        if (recipientPlayer === playerNumber) {
            var tempDisplayedTrap = -1;
            if (sSecondTrap === -1) {
                tempDisplayedTrap = sFirstTrap;
            } else {
                tempDisplayedTrap = sSecondTrap;
            }
            var trapPlayerSource = -1;
            if (recipientPlayer === attackingPlayer) {
                trapPlayerSource = defendingPlayer;
            } else {
                trapPlayerSource = attackingPlayer;
            }
            document.getElementById('singleCardTopText').innerHTML = 'Commander' + commName[trapPlayerSource] + ' played ' + referenceCards[tempDisplayedTrap].name;
            document.getElementById('singleCardVisualsName').innerHTML = referenceCards[tempDisplayedTrap].name;
            if (referenceCards[tempDisplayedTrap].hasOwnProperty('trainingTime')) {
                document.getElementById('singleCardVisualsDuration').innerHTML = referenceCards[tempDisplayedTrap].trainingTime + 'TR';
            } else if (referenceCards[tempDisplayedTrap].hasOwnProperty('duration')) {
                switch (referenceCards[tempDisplayedTrap].duration) {
                    case 0: break;
                    case 999: document.getElementById('singleCardVisualsDuration').innerHTML = 'Perm.'; break;
                    default: document.getElementById('singleCardVisualsDuration').innerHTML = referenceCards[tempDisplayedTrap].duration + 'TR'; break;
                }
            }
            if (referenceCards[tempDisplayedTrap].cardType === 0) {
                document.getElementById('singleCardVisualsSpeed').innerHTML = referenceCards[tempDisplayedTrap].maxSpeed + 'SP';
                document.getElementById('singleCardVisualsSpeed').style.color = 'black';
            }
            if (referenceCards[tempDisplayedTrap].cardType === 0) {
                document.getElementById('singleCardVisualsAttack').innerHTML = referenceCards[tempDisplayedTrap].attack + 'ATK';
                document.getElementById('singleCardVisualsAttack').style.color = 'black';
            }
            if (referenceCards[tempDisplayedTrap].cardType === 0) {
                document.getElementById('singleCardVisualsHP').innerHTML = referenceCards[tempDisplayedTrap].maxHP + 'HP';
                document.getElementById('singleCardVisualsHP').style.color = 'black';
            }
            document.getElementById('singleCardVisualsImage').src = referenceCards[tempDisplayedTrap].image;
            if (referenceCards[tempDisplayedTrap].cardType === 0) {
                switch (referenceCards[tempDisplayedTrap].size) {
                    case 0: document.getElementById('singleCardVisualsSizeType').innerHTML = 'Unit'; break;
                    case 1: document.getElementById('singleCardVisualsSizeType').innerHTML = 'Large unit'; break;
                    case 2: document.getElementById('singleCardVisualsSizeType').innerHTML = 'Huge unit'; break;
                    case 3: document.getElementById('singleCardVisualsSizeType').innerHTML = 'Colossal unit'; break;
                    case 99: document.getElementById('singleCardVisualsSizeType').innerHTML = 'Structure'; break;
                }
                document.getElementById('singleCardVisualsSizeType').style.color = 'black';
            } else if (referenceCards[tempDisplayedTrap].cardType === 1) {
                document.getElementById('singleCardVisualsSizeType').innerHTML = 'Trap';
            } else if (referenceCards[tempDisplayedTrap].cardType === 2) {
                document.getElementById('singleCardVisualsSizeType').innerHTML = 'Utility';
            }
            if (referenceCards[tempDisplayedTrap].cardType === 0) {
                switch (referenceCards[tempDisplayedTrap].mechanical) {
                    case 0: document.getElementById('singleCardVisualsMechanical').innerHTML = 'Non-Mech.'; break;
                    case 1: document.getElementById('singleCardVisualsMechanical').innerHTML = 'Half-Mech.'; break;
                    case 2: document.getElementById('singleCardVisualsMechanical').innerHTML = 'Full-Mech.'; break;
                }
                document.getElementById('singleCardVisualsMechanical').style.color = 'black';
            }
            document.getElementById('singleCardVisualsDescription').innerHTML = referenceCards[tempDisplayedTrap].description;
            document.getElementById('singleCardVisualsDescription').style.color = 'black';
            $('#singleCardWindow').fadeIn(150);
            document.getElementById('singleCardWindowButton').onclick = function() {
                $('#overlayWindows, #singleCardWindow').fadeOut(0);
                if (recipientPlayer === defendingPlayer) {
                    // TO DO: replace with sockets?
                    selectTrap(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, sAttackingUnits, sTargetedUnits, sFirstTrap);
                } else {
                    // TO DO: replace with sockets?
                    activateTrap(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, altCardPiles[((playerNumber * 3) + 1)][card]);
                }
            }
        } else {
            displayTargetCard('Commander' + commName[trapPlayerSource] + ' played ' + referenceCards[tempDisplayedTrap].name, cardID);
        }
    });
    // this part should be deleted if the above socket works just fine
        // socket.on('select trap', function(recipientPlayer, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, sAttackingUnits, sTargetedUnits, sFirstTrap) {
        //     if (recipientPlayer === playerNumber) {
        //         selectTrap(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, sAttackingUnits, sTargetedUnits, sFirstTrap);
        //     } else {
        //         // TO DO: inform other players that recipientPlayer is selecting a trap card
        //     }
        // });
        // socket.on('activate trap', function(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, sAttackingUnits, sTargetedUnits, sFirstTrap, sCounterTrap) {
        //     activateTrap(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, sAttackingUnits, sTargetedUnits, sFirstTrap);
        // });
    socket.on('attack ter', function(sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
        if (sPlayerNumber !== playerNumber) {
            attackTer(sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
        }
    });
    socket.on('draw spoils', function(sPlayerNumber, tempTarget, tempCardIndex) {
        if (sPlayerNumber !== playerNumber) {
            if (tempTarget === -1) {
                // move from drawPile
                var tempX1 = $('#drawPile').offset().left
                var tempY1 = $('#drawPile').offset().top
            } else {
                // move from player
                // OPTIONAL: allow other players to see which card was drawn?
                if (tempTarget === sPlayerNumber) {
                    var tempX1 = $('#cardImage' + tempCardIndex).offset().left
                    var tempY1 = $('#cardImage' + tempCardIndex).offset().top
                } else {
                    var tempX1 = $('#p' + playerByPos.indexOf(sPlayerNumber) + 'Area').offset().left
                    var tempY1 = $('#p' + playerByPos.indexOf(sPlayerNumber) + 'Area').offset().top
                }
            }
            var tempX2 = $('#p' + playerByPos.indexOf(tempTarget) + 'Area').offset().left;
            var tempY2 = $('#p' + playerByPos.indexOf(tempTarget) + 'Area').offset().top;
            flyCardFly(tempX1, tempY1, tempX2, tempY2, 300);
        }
    });
    socket.on('draw random from player', function(sPlayerNumber, sTargetPlayer, tempPile, tempCardIndex) {
        if (sPlayerNumber !== playerNumber) {
            var tempCardID = altCardPiles[((sTargetPlayer * 3) + 1)][tempCardIndex];
            altCardPiles[((sTargetPlayer * 3) + tempPile)].splice(tempCardIndex,1);
            nOfCards[sTargetPlayer] = altCardPiles[((sTargetPlayer * 3) + 1)].length;
            nOfCards[sPlayerNumber] = altCardPiles[((sPlayerNumber * 3) + 1)].length;
            document.getElementById('player' + sTargetPlayer + 'Cards').innerHTML = nOfCards[sTargetPlayer];
            document.getElementById('player' + sPlayerNumber + 'Cards').innerHTML = nOfCards[sPlayerNumber];
        }
    });

    socket.on('place unit', function(sPlayerNumber, sCardID, sActiveTer) {
        if (sPlayerNumber !== playerNumber) {
            territoryStateInfo[sActiveTer].occupiedByUnits.push(sCardID);
            // made as array in case the Schnee Dust Company card is no longer unique per deck in the future. effect won't stack, though
            var schneeID = [];
            for (var obj = 0; obj < referenceCards.length; obj++) {
                if (referenceCards[obj].name === 'Schnee Dust Company') {
                    schneeID.push(obj);
                }
            }
            for (var arr = 0; arr < schneeID.length; arr++) {
                if (altCardPiles[((sPlayerNumber * 3) + 2)].indexOf(schneeID[arr]) !== -1) {
                    referenceCards[sCardID].attack = referenceCards[sCardID].attack + 5;
                    break;
                }
            }
            altCardPiles[((sPlayerNumber * 3) + 2)].push(sCardID);
            refreshTerStateVisuals(sActiveTer);
            refreshInteractibility();
        }
    });
    socket.on('move to ter', function(sPlayerNumber, sActiveUnits, sActiveTerID, sTargetTerID) {
        var tempX1 = 3840 / 100 * territoryShapeInfo[sActiveTerID][(territoryShapeInfo[sActiveTerID].length - 1)][0][0].x;
        var tempY1 = 2160 / 100 * territoryShapeInfo[sActiveTerID][(territoryShapeInfo[sActiveTerID].length - 1)][0][0].y;
        var tempX2 = 3840 / 100 * territoryShapeInfo[sTargetTerID][(territoryShapeInfo[sTargetTerID].length - 1)][0][0].x;
        var tempY2 = 2160 / 100 * territoryShapeInfo[sTargetTerID][(territoryShapeInfo[sTargetTerID].length - 1)][0][0].y;
        moveArrowSVG.setAttribute("x1", tempX1);
        moveArrowSVG.setAttribute("y1", tempY1);
        moveArrowSVG.setAttribute("x2", tempX2);
        moveArrowSVG.setAttribute("y2", tempY2);
        moveArrowSVG.style.visibility = 'visible';
        setTimeout(function() {
            for (var tempActiveUnit = 0; tempActiveUnit < sActiveUnits.length; tempActiveUnit++) {
                territoryStateInfo[sTargetTerID].occupiedByUnits.push(sActiveUnits[tempActiveUnit]);
                territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(sActiveUnits[tempActiveUnit]), 1);
            }
            territoryStateInfo[sTargetTerID].occupiedByPlayer = sPlayerNumber;
            for (var continent = 0; continent < continentArray.length; continent++) {
                if (sTargetTerID === continentArray[continent].capital && territoryStateInfo[sTargetTerID].occupiedByPlayer !== territoryStateInfo[sTargetTerID].ownedByPlayer) {
                    for (var ter = continentArray[continent].start; ter <= continentArray[continent].end; ter++) {
                        territoryStateInfo[ter].ownedByPlayer = sPlayerNumber;
                    }
                }
            }
            refreshTerStateVisuals(sTargetTerID);
            refreshTerStateVisuals(sActiveTerID);
            refreshInteractibility();
            setTimeout(function() {
                moveArrowSVG.style.visibility = 'hidden';
            }, 500);
        }, 1000);
    });

    // trap cards
        socket.on('push to forgedArmistice', function(sPlayerNumber, sTargetPlayer, sTurnsLeft) {
            if (sPlayerNumber !== playerNumber) {
                var inArray = false;
                for (var fa = 0; fa < forgedArmistice.length; fa++) {
                    if (forgedArmistice[fa].player === sTargetPlayer && forgedArmistice[fa].cannotAttack === sPlayerNumber) {
                        inArray = true;
                        forgedArmistice[fa].turnsLeft = forgedArmistice[fa].turnsLeft + sTurnsLeft;
                    }
                }
                if (inArray === false) {
                    forgedArmistice.push({player:sTargetPlayer, cannotAttack:sPlayerNumber, turnsLeft:sTurnsLeft});
                }
            }
        });
        socket.on('assault of the giant nevermore', function(sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sTarget, sTargetEnemy, sTargetAlly) {
            if (sPlayerNumber !== playerNumber) {
                if (sTarget === 0) {
                    // enemy target
                    if (sTargetedUnits.indexOf(sTargetEnemy) !== -1) {
                        sTargetedUnits.splice(sTargetedUnits.indexOf(sTargetEnemy), 1);
                    }
                    referenceCards[sTargetEnemy].currentHP = 0;
                    altCardPiles[((territoryStateInfo[sActiveTerID].occupiedByPlayer * 3) + 2)].splice(altCardPiles[((territoryStateInfo[sActiveTerID].occupiedByPlayer * 3) + 2)].indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[this.rowIndex]), 1);
                    territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[this.rowIndex]), 1);
                    refreshTerStateVisuals(sActiveTerID);
                    if (territoryStateInfo[sActiveTerID].occupiedByUnits.length > 0) {
                        attackTer(sActiveTerID, sTargetedUnits, firstTrap);
                    } else if (territoryStateInfo[sActiveTerID].occupiedByPlayer === playerNumber) {
                        activeTer = -1;
                        hasRanged = -1;
                        refreshInteractibility();
                        document.getElementById('terGenInfo').innerHTML = '';
                        document.getElementById('terUnitInfo').innerHTML = '';
                    }
                } else {
                    // friendly target
                    for (var ally = 0; ally < territoryStateInfo[sTargetTerID].occupiedByUnits.length; ally++) {
                        if (territoryStateInfo[sTargetTerID].occupiedByUnits[ally] === sTargetAlly) {
                            territoryStateInfo[sTargetTerID].occupiedByUnits.splice(territoryStateInfo[sTargetTerID].occupiedByUnits[ally], 1);
                            refreshTerStateVisuals(sTargetTerID);
                            if (sTargetedUnits.indexOf(sTargetAlly) !== -1) {
                                sTargetedUnits.splice(sTargetedUnits.indexOf(sTargetAlly), 1);
                            }
                        }
                    }
                    for (var adj = 0; adj < territoryStateInfo[sTargetTerID].adjacentTer.length; adj++) {
                        for (var ally = 0; ally < territoryStateInfo[territoryStateInfo[sTargetTerID].adjacentTer[adj]].occupiedByUnits.length; ally++) {
                            if (territoryStateInfo[territoryStateInfo[sTargetTerID].adjacentTer[adj]].occupiedByUnits[ally] === sTargetAlly) {
                                territoryStateInfo[territoryStateInfo[sTargetTerID].adjacentTer[adj]].occupiedByUnits.splice(territoryStateInfo[territoryStateInfo[sTargetTerID].adjacentTer[adj]].occupiedByUnits[ally], 1);
                                refreshTerStateVisuals(territoryStateInfo[sTargetTerID].adjacentTer[adj]);
                            }
                        }
                    }
                    referenceCards[sTargetAlly].currentHP = 0;
                    altCardPiles[((defendingPlayer * 3) + 2)].splice(altCardPiles[((defendingPlayer * 3) + 2)].indexOf(tempTargetAlly), 1);
                    territoryStateInfo[sTargetTerID].occupiedByUnits.splice(territoryStateInfo[sTargetTerID].occupiedByUnits.indexOf(tempTargetAlly), 1);
                    refreshTerStateVisuals(sActiveTerID);
                    if (territoryStateInfo[sTargetTerID].occupiedByUnits.length > 0) {
                        attackTer(sActiveTerID, sTargetedUnits, firstTrap);
                    } else if (territoryStateInfo[sActiveTerID].occupiedByPlayer === playerNumber) {
                        activeTer = -1;
                        hasRanged = -1;
                        refreshInteractibility();
                        document.getElementById('terGenInfo').innerHTML = '';
                        document.getElementById('terUnitInfo').innerHTML = '';
                    }
                }
            }
        });
        socket.on('frost dust bombs', function(sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sTurnsLeft) {
            if (sPlayerNumber !== playerNumber) {
                for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                    referenceCards[attackingUnits[attacker]].currentSpeed = 0;
                    var inArray = false;
                    for (var fdb = 0; fdb < frostDustBombs.length; fdb++) {
                        if (frostDustBombs[fdb].unitID === attackingUnits[attacker]) {
                            inArray = true;
                            frostDustBombs[fdb].turnsLeft = frostDustBombs[fdb].turnsLeft + sTurnsLeft;
                        }
                    }
                    if (inArray === false) {
                        frostDustBombs.push({unitID:attackingUnits[attacker], turnsLeft:sTurnsLeft});
                    }
                    if (referenceCards[attackingUnits[attacker]].type === 2) {
                        referenceCards[attackingUnits[attacker]].currentHP = referenceCards[attackingUnits[attacker]].currentHP - (referenceCards[attackingUnits[attacker]].maxHP * 0.4);
                        if (Math.round(referenceCards[attackingUnits[attacker]].currentHP) <= 0) {
                            territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(attackingUnits[attacker]), 1);
                            for (var fdb = 0; fdb < frostDustBombs.length; fdb++) {
                                if (frostDustBombs[fdb].unitID === attackingUnits[attacker]) {
                                    frostDustBombs.splice(fdb, 1);
                                }
                            }
                            attackingUnits[attacker].splice(attacker, 1);
                            attacker--;
                        }
                    }
                }
                refreshTerStateVisuals(sActiveTerID);
                if (attackingUnits.length > 0) {
                    attackTer(sTargetTerID, sTargetedUnits, firstTrap);
                } else if (territoryStateInfo[sActiveTerID].occupiedByPlayer === playerNumber) {
                    activeTer = -1;
                    hasRanged = -1;
                    refreshInteractibility();
                    document.getElementById('terGenInfo').innerHTML = '';
                    document.getElementById('terUnitInfo').innerHTML = '';
                }
            }
        });
        socket.on('liquid death', function(sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sUnitID, sTurnsLeft) {
            if (sPlayerNumber !== playerNumber) {
                var inArray = false;
                for (var ld = 0; ld < liquidDeath.length; ld++) {
                    if (liquidDeath[ld].unitID === sUnitID) {
                        inArray = true;
                        liquidDeath[ld].turnsLeft = liquidDeath[ld].turnsLeft + sTurnsLeft;
                    }
                }
                if (inArray === false) {
                    liquidDeath.push({unitID:sUnitID, turnsLeft:sTurnsLeft});
                }
                attackTer(sActiveTerID, sTargetedUnits, firstTrap);
            }
        });
        socket.on('minefield', function(sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
            if (sPlayerNumber !== playerNumber) {
                for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                    if (referenceCards[attackingUnits[attacker]].hasOwnProperty('ranged') && referenceCards[attackingUnits[attacker]].type === 0) {
                        referenceCards[attackingUnits[attacker]].currentHP = referenceCards[attackingUnits[attacker]].currentHP - 15;
                    }
                }
                for (var unit = 0; unit < territoryStateInfo[sActiveTerID].occupiedByUnits.length; unit++) {
                    if (Math.round(referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].currentHP) <= 0) {
                        territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[unit]), 1);
                        unit--;
                    }
                }
                refreshTerStateVisuals(sActiveTerID);
                if (attackingUnits.length > 0) {
                    attackTer(sActiveTerID, sTargetedUnits, firstTrap);
                } else {
                    sActiveTerID = -1;
                    hasRanged = -1;
                    refreshInteractibility();
                    document.getElementById('terGenInfo').innerHTML = '';
                    document.getElementById('terUnitInfo').innerHTML = '';
                }
            }
        });
        socket.on('naval minefield', function(sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
            if (sPlayerNumber !== playerNumber) {
                for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                    if (referenceCards[attackingUnits[attacker]].type === 1) {
                        referenceCards[attackingUnits[attacker]].currentHP = referenceCards[attackingUnits[attacker]].currentHP - 15;
                    }
                }
                for (var unit = 0; unit < territoryStateInfo[sActiveTerID].occupiedByUnits.length; unit++) {
                    if (Math.round(referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[unit]].currentHP) <= 0) {
                        territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(territoryStateInfo[sActiveTerID].occupiedByUnits[unit]), 1);
                        unit--;
                    }
                }
                refreshTerStateVisuals(sActiveTerID);
                if (attackingUnits.length > 0) {
                    attackTer(sActiveTerID, sTargetedUnits, firstTrap);
                } else {
                    sActiveTerID = -1;
                    hasRanged = -1;
                    refreshInteractibility();
                    document.getElementById('terGenInfo').innerHTML = '';
                    document.getElementById('terUnitInfo').innerHTML = '';
                }
            }
        });
        socket.on('royal reinstatement', function(sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
            if (sPlayerNumber !== playerNumber) {
                for (var enemy = 0; enemy < territoryStateInfo[sActiveTerID].occupiedByUnits.length; enemy++) {
                    if (referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[enemy]].affiliation === kingdomNameArray[kingdom[sPlayerNumber]]) {
                        territoryStateInfo[sActiveTerID].occupiedByUnits.push(territoryStateInfo[sActiveTerID].occupiedByUnits[enemy]);
                        territoryStateInfo[sActiveTerID].occupiedByUnits.splice(enemy, 1);
                        unit--;
                    }
                }
                // FUTURE FIX: optionally add visuals displaying how many move over
                refreshTerStateVisuals();
                if (territoryStateInfo[sActiveTerID].occupiedByUnits.length > 0) {
                    attackTer(sActiveTerID, sTargetedUnits, firstTrap);
                } else {
                    sActiveTerID = -1;
                    hasRanged = -1;
                    refreshInteractibility();
                    document.getElementById('terGenInfo').innerHTML = '';
                    document.getElementById('terUnitInfo').innerHTML = '';
                }
            }
        });
        socket.on('rusting mists', function(sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sTurnsLeft) {
            if (sPlayerNumber !== playerNumber) {
                var rustbucketCount = 0;
                for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                    if (referenceCards[attackingUnits[attacker]].mechanical !== 0) {
                        rustbucketCount++;
                        var inArray = false;
                        for (var rm = 0; rm < rustingMists.length; rm++) {
                            if (rustingMists[rm].unitID === attackingUnits[attacker]) {
                                inArray = true;
                                rustingMists[rm].turnsLeft = rustingMists[rm].turnsLeft + sTurnsLeft;
                            }
                        }
                        if (inArray === false) {
                            rustingMists.push({unitID:attackingUnits[attacker], turnsLeft:sTurnsLeft});
                        }
                    }
                }
                for (var defender = 0; defender < territoryStateInfo[sActiveTerID].occupiedByUnits.length; defender++) {
                    if (referenceCards[territoryStateInfo[sActiveTerID].occupiedByUnits[defender]].mechanical !== 0) {
                        rustbucketCount++;
                        var inArray = false;
                        for (var rm = 0; rm < rustingMists.length; rm++) {
                            if (rustingMists[rm].unitID === territoryStateInfo[sActiveTerID].occupiedByUnits[defender]) {
                                inArray = true;
                                rustingMists[rm].turnsLeft = rustingMists[rm].turnsLeft + sTurnsLeft;
                            }
                        }
                        if (inArray === false) {
                            rustingMists.push({unitID:territoryStateInfo[sActiveTerID].occupiedByUnits[defender], turnsLeft:sTurnsLeft});
                        }
                    }
                }
                if (rustbucketCount < attackingUnits.length) {
                    attackTer(sActiveTerID, sTargetedUnits, firstTrap);
                } else if (territoryStateInfo[sActiveTerID].occupiedByPlayer === playerNumber) {
                    activeTer = -1;
                    hasRanged = -1;
                    refreshInteractibility();
                    document.getElementById('terGenInfo').innerHTML = '';
                    document.getElementById('terUnitInfo').innerHTML = '';
                }
            }
        });
        socket.on('stealthy commandeering', function(sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sUnitID) {
            // FUTURE FIX: insert visuals here
            if (attackingUnits.indexOf(sUnitID) !== -1) {
                attackingUnits.splice(attackingUnits.indexOf(sUnitID), 1);
            }
            territoryStateInfo[sActiveTerID].occupiedByUnits.splice(territoryStateInfo[sActiveTerID].occupiedByUnits.indexOf(sUnitID), 1);
            territoryStateInfo[sTargetTerID].occupiedByUnits.push(sUnitID);
            altCardPiles[((attackingPlayer * 3) + 2)].splice(altCardPiles[((attackingPlayer * 3) + 2)].indexOf(sUnitID), 1);
            altCardPiles[((defendingPlayer * 3) + 2)].push(sUnitID);
            refreshTerStateVisuals(sActiveTerID);
            refreshTerStateVisuals(sTargetTerID);
            if (territoryStateInfo[sActiveTerID].occupiedByUnits.length > 0) {
                attackTer(sActiveTerID, sTargetedUnits, firstTrap);
            } else if (territoryStateInfo[sActiveTerID].occupiedByPlayer === playerNumber) {
                activeTer = -1;
                hasRanged = -1;
                refreshInteractibility();
                document.getElementById('terGenInfo').innerHTML = '';
                document.getElementById('terUnitInfo').innerHTML = '';
            }
        });
        socket.on('trapping pit', function(attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sTurnsLeft) {
            if (sPlayerNumber !== playerNumber) {
                for (var attacker = 0; attacker < attackingUnits.length; attacker++) {
                    referenceCards[attackingUnits[attacker]].currentSpeed = 0;
                    if (referenceCards[attackingUnits[attacker]].size !== 2 && referenceCards[attackingUnits[attacker]].size !== 3 && referenceCards[attackingUnits[attacker]].size !== 99 && referenceCards[attackingUnits[attacker]].type === 0) {
                        var inArray = false;
                        for (var tp = 0; tp < trappingPit.length; tp++) {
                            if (trappingPit[tp].unitID === attackingUnits[attacker]) {
                                inArray = true;
                                trappingPit[tp].turnsLeft = trappingPit[tp].turnsLeft + sTurnsLeft;
                            }
                        }
                        if (inArray === false) {
                            trappingPit.push({unitID:attackingUnits[attacker], turnsLeft:sTurnsLeft});
                        }
                    }
                }
                attackTer(sActiveTerID, sTargetedUnits, firstTrap);
            }
        });

    // utility cards
        socket.on('place amethyst grove saboteur', function(sPlayerNumber, sTargetPlayer, sActiveCard, sCardID) {
            if (sPlayerNumber !== playerNumber) {
                addToCardHistory(sActiveCard, sPlayerNumber);
                nOfCards[sTargetPlayer]--;
                altCardPiles[((sTargetPlayer * 3) + 3)].push(sCardID);
            }
        });
        socket.on('place atlesian engineers', function(sPlayerNumber, sActiveCard) {
            if (sPlayerNumber !== playerNumber) {
                addToCardHistory(sActiveCard, sPlayerNumber);
                altCardPiles[((sPlayerNumber * 3) + 2)].push(sActiveCard);
            }
        });
        socket.on('place desert scavenge', function(sPlayerNumber, sActiveCard) {
            if (sPlayerNumber !== playerNumber) {
                addToCardHistory(sActiveCard, sPlayerNumber);
            }
        });
        socket.on('place mistral trade route', function(sPlayerNumber, sActiveCard) {
            if (sPlayerNumber !== playerNumber) {
                addToCardHistory(sActiveCard, sPlayerNumber);
                $('#cardImage' + (altCardPiles[((sPlayerNumber * 3) + 1)].indexOf(sActiveCard) + 1)).removeClass('selected');
                altCardPiles[((sPlayerNumber * 3) + 2)].push(sActiveCard);
            }
        });
        socket.on('place schnee dust company', function(sPlayerNumber, sActiveCard) {
            if (sPlayerNumber !== playerNumber) {
                for (var ter = 0; ter < territoryStateInfo.length; ter++) {
                    if (territoryStateInfo.occupiedByPlayer === sPlayerNumber) {
                        for (var unit = 0; unit < territoryStateInfo[ter].occupiedByUnits.length; unit++) {
                            if (referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].mechanical !== 0) {
                                referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].appliedEffects.push(sActiveCard);
                                referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].attack = referenceCards[territoryStateInfo[ter].occupiedByUnits[unit]].attack + 5;
                            }
                        }
                    }
                }
                addToCardHistory(sActiveCard, sPlayerNumber);
                $('#cardImage' + (altCardPiles[((sPlayerNumber * 3) + 1)].indexOf(sActiveCard) + 1)).removeClass('selected');
                altCardPiles[((sPlayerNumber * 3) + 2)].push(sActiveCard);
            }
        });
        socket.on('place smugglers of wind path', function(sPlayerNumber, sActiveCard) {
            if (sPlayerNumber !== playerNumber) {
                addToCardHistory(sActiveCard, sPlayerNumber);
            }
        });
        socket.on('apply utility', function(sPlayerNumber, sActiveCard, sUnitID) {
            if (sPlayerNumber !== playerNumber) {
                referenceCards[sUnitID].appliedEffects.push(sActiveCard);
                altCardPiles[((sPlayerNumber * 3) + 2)].push(sActiveCard);
                switch(referenceCards[sActiveCard].name) {
                    case 'Concentrated Dust':
                        referenceCards[sUnitID].attack = referenceCards[sUnitID].attack + 10;
                        break;
                    case 'First Aid':
                        if ((referenceCards[sUnitID].currentHP + 20) > referenceCards[sUnitID].maxHP) {
                            referenceCards[sUnitID].currentHP = referenceCards[sUnitID].maxHP;
                        } else {
                            referenceCards[sUnitID].currentHP = referenceCards[sUnitID].currentHP + 20;
                        }
                        break;
                    case 'Infused Armor':
                        referenceCards[sUnitID].maxHP = referenceCards[sUnitID].maxHP + 15;
                        referenceCards[sUnitID].currentHP = referenceCards[sUnitID].currentHP + 15;
                        referenceCards[sUnitID].mechanical = 1;
                        break;
                    case 'Naval Ram':
                        referenceCards[sUnitID].attack = referenceCards[sUnitID].attack + 10;
                        break;
                    case 'Perimeter Defenses ':
                        referenceCards[sUnitID].attack = referenceCards[sUnitID].attack + 5;
                        break;
                    case 'Prototype Weaponry':
                        referenceCards[sUnitID].attack = referenceCards[sUnitID].attack + 10;
                        break;
                    case 'Reinforce Structure':
                        referenceCards[sUnitID].maxHP = referenceCards[sUnitID].maxHP + 10;
                        referenceCards[sUnitID].currentHP = referenceCards[sUnitID].currentHP + 10;
                        break;
                    case 'Silver Eyes': break;
                    case 'Thruster Packs':
                        referenceCards[sUnitID].type = 2;
                        break;
                }
            }
        });
        socket.on('apply nh', function(sPlayerNumber, sActiveCard, sTerID) {
            if (sPlayerNumber !== playerNumber) {
                territoryStateInfo[sTerID].naturalHazardIDs.push(sActiveCard);
                altCardPiles[((sPlayerNumber * 3) + 2)].push(sActiveCard);
                refreshTerStateVisuals(sTerID);
            }
        });
    */

	/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
	// server-side functions, present for local testing
    // emitting with original player number is a temporary measure until I can ensure socketIO's broadcast functionworks well in combination with to/in

	// socket.on('next turn', function() {
	// });
	function serverNextTurn(GRID, lastPlayer) {
		// TO DO: retrieve based on GRID from database: last player turn, next 2 cards from draw pile, playersStillPlaying, and nOfCapitalsByPlayer
		// double check if local game is in sync with server
		var serverSideCurrentPlayer; // TO DO: get player turn from database;
        var playersStillPlaying; // TO DO: gets array of players that haven't surrendered/were defeated
		if (lastPlayer !== serverSideCurrentPlayer) {
			// something went horribly wrong and I have no idea what to do about it. I guess stick to the server-side info then in case of local tampering?
			// lastPlayer = serverSideCurrentPlayer;
		}
        serverSideCurrentPlayer++;
        var viableNextPlayer = false;
        while(viableNextPlayer === false) {
            if (playersStillPlaying.indexOf(serverSideCurrentPlayer) !== -1) {
                viableNextPlayer = true;
            } else {
                serverSideCurrentPlayer++;
                if (serverSideCurrentPlayer > 3) {
                    serverSideCurrentPlayer = 0;
                    // request game state information from all players
                    socket.to(GRID).emit('request game state info');
                }
                if (serverSideCurrentPlayer === lastPlayer) {
                    // only 1 player remaining
                    // TO DO: declare victory of player
                    // TO DO (later stage of development): check if victory is better suited for grimm (e.g.: 2 kingdoms under control of the grimm)
                }
            }
        }
		// TO DO: save serverSideCurrentPlayer in database
        var sFirstCardID; // TO DO: get drawPile[0] from database
        var sSecondCardID; // TO DO: get drawPile[1] from database
        var nOfCapitalsByPlayer; // TO DO: get nOfCapitalsByPlayer from database
        // TO DO: remake to accompany new server-side card drawing (draw from drawpile)
        if (nOfCapitalsByPlayer[serverSideCurrentPlayer] > 0) {
            // TEST: could setTimeout function of sDrawFromDrawPile cause asynchrony with socket command?
            sDrawFromDrawPile(GRID, serverSideCurrentPlayer, sFirstCardID, sSecondCardID);
            socket.to(GRID).emit('next turn', serverSideCurrentPlayer, true);
            // TO DO: update database with serverSideCurrentPlayer, and firstCard (and secondCard if !== -1) removed from drawpile array
        } else {
            socket.to(GRID).emit('next turn', serverSideCurrentPlayer, false);
        }
	}
    // socket.on('create draw pile', function(referenceCards) {
    // });
    var drawPile = [];
    var EoWIDs = [];
    function createDrawPile(GRID, sReferenceCards) {
        // create draw pile
        for (var i = 0; i < referenceCards.length; i++) {
            var EoWIDs = [];
            if (referenceCards[i].stage === 1 && referenceCards[i].name !== 'Evolution of Warfare') {
                // TO DO: 
                drawPile.push(referenceCards[i].id);
                // ON LIVE: remove line
                nOfCards[4]++;
            } else if (referenceCards[i].name === 'Evolution of Warfare') {
                EoWIDs.push(i);
            }
        }
        // TO DO: save Evolution of Warfare ID array in database
        deckShuffle(GRID, drawPile, true);
    }
    function deckShuffle(GRID, array, dealCardsAfterwards) {
        var m = array.length, t, i;
        while (m) {
            i = Math.floor(Math.random() * m--);
            t = array[m];
            array[m] = array[i];
            array[i] = t;
        }
        drawPile = array;
        if (dealCardsAfterwards === true) {
            dealCards(GRID, drawPile);
        }
    }
    // For every player, there's an array of cards on their hand (1), cards in play (2), and card in their discard pile (3)
    var altCardPiles = [[/*drawpile*/], [/*p1*/], [], [], [/*p2*/], [], [], [/*p3*/], [], [], [/*p4*/], [], []];
    function dealCards(GRID, drawPile) {
        for (var cards = 0; cards < 5; cards++) {
            for (var p = 0; p < 4; p++) {
                altCardPiles[((p * 3) + 1)].push(drawPile[0]);
                drawPile.splice(0,1);
                // ON LIVE: remove line
                nOfCards[p]++;
            }
        }
        // socket.to(GRID).emit('send player hands 1');
    }
    function sDrawFromDrawPile(GRID, sNewPlayerTurn, sFirstCardID, sSecondCardID) {
        // TO DO: get first drawPile card from database
        var evolutionOfWarfareTime = 0;
        var tempDrawnCard = firstCardID;
        if (sReferenceCards[firstCardID].name = 'Evolution of Warfare') {
            tempDrawnCard = secondCardID;
            evolutionOfWarfareTime = 4300;
            drawPile.splce(0,1);
            socket.to(GRID).emit('evolution of warfare', firstCardID);
            setTimeout(function() {
                stageOfWar++;
                for (var ref = 0; ref < sReferenceCards.length; ref++) {
                    if (sReferenceCards[ref].stage === stageOfWar) {
                        drawPile.push(sReferenceCards[ref].id);
                        nOfCards[4]++;
                    }
                }
                deckShuffle(GRID, drawPile, false);
                // TO DO: store new drawPile and draw new next card
            }, evolutionOfWarfareTime);
        }
        setTimeout(function() {
            socket.to(GRID).emit('draw from drawpile', sNewPlayerTurn, tempDrawnCard);
            altCardPiles[((sNewPlayerTurn * 3) + 1)].push(tempDrawnCard);
            drawPile.splice(0,1);
            nOfCards[4]--;
        }, evolutionOfWarfareTime);
    }
    /*
    socket.on('response send player hands 1', function(sPlayerNumber) {
        socket.emit('send player hands 2', altCardPiles[((playerNumber * 3) + 1)]);
    });

    socket.on('response game state info', function(GRID, playerNumber, nOfCapitals, stageOfWar, cardHistory, altCardPiles[((playerNumber * 3) + 1)], altCardPiles[((playerNumber * 3) + 2)], altCardPiles[((playerNumber * 3) + 3)], forgedArmistice, frostDustBombs, liquidDeath, rustingMists, trappingPit) {
        // TO DO: store data in database
    });
    socket.on('capital taken over', function(sNewOwner, sOldOwner, sTerID) {
        var nOfCapitalsByPlayer; // TO DO: get nOfCapitalsByPlayer from database
        nOfCapitalsByPlayer[sNewOwner]++;
        nOfCapitalsByPlayer[sOldOwner]--;
        if (nOfCapitalsByPlayer[sNewOwner] === 4) {
            socket.to(GRID).emit('player victory', sNewOwner);
            // TO DO: anounce victory
        } else if (nOfCapitalsByPlayer[sOldOwner] === 0) {
            // TO DO: check surrender/defeat conditions
        }
        // TO DO: store nOfCapitalsByPlayer in database
        socket.emit('capital taken over', sNewOwner, sOldOwner, sTerID);
    });
    // socket.on('player surrenders', function(sPlayerNumber) {
        socket.to(GRID).emit('player surrenders', sPlayerNumber);
        removePlayerFromGame(sPlayerNumber);
    });
    // socket.on('player defeated', function(sPlayerNumber) {
        socket.to(GRID).emit('player surrenders', sPlayerNumber);
        removePlayerFromGame(sPlayerNumber);
    });
    function removePlayerFromGame(sPlayerNumber) {
        var playersStillPlaying; // TO DO: gets array of players that haven't surrendered/were defeated
        playersStillPlaying.splice(playersStillPlaying.indexOf(sPlayerNumber), 1);
        // TO DO: update database with new playersStillPlaying
    }

    socket.on('EoW IDs', function(EoWIDs) {
        // TO DO: save Evolution of Warfare ID array in database
    });
    socket.on('clear card visuals', function(GRID, sPlayerNumber) {
        socket.to(GRID).emit('clear card visuals', sPlayerNumber);
    });
    socket.on('push to discard pile', function(GRID, sPlayerNumber, sCardID) {
        socket.to(GRID).emit('push to discard pile', sPlayerNumber, sCardID);
    });
    socket.on('push to actives pile', function(GRID, sPlayerNumber, sCardID) {
        socket.to(GRID).emit('push to actives pile', sPlayerNumber, sCardID);
    });
    socket.on('draw picked card', function(GRID, sPlayerNumber, sTargetPlayer, sActiveCard, sCardID) {
        socket.to(GRID).emit('draw picked card', sPlayerNumber, sTargetPlayer, sActiveCard, sCardID);
    });
    socket.on('draw from drawpile', function(GRID, sPlayerNumber, sNewPlayerTurn, sReferenceCards, sFirstCardID, sSecondCardID) {
        sDrawFromDrawPile(GRID, sPlayerNumber, sNewPlayerTurn, sReferenceCards, sFirstCardID, sSecondCardID);
    });
    socket.on('wait for discard', function(GRID, sPlayerNumber) {
        socket.emit('wait for discard', sPlayerNumber);
    });
    socket.on('end of wait for discard', function(GRID, sPlayerNumber) {
        socket.emit('end of wait for discard', sPlayerNumber);
    });

    socket.on('show played trap', function(GRID, sRecipientPlayer, sAttackingPlayer, sDefendingPlayer, sActiveTer, sTargetTerID, sAttackingUnits, sTargetedUnits, firstTrap) {
        socket.to(GRID).emit('show played trap', sRecipientPlayer, sAttackingPlayer, sDefendingPlayer, sActiveTer, sTargetTerID, sAttackingUnits, sTargetedUnits, firstTrap);
    });
    socket.on('select trap', function(GRID, sRecipientPlayer, sAttackingPlayer, sDefendingPlayer, sActiveTer, sTargetTerID, sAttackingUnits, sTargetedUnits, firstTrap) {
        socket.to(GRID).emit('select trap', sRecipientPlayer, sAttackingPlayer, sDefendingPlayer, sActiveTer, sTargetTerID, sAttackingUnits, sTargetedUnits, firstTrap);
    });
    socket.on('activate trap', function(GRID, sAttackingPlayer, sDefendingPlayer, sActiveTerID, sTargetTerID, sAttackingUnits, sTargetedUnits, firstTrap, counterTrap) {
        socket.to(GRID).emit('activate trap', sAttackingPlayer, sDefendingPlayer, sActiveTerID, sTargetTerID, sAttackingUnits, sTargetedUnits, firstTrap, counterTrap);
    });
    socket.on('attack ter', function(GRID, sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
        socket.to(GRID).emit('attack ter', sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
    });
    socket.on('draw spoils', function(GRID, sPlayerNumber, tempTarget) {
        socket.to(GRID).emit('draw spoils', sPlayerNumber, tempTarget);
    });
    socket.on('draw random from player', function(GRID, sPlayerNumber, sTargetPlayer, tempPile, tempCardIndex) {
        socket.to(GRID).emit('draw random from player', sPlayerNumber, sTargetPlayer, tempPile, tempCardIndex);
    });

    socket.on('place unit', function(GRID, sPlayerNumber, sCardID, sActiveTer) {
        socket.to(GRID).emit('place unit', sPlayerNumber, sCardID, sActiveTer);
    });
    socket.on('move to ter', function(GRID, sPlayerNumber, sActiveUnits, sActiveTer, sTargetTerID) {
        socket.to(GRID).emit('move to ter', sPlayerNumber, sActiveUnits, sActiveTer, sTargetTerID);
    });

    // trap cards
        socket.on('push to forgedArmistice', function(GRID, sPlayerNumber, sTargetPlayer, sTurnsLeft) {
            socket.to(GRID).emit('push to forgedArmistice', sPlayerNumber, sTargetPlayer, sTurnsLeft);
        });
        socket.on('assault of the giant nevermore', function(GRID, sPlayerNumber, sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sTarget, sTargetEnemy, sTargetAlly) {
            socket.to(GRID).emit('assault of the giant nevermore', sPlayerNumber, sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sTarget, sTargetEnemy, sTargetAlly);
        });
        socket.on('frost dust bombs', function(GRID, sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sTurnsLeft) {
            socket.to(GRID).emit('frost dust bombs', sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sTurnsLeft);
        });
        socket.on('liquid death', function(GRID, sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sUnitID, sTurnsLeft) {
            socket.to(GRID).emit('liquid death', sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sUnitID, sTurnsLeft);
        });
        socket.on('minefield', function(GRID, sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
            socket.to(GRID).emit('minefield', sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
        });
        socket.on('naval minefield', function(GRID, sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
            socket.to(GRID).emit('naval minefield', sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
        });
        socket.on('royal reinstatement', function(GRID, sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
            socket.to(GRID).emit('royal reinstatement', sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
        });
        socket.on('rusting mists', function(GRID, sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap) {
            socket.to(GRID).emit('rusting mists', sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap);
        });
        socket.on('stealthy commandeering', function(GRID, sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sUnitID) {
            socket.to(GRID).emit('stealthy commandeering', sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sUnitID);
        });
        socket.on('trapping pit', function(GRID, sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sTurnsLeft) {
            socket.to(GRID).emit('trapping pit', sPlayerNumber, attackingPlayer, defendingPlayer, sActiveTerID, sTargetTerID, attackingUnits, sTargetedUnits, firstTrap, counterTrap, sTurnsLeft);
        });

    // utility cards
        socket.on('place amethyst grove saboteur', function(GRID, sPlayerNumber, sTargetPlayer, sActiveCard, sCardID) {
            socket.to(GRID).emit('place amethyst grove saboteur', sPlayerNumber, sTargetPlayer, sActiveCard, sCardID);
        });
        socket.on('place atlesian engineers', function(GRID, sPlayerNumber, sActiveCard) {
            socket.to(GRID).emit('place atlesian engineers', sPlayerNumber, sActiveCard);
        });
        socket.on('place desert scavenge', function(GRID, sPlayerNumber, sActiveCard) {
            socket.to(GRID).emit('place desert scavenge', sPlayerNumber, sActiveCard);
        });
        socket.on('place mistral trade route', function(GRID, sPlayerNumber, sActiveCard) {
            socket.to(GRID).emit('place mistral trade route', sPlayerNumber, sActiveCard);
        });
        socket.on('place schnee dust company', function(GRID, sPlayerNumber, sActiveCard) {
            socket.to(GRID).emit('place schnee dust company', sPlayerNumber, sActiveCard);
        });
        socket.on('place smugglers of wind path', function(GRID, sPlayerNumber, sActiveCard) {
            socket.to(GRID).emit('place smugglers of wind path', sPlayerNumber, sActiveCard);
        });
        socket.on('apply utility', function(GRID, sPlayerNumber, sActiveCard) {
            socket.to(GRID).emit('apply utility', sPlayerNumber, sActiveCard);
        });
        socket.on('apply nh', function(GRID, sPlayerNumber, sActiveCard, sTerID) {
            socket.to(GRID).emit('apply nh', sPlayerNumber, sActiveCard, sTerID);
        });
    */
});